<?xml version="1.0" encoding="UTF-8"?><scriptlibrary xmlns="http://www.lotus.com/dxl" name="utilsLibrary" hide="v3 v4strict" comment="Base64.java+jakarta-oro-2.0.8.jar+LAX+xerces">
<noteinfo unid="83386BC9E526A7F1C32570E700640A7C"/>

<code event="library">
<javaproject class="org/base64/util/Base64.class">
<java name="DataConsumer.java">import java.io.File;
import java.io.InputStream;

import lotus.notes.NotesThread;

public class DataConsumer implements Runnable {
    private InputStream inputStream = null;

    public DataConsumer(InputStream inputStream) {
        this.inputStream = inputStream;
    }

    public void run() {
        Lax lax = new Lax();
        // РЎРѕР·РґР°РµРј РёРЅСЃС‚Р°РЅСЃС‹ РєР»Р°СЃСЃРѕРІ, РєРѕС‚. РѕР±СЂР°Р±Р°С‚С‹РІР°СЋС‚ РєРѕРЅРєСЂРµС‚РЅС‹Рµ СЌР»РµРјРµРЅС‚С‹ XML
        FileData fdata = new FileData("."
                + (new Character(File.separatorChar)).toString());
        GifData gifData = new GifData("."
                + (new Character(File.separatorChar)).toString());
        JpegData jpegData = new JpegData("."
                + (new Character(File.separatorChar)).toString());
        // РџРѕРґРєР»СЋС‡Р°РµРј РёС… Рє Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРѕРјСѓ С…РµРЅРґР»РµСЂСѓ
        // РІ РєР»Р°СЃСЃРµ Рґ.Р±. РјРµС‚РѕРґС‹ textOf&lt;СЌР»РµРјРµРЅС‚&gt; (РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРґРµСЂР¶РёРјРѕРіРѕ) Рё
        // start&lt;СЌР»РµРјРµРЅС‚&gt;, end&lt;СЌР»РµРјРµРЅС‚&gt; - РґР»СЏ СѓСЃР»РѕРІРёР№ РЅР°С‡Р°Р»Р° Рё РѕРєРѕРЅС‡Р°РЅРёСЏ
        // СЌР»РµРјРµРЅС‚Р°
        lax.addHandler(jpegData);
        lax.addHandler(gifData);
        lax.addHandler(fdata);
        System.out.println("procesing...");
        lax.parseDocument(true, lax, inputStream);
    }
}</java>
<java name="DataSource.java">import java.io.BufferedWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import lotus.domino.*;

public class DataSource implements Runnable {
    private Document doc = null;
    private OutputStream outs = null;

    public DataSource(Document xdoc, OutputStream stream) {
        outs = stream;
        doc = xdoc;
    }

    @Override
    public void run() {
        try {
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outs,
                    "utf-8"));
            System.out.println("*" +this.getClass().getName()+" -&gt;doc's generating...");
            doc.generateXML(bw);
            bw.flush();
            outs.flush();
            outs.close();
            System.out.println("*" +this.getClass().getName()+" -&gt;doc's been generated");
            outs = null;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            System.out.println("quit DataSource");
            if (outs != null) {
                try {
                    outs.flush();
                    outs.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</java>
<java name="FileData.java">import org.xml.sax.*;
import java.io.*;
import org.base64.util.*;

public class FileData {
    // private String fileName="";
    private FileOutputStream outFile = null;
    private StringBuffer sBuff = new StringBuffer("");
    private String rootPath = "";
    private String filePath = "";
    private File fobj = null;

    public FileData(String path) {
        super();
        rootPath = path;
    }

    public void textOffiledata(String fileData) {
        // System.out.print(fileData);
        sBuff.append(fileData);
    }

    public void startfile(AttributeList list) {
        // Р·Р° РЅР°Р·РІР°РЅРёРµ Р±РµСЂРµРј СЃРёСЃС‚РµРјРЅРѕРµ РІСЂРµРјСЏ РІ РјСЃ
        filePath = rootPath + list.getValue("name");
        fobj = new File(filePath);
    }

    public void startfiledata(AttributeList list) {
        System.out.print("start file-&gt;");
        openStream(fobj);
    }

    public void endfiledata() {
        closeStream();
        System.out.println("&lt;-end file");
    }

    // *************************************************
    private void openStream(File f) {
        try {
            outFile = new FileOutputStream(f);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void closeStream() {
        try {
            if (outFile != null) {
                outFile.write(Base64.decode(sBuff.toString()));
                outFile.close();
                System.out.println(fobj.getAbsolutePath());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</java>
<java name="GifData.java">import org.xml.sax.*;
import java.io.*;
import org.base64.util.*;

public class GifData {
	//private String fileName="";
//	private OutputStream outStream=null;
	private FileOutputStream outFile=null;
	private StringBuffer sBuff=new StringBuffer("");
	private String rootPath="";
	private String filePath="";

	public GifData(String path){super(); rootPath=path;}

	public void textOfgif(String fileData){
//		System.out.print(fileData);
		sBuff.append(fileData);
	}
	
	public void startgif(AttributeList list){
		System.out.print("start gif-&gt;");
//Р·Р° РЅР°Р·РІР°РЅРёРµ Р±РµСЂРµРј СЃРёСЃС‚РµРјРЅРѕРµ РІСЂРµРјСЏ РІ РјСЃ
		filePath=rootPath + (new Long(System.currentTimeMillis())).toString() + "bin.gif";
//list.getValue();
		openStream(filePath);
	}
	public void endgif(){
		closeStream();		
		System.out.println("&lt;-end gif");
	}
//**********************************************************
	private void openStream(String fName){
		try{
			outFile=new FileOutputStream(fName);
		} catch(Exception e) {
				e.printStackTrace();
		}
	}
	private void closeStream(){
		try{
			if (outFile!=null){
				outFile.write(Base64.decode(sBuff.toString()));
				outFile.close();
				System.out.println(filePath);
			}
		} catch(Exception e) {
				e.printStackTrace();
		}
	}

}

</java>
<java name="JakartaOroWrapper.java">import org.apache.oro.text.regex.*;
import java.util.Vector;

/** This is a simple wrapper around some of the commonly used
  * regular expression methods in the Jakarta ORO class library.
  * This is not meant to be a comprehensive or efficient way of
  * processing regular expression strings and patterns, just an
  * example to get you on your way.
  * &lt;p&gt;
  * For more information about the functionality provided by ORO,
  * along with all of the additional classes and methods that are
  * available, please download or read the javadocs here:
  *		http://jakarta.apache.org/oro
  * &lt;p&gt;
  * Also, if you plan to use the ORO library in your applications,
  * please refer to the license that it is covered under, which can
  * be found at the link above. The library is essentially free to use,
  * but you should make sure you don't violate the Apache license
  * by using or distributing it (especially if you use it in a commercial
  * application).
  * &lt;p&gt;
  * This wrapper class was written by Julian Robichaux, and can be
  * found at http://www.nsftools.com . You may use this code in any
  * way that you like, as long as you don't pretend like you wrote it,
  * and don't indirectly violate the Apache license attached to the
  * included Jakarta ORO library.
  * &lt;p&gt;
  * You are using version 1.0 of the class.
 *
 * @author Julian Robichaux ( http://www.nsftools.com )
 * @version 1.0
  */

/* Examples and Introductions to Regular Expressions
basic examples of using ORO:
	http://www.javaworld.com/javaworld/jw-07-2001/jw-0713-regex_p.html 

quick introductions:
	http://www.macworld.com/2004/02/secrets/regex/index.php
	http://www.newbie.org/gazette/xxaxx/xprmnt02.html
	http://gnosis.cx/publish/programming/regular_expressions.html
	http://jmason.org/software/sitescooper/tao_regexps.html
	
this is a little Microsoft-specific, but I like the Appendix at the bottom:
	http://weblogs.asp.net/rosherove/articles/6863.aspx
*/

public class JakartaOroWrapper {
	// constants used to indicate how we should be matching our patterns
	// (see the javadocs for the Perl5Compiler class for details). For simple
	// regular expression matches, just remember that DEFAULT_MASK is
	// case-sensitive and CASE_INSENSITIVE_MASK is (obviously) not.
	public static int CASE_INSENSITIVE_MASK = Perl5Compiler.CASE_INSENSITIVE_MASK;
	public static int DEFAULT_MASK = Perl5Compiler.DEFAULT_MASK;
	public static int EXTENDED_MASK = Perl5Compiler.EXTENDED_MASK;
	public static int MULTILINE_MASK = Perl5Compiler.MULTILINE_MASK;
	public static int READ_ONLY_MASK = Perl5Compiler.READ_ONLY_MASK;
	public static int SINGLELINE_MASK = Perl5Compiler.SINGLELINE_MASK;
	
	// constant used to indicate that we should substitute all matches, if this is
	// passed as the numSubs parameter in the substitute method below
	public static int SUBSTITUTE_ALL = Util.SUBSTITUTE_ALL;
	
	// set a few of the classes up as global classes, for efficiency
	private PatternCompiler compiler;
	private PatternMatcher matcher;
	private Perl5Substitution sub;
	
	/** Default constructor, which just instantiates the global private members */
	public JakartaOroWrapper () {
		compiler = new Perl5Compiler();
		matcher = new Perl5Matcher();
		sub = new Perl5Substitution();
	}
	
	/** Determine if the input String exactly matches the regular expression pattern */
	public boolean matches (String input, String pattern, boolean isCaseSensitive) 
			throws MalformedPatternException {
		int mask = isCaseSensitive ? DEFAULT_MASK : CASE_INSENSITIVE_MASK;
		Pattern pat = compiler.compile(pattern, mask);
		return matcher.matches(input, pat);
	}
	
	/** Determine if the prefix of the input String matches the regular expression 
	  * pattern */
	public boolean matchesPrefix (String input, String pattern, boolean isCaseSensitive) 
			throws MalformedPatternException {
		int mask = isCaseSensitive ? DEFAULT_MASK : CASE_INSENSITIVE_MASK;
		Pattern pat = compiler.compile(pattern, mask);
		return matcher.matchesPrefix(input, pat);
	}
	
	/** Determine if the input String contains the regular expression pattern */
	public boolean contains (String input, String pattern, boolean isCaseSensitive) 
			throws MalformedPatternException {
		int mask = isCaseSensitive ? DEFAULT_MASK : CASE_INSENSITIVE_MASK;
		Pattern pat = compiler.compile(pattern, mask);
		return matcher.contains(input, pat);
	}
	
	/** Replace the first numSubs occurrences of the regular expression
	  * pattern in the input String with the substitution pattern (or replace all
	  * occurrences if SUBSTITUTE_ALL is used for numSubs) */
	public String substitute (String input, String pattern, boolean isCaseSensitive, 
			String substitution, int numSubs) 
			throws MalformedPatternException {
		int mask = isCaseSensitive ? DEFAULT_MASK : CASE_INSENSITIVE_MASK;
		Pattern pat = compiler.compile(pattern, mask);
		sub.setSubstitution(substitution);
		return Util.substitute(matcher, pat, sub, input, numSubs);
	}
	
	/** Split the input String along the delimiters specified by the pattern,
	  * NOT including the delimiter characters/expressions if the delimiter
	  * pattern has parenthesis. For example, split("/([,-])/", "8-12,15,18")
	  * will return a Vector with elements "8", "12", "15", "18". Normal Perl
	  * functionality will include the delimiters as single elements; if you
	  * want to mimic that functionality, use the Perl5Util.split method. */
	public Vector&lt;String&gt; split (String input, String pattern, boolean isCaseSensitive) 
			throws MalformedPatternException {
		int mask = isCaseSensitive ? DEFAULT_MASK : CASE_INSENSITIVE_MASK;
		Pattern pat = compiler.compile(pattern, mask);
		Vector&lt;String&gt; v = new Vector&lt;String&gt;();
		Util.split(v, matcher, pat, input);
		return v;
	}
	
}


</java>
<java name="JpegData.java">import org.xml.sax.*;
import java.io.*;
import org.base64.util.*;

public class JpegData {
	//private String fileName="";
//	private OutputStream outStream=null;
	private FileOutputStream outFile=null;
	private StringBuffer sBuff=new StringBuffer("");
	private String rootPath="";
	private String filePath="";

	public JpegData(String path){super(); rootPath=path;}

	public void textOfjpeg(String fileData){
		sBuff.append(fileData);
	}
	public void startjpeg(AttributeList list){
//Р·Р° РЅР°Р·РІР°РЅРёРµ Р±РµСЂРµРј СЃРёСЃС‚РµРјРЅРѕРµ РІСЂРµРјСЏ РІ РјСЃ
		System.out.println("start jpeg-&gt;");
		filePath=rootPath + (new Long(System.currentTimeMillis())).toString() + "bin.jpeg";
		openStream(filePath);
	}
	public void endjpeg(){
		closeStream();
		System.out.println("&lt;-end jpeg");
	}
//********************************************************
	private void openStream(String fName){
		try{
			outFile=new FileOutputStream(fName);
		} catch(Exception e) {
				e.printStackTrace();
		}
	}
	private void closeStream(){
		try{
			if (outFile!=null){
				outFile.write(Base64.decode(sBuff.toString()));
				outFile.close();
				System.out.println(filePath);
			}
		} catch(Exception e) {
				e.printStackTrace();
		}
	}

}
</java>
<java name="Lax.java">import org.xml.sax.*;
import java.lang.reflect.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.SAXException;  
import org.xml.sax.SAXParseException;
import java.util.*;
import java.io.*;

public class Lax extends org.xml.sax.HandlerBase {

	// LAX translates XML content into method calls on this object
	private Vector _vecHandlers = null;
	private Vector _vecTags = null;
	private static Class[] _caNoArgs = null;
	private static Class[] _caAttrList = null;
	private static Class[] _caString = null;
	private SimpleErrorHandler _seh = new SimpleErrorHandler();

	// Initialize class arrays used for reflection
	static {
		_caNoArgs = new Class[] {};
		_caAttrList = new Class[] {org.xml.sax.AttributeList.class};
		_caString = new Class[] {java.lang.String.class};
	}
/**
 * Lax default constructor
 */
public Lax() {
	super();
//System.out.println("startLax");
	_vecHandlers = new Vector();
	_vecTags = new Vector();
}
/**
 * Lax ctor with a single handler
 */
public Lax(Object handler_) {
	super();
	_vecHandlers = new Vector();
	_vecTags = new Vector();
	addHandler(handler_);
}
/**
 * Add a handler to the list of handler objects.
 * @param objHandler_ java.lang.Object
 */
public void addHandler(Object objHandler_) {
	_vecHandlers.addElement(objHandler_);
}
/**
 * Handle an incoming block of text by calling the textOf method for the
 * current tag.
 */
public void characters(char[] caChars, int iStart, int iEnd) throws SAXException {
	String sCurrentTag = sCurrentTag();
	
	if (sCurrentTag != null) {
		int i;
		String sTextMethodName = "textOf" + sCurrentTag;
		String sArg = null;
		
		// Call every text method for current tag found in the list of handlers.
		for (i = 0; i &lt; _vecHandlers.size(); i++) {
			Object oThisHandler = _vecHandlers.elementAt(i);
			Method mTextMethod = mFindMethod(oThisHandler, sTextMethodName, _caString);
			if (mTextMethod != null) {
				try {
					if (sArg == null) {
						sArg = new String(caChars, iStart, iEnd);
					}
					mTextMethod.invoke(oThisHandler, new Object[] { sArg });
				} catch (InvocationTargetException ex) {
					System.err.println(ex);
				} catch (IllegalAccessException ex) {
					System.err.println(ex);
				}
			}
		}
	}
}
/**
 * endDocument method comment.
 */
public void endDocument() throws org.xml.sax.SAXException {
}
/**
 * Call all end tag methods in the handler list
 */
public void endElement(String sTag) throws SAXException {
	int i;
	String sEndMethodName = "end" + sTag;

	// Call every tag start method for this tag found in the list of handlers.
	for (i = 0; i &lt; _vecHandlers.size(); i++) {
		Object oThisHandler = _vecHandlers.elementAt(i);
		Method mEndMethod = mFindMethod(oThisHandler, sEndMethodName, _caNoArgs);
		if (mEndMethod != null) {
			try {
				mEndMethod.invoke(oThisHandler, new Object[] {});
			} catch (InvocationTargetException ex) {
				System.err.println(ex);
			} catch (IllegalAccessException ex) {
				System.err.println(ex);
			}
		}
	}
	popTag();
}
/**
 * error method comment.
 */
public void error(SAXParseException ex) throws SAXException {
	_seh.error(ex);
}
/**
 * fatalError method comment.
 */
public void fatalError(SAXParseException ex) throws SAXException {
	_seh.fatalError(ex);
}

/**
 * Return a method of object oHandler 
 * with the given name and argument list, or null if not found
 * @return java.lang.reflect.Method
 * @param oHandler java.lang.Object - The handler object to search for a method.
 * @param sTag java.lang.String - The tag to find.
 */
private Method mFindMethod(Object oHandler, String sMethodName, Class[] caArgs) {
	Method m = null;
	Class classOfHandler = oHandler.getClass();

	// Find a method with the given name and argument list
	try {
		m = classOfHandler.getMethod(sMethodName, caArgs);
	} catch (NoSuchMethodException ex) {
		// Ignore exception - no such method exists.
	}
	return m;
}
/**
 * Reimplement this method to use a parser from a different vendor. See your
 * parser package documentation for details.
 * @param isValidating boolean
 * @param documentHandler org.xml.sax.DocumentHandler
 * @param errorHandler org.xml.sax.ErrorHandler
 * @param sFilename java.lang.String
 */
//InputStream inputstream
protected void parseDocument(boolean isValidating, HandlerBase handler, InputStream xmlIn){ //String sFilename) {
	try {
		// Get a "parser factory", an an object that creates parsers
		SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();

		// Set up the factory to create the appropriate type of parser
		saxParserFactory.setValidating(isValidating);
		saxParserFactory.setNamespaceAware(false); // Not this month...

		SAXParser parser = saxParserFactory.newSAXParser();

//		parser.parse(new File(sFilename), handler);
		parser.parse(xmlIn, handler);
	} catch (Exception ex) {
		System.err.println("Exception: " + ex);
		//System.exit(2);
	}
}
/**
 * Pop tag off of tag stack.
 */
private void popTag() {
	_vecTags.removeElementAt(_vecTags.size() - 1);
}
/**
 * Push tag onto tag stack.
 * @param sTag java.lang.String
 */
private void pushTag(String sTag) {
	_vecTags.addElement(sTag);
}
/**
 * Return tag at top of tag stack. At any particular point in the parse,
 * this string represents the tag being processed.
 * @return java.lang.String
 */
private String sCurrentTag() {
	int iIndex = _vecTags.size() - 1;
	if (iIndex &gt;= 0) {
		return (String)(_vecTags.elementAt(_vecTags.size() - 1));
	} else {
		return null;
	}
}
/**
 * startDocument method comment.
 */
public void startDocument() throws org.xml.sax.SAXException {
}
/**
 * Call all start methods for this tag.
 */
public void startElement(String sTag, AttributeList alAttrs) {
	int i;
	String sStartMethodName = "start" + sTag;

	pushTag(sTag);

	// Call every tag start method for this tag found in the list of handlers.
	for (i = 0; i &lt; _vecHandlers.size(); i++) {
		Object oThisHandler = _vecHandlers.elementAt(i);
		Method mStartMethod = mFindMethod(oThisHandler, sStartMethodName, _caAttrList);
		if (mStartMethod == null) {
			mStartMethod = mFindMethod(oThisHandler, sStartMethodName, _caNoArgs);
		}
		if (mStartMethod != null) {
			try {
				// Call start method with or without attribute list
				Class[] caMethodArgs = mStartMethod.getParameterTypes();
				if (caMethodArgs.length == 0) {
					mStartMethod.invoke(oThisHandler, new Object[] {});
				} else {
					mStartMethod.invoke(oThisHandler, new Object[] {alAttrs});
				}
			} catch (InvocationTargetException ex) {
				System.err.println(ex);
			} catch (IllegalAccessException ex) {
				System.err.println(ex);
			}
		}
	}
}
/**
 * warning method comment.
 */
public void warning(SAXParseException ex) throws SAXException {
	_seh.warning(ex);
}
}</java>
<java name="SimpleErrorHandler.java">import java.io.*;
import org.xml.sax.*;

public class SimpleErrorHandler implements ErrorHandler {
/**
 * SimpleErrorHandler constructor comment.
 */
public SimpleErrorHandler() {
	super();
}
/**
 * error method comment.
 */
public void error(SAXParseException ex) throws SAXException {
//	File fInput = new File (ex.getSystemId());
	System.err.println("SAX Error&gt;" +
		"line " + ex.getLineNumber() + 
		":column " + ex.getColumnNumber() +
		": " + ex);
}
/**
 * fatalError method comment.
 */
public void fatalError(SAXParseException ex) throws SAXException {
//	File fInput = new File(ex.getSystemId());
	System.err.println("SAX Fatal Error&gt;" +
		"line " + ex.getLineNumber() + 
		":column " + ex.getColumnNumber() +
		": " + ex);
}
/**
 * warning method comment.
 */
public void warning(SAXParseException ex) throws SAXException {
//	File fInput = new File(ex.getSystemId());
	System.err.println("SAX Warning&gt;" +
		"line " + ex.getLineNumber() + 
		":column " + ex.getColumnNumber() +
		": " + ex);
}
}
</java>
<java name="org/base64/util/Base64.java">package org.base64.util;

public class Base64
{
    
/* ********  P U B L I C   F I E L D S  ******** */   
    
    
    /** No options specified. Value is zero. */
    public final static int NO_OPTIONS = 0;
    
    /** Specify encoding. */
    public final static int ENCODE = 1;
    
    
    /** Specify decoding. */
    public final static int DECODE = 0;
    
    
    /** Specify that data should be gzip-compressed. */
    public final static int GZIP = 2;
    
    
    /** Don't break lines when encoding (violates strict Base64 specification) */
    public final static int DONT_BREAK_LINES = 8;
    
    
/* ********  P R I V A T E   F I E L D S  ******** */  
    
    
    /** Maximum line length (76) of Base64 output. */
    private final static int MAX_LINE_LENGTH = 76;
    
    
    /** The equals sign (=) as a byte. */
    private final static byte EQUALS_SIGN = (byte)'=';
    
    
    /** The new line character (\n) as a byte. */
    private final static byte NEW_LINE = (byte)'\n';
    
    
    /** Preferred encoding. */
    public final static String PREFERRED_ENCODING = "UTF-8";
    
    
    /** The 64 valid Base64 values. */
private static byte[] ALPHABET;    
    private final static byte[] _NATIVE_ALPHABET = /* May be something funny like EBCDIC */
    {
        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', 
        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', 
        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', 
        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'
    };
    
    /** Determine which ALPHABET to use. */
    static
    {
        byte[] __bytes;
        try
        {
            __bytes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".getBytes( PREFERRED_ENCODING );
        }   // end try
        catch (java.io.UnsupportedEncodingException use)
        {
            __bytes = _NATIVE_ALPHABET; // Fall back to native encoding
        }   // end catch
ALPHABET= __bytes;
    }   // end static
    
    
    /** 
     * Translates a Base64 value to either its 6-bit reconstruction value
     * or a negative number indicating some other meaning.
     **/
    private final static byte[] DECODABET =
    {   
        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
        -5,-5,                                      // Whitespace: Tab and Linefeed
        -9,-9,                                      // Decimal 11 - 12
        -5,                                         // Whitespace: Carriage Return
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
        -9,-9,-9,-9,-9,                             // Decimal 27 - 31
        -5,                                         // Whitespace: Space
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
        62,                                         // Plus sign at decimal 43
        -9,-9,-9,                                   // Decimal 44 - 46
        63,                                         // Slash at decimal 47
        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
        -9,-9,-9,                                   // Decimal 58 - 60
        -1,                                         // Equals sign at decimal 61
        -9,-9,-9,                                      // Decimal 62 - 64
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96
        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
        -9,-9,-9,-9                                 // Decimal 123 - 126
        /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
    };
    
    // I think I end up not using the BAD_ENCODING indicator.
    //private final static byte BAD_ENCODING    = -9; // Indicates error in encoding
    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding
    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding

    
    /** Defeats instantiation. */
    private Base64(){}
    
    
    
/* ********  E N C O D I N G   M E T H O D S  ******** */    
    
    
    /**
     * Encodes up to the first three bytes of array &lt;var&gt;threeBytes&lt;/var&gt;
     * and returns a four-byte array in Base64 notation.
     * The actual number of significant bytes in your array is
     * given by &lt;var&gt;numSigBytes&lt;/var&gt;.
     * The array &lt;var&gt;threeBytes&lt;/var&gt; needs only be as big as
     * &lt;var&gt;numSigBytes&lt;/var&gt;.
     * Code can reuse a byte array by passing a four-byte array as &lt;var&gt;b4&lt;/var&gt;.
     *
     * @param b4 A reusable byte array to reduce array instantiation
     * @param threeBytes the array to convert
     * @param numSigBytes the number of significant bytes in your array
     * @return four byte array in Base64 notation.
     * @since 1.5.1
     */
    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes )
    {
        encode3to4( threeBytes, 0, numSigBytes, b4, 0 );
        return b4;
    }   // end encode3to4

    
    /**
     * Encodes up to three bytes of the array &lt;var&gt;source&lt;/var&gt;
     * and writes the resulting four Base64 bytes to &lt;var&gt;destination&lt;/var&gt;.
     * The source and destination arrays can be manipulated
     * anywhere along their length by specifying 
     * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
     * This method does not check to make sure your arrays
     * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 3 for
     * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 4 for
     * the &lt;var&gt;destination&lt;/var&gt; array.
     * The actual number of significant bytes in your array is
     * given by &lt;var&gt;numSigBytes&lt;/var&gt;.
     *
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param numSigBytes the number of significant bytes in your array
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @return the &lt;var&gt;destination&lt;/var&gt; array
     * @since 1.3
     */
    private static byte[] encode3to4( 
     byte[] source, int srcOffset, int numSigBytes,
     byte[] destination, int destOffset )
    {
        //           1         2         3  
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET
        //          &gt;&gt;18  &gt;&gt;12  &gt;&gt; 6  &gt;&gt; 0  Right shift necessary
        //                0x3f  0x3f  0x3f  Additional AND
        
        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an int.
        int inBuff =   ( numSigBytes &gt; 0 ? ((source[ srcOffset     ] &lt;&lt; 24) &gt;&gt;&gt;  8) : 0 )
                     | ( numSigBytes &gt; 1 ? ((source[ srcOffset + 1 ] &lt;&lt; 24) &gt;&gt;&gt; 16) : 0 )
                     | ( numSigBytes &gt; 2 ? ((source[ srcOffset + 2 ] &lt;&lt; 24) &gt;&gt;&gt; 24) : 0 );

        switch( numSigBytes )
        {
            case 3:
                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];
                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];
                destination[ destOffset + 2 ] = ALPHABET[ (inBuff &gt;&gt;&gt;  6) &amp; 0x3f ];
                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) &amp; 0x3f ];
                return destination;
                
            case 2:
                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];
                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];
                destination[ destOffset + 2 ] = ALPHABET[ (inBuff &gt;&gt;&gt;  6) &amp; 0x3f ];
                destination[ destOffset + 3 ] = EQUALS_SIGN;
                return destination;
                
            case 1:
                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];
                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];
                destination[ destOffset + 2 ] = EQUALS_SIGN;
                destination[ destOffset + 3 ] = EQUALS_SIGN;
                return destination;
                
            default:
                return destination;
        }   // end switch
    }   // end encode3to4
    
    
    
    /**
     * Serializes an object and returns the Base64-encoded
     * version of that serialized object. If the object
     * cannot be serialized or there is another error,
     * the method will return &lt;tt&gt;null&lt;/tt&gt;.
     * The object is not GZip-compressed before being encoded.
     *
     * @param serializableObject The object to encode
     * @return The Base64-encoded object
     * @since 1.4
     */
    public static String encodeObject( java.io.Serializable serializableObject )
    {
        return encodeObject( serializableObject, NO_OPTIONS );
    }   // end encodeObject
    


    /**
     * Serializes an object and returns the Base64-encoded
     * version of that serialized object. If the object
     * cannot be serialized or there is another error,
     * the method will return &lt;tt&gt;null&lt;/tt&gt;.
     * &lt;p&gt;
     * Valid options:&lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DONT_BREAK_LINES: don't break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
     *
     * @param serializableObject The object to encode
     * @param options Specified options
     * @return The Base64-encoded object
     * @see Base64#GZIP
     * @see Base64#DONT_BREAK_LINES
     * @since 2.0
     */
    public static String encodeObject( java.io.Serializable serializableObject, int options )
    {
        // Streams
        java.io.ByteArrayOutputStream  baos  = null; 
        java.io.OutputStream           b64os = null; 
        java.io.ObjectOutputStream     oos   = null; 
        java.util.zip.GZIPOutputStream gzos  = null;
        
        // Isolate options
        int gzip           = (options &amp; GZIP);
        int dontBreakLines = (options &amp; DONT_BREAK_LINES);
        
        try
        {
            // ObjectOutputStream -&gt; (GZIP) -&gt; Base64 -&gt; ByteArrayOutputStream
            baos  = new java.io.ByteArrayOutputStream();
            b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
    
            // GZip?
            if( gzip == GZIP )
            {
                gzos = new java.util.zip.GZIPOutputStream( b64os );
                oos  = new java.io.ObjectOutputStream( gzos );
            }   // end if: gzip
            else
                oos   = new java.io.ObjectOutputStream( b64os );
            
            oos.writeObject( serializableObject );
        }   // end try
        catch( java.io.IOException e )
        {
            e.printStackTrace();
            return null;
        }   // end catch
        finally
        {
            try{ oos.close();   } catch( Exception e ){}
            try{ gzos.close();  } catch( Exception e ){}
            try{ b64os.close(); } catch( Exception e ){}
            try{ baos.close();  } catch( Exception e ){}
        }   // end finally
        
        // Return value according to relevant encoding.
        try 
        {
            return new String( baos.toByteArray(), PREFERRED_ENCODING );
        }   // end try
        catch (java.io.UnsupportedEncodingException uue)
        {
            return new String( baos.toByteArray() );
        }   // end catch
        
    }   // end encode
    
    

    /**
     * Encodes a byte array into Base64 notation.
     * Does not GZip-compress data.
     *
     * @param source The data to convert
     * @since 1.4
     */
    public static String encodeBytes( byte[] source )
    {
        return encodeBytes( source, 0, source.length, NO_OPTIONS );
    }   // end encodeBytes
    


    /**
     * Encodes a byte array into Base64 notation.
     * &lt;p&gt;
     * Valid options:&lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DONT_BREAK_LINES: don't break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
     *
     *
     * @param source The data to convert
     * @param options Specified options
     * @see Base64#GZIP
     * @see Base64#DONT_BREAK_LINES
     * @since 2.0
     */
    public static String encodeBytes( byte[] source, int options )
    {   
        return encodeBytes( source, 0, source.length, options );
    }   // end encodeBytes
    
    
    /**
     * Encodes a byte array into Base64 notation.
     * Does not GZip-compress data.
     *
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @since 1.4
     */
    public static String encodeBytes( byte[] source, int off, int len )
    {
        return encodeBytes( source, off, len, NO_OPTIONS );
    }   // end encodeBytes
    
    

    /**
     * Encodes a byte array into Base64 notation.
     * &lt;p&gt;
     * Valid options:&lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DONT_BREAK_LINES: don't break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
     *
     *
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @param options Specified options
     * @see Base64#GZIP
     * @see Base64#DONT_BREAK_LINES
     * @since 2.0
     */
    public static String encodeBytes( byte[] source, int off, int len, int options )
    {
        // Isolate options
        int dontBreakLines = ( options &amp; DONT_BREAK_LINES );
        int gzip           = ( options &amp; GZIP   );
        
        // Compress?
        if( gzip == GZIP )
        {
            java.io.ByteArrayOutputStream  baos  = null;
            java.util.zip.GZIPOutputStream gzos  = null;
            Base64.OutputStream            b64os = null;
            
    
            try
            {
                // GZip -&gt; Base64 -&gt; ByteArray
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
                gzos  = new java.util.zip.GZIPOutputStream( b64os ); 
            
                gzos.write( source, off, len );
                gzos.close();
            }   // end try
            catch( java.io.IOException e )
            {
                e.printStackTrace();
                return null;
            }   // end catch
            finally
            {
                try{ gzos.close();  } catch( Exception e ){}
                try{ b64os.close(); } catch( Exception e ){}
                try{ baos.close();  } catch( Exception e ){}
            }   // end finally

            // Return value according to relevant encoding.
            try
            {
                return new String( baos.toByteArray(), PREFERRED_ENCODING );
            }   // end try
            catch (java.io.UnsupportedEncodingException uue)
            {
                return new String( baos.toByteArray() );
            }   // end catch
        }   // end if: compress
        
        // Else, don't compress. Better not to use streams at all then.
        else
        {
            // Convert option to boolean in way that code likes it.
            boolean breakLines = dontBreakLines == 0;
            
            int    len43   = len * 4 / 3;
            byte[] outBuff = new byte[   ( len43 )                      // Main 4:3
                                       + ( (len % 3) &gt; 0 ? 4 : 0 )      // Account for padding
                                       + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines      
            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for( ; d &lt; len2; d+=3, e+=4 )
            {
                encode3to4( source, d+off, 3, outBuff, e );

                lineLength += 4;
                if( breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH )
                {   
                    outBuff[e+4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                }   // end if: end of line
            }   // en dfor: each piece of array

            if( d &lt; len )
            {
                encode3to4( source, d+off, len - d, outBuff, e );
                e += 4;
            }   // end if: some padding needed

            
            // Return value according to relevant encoding.
            try
            {
                return new String( outBuff, 0, e, PREFERRED_ENCODING );
            }   // end try
            catch (java.io.UnsupportedEncodingException uue)
            {
                return new String( outBuff, 0, e );
            }   // end catch
            
        }   // end else: don't compress
        
    }   // end encodeBytes
    

    
    
    
/* ********  D E C O D I N G   M E T H O D S  ******** */
    
    
    /**
     * Decodes four bytes from array &lt;var&gt;source&lt;/var&gt;
     * and writes the resulting bytes (up to three of them)
     * to &lt;var&gt;destination&lt;/var&gt;.
     * The source and destination arrays can be manipulated
     * anywhere along their length by specifying 
     * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
     * This method does not check to make sure your arrays
     * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 4 for
     * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 3 for
     * the &lt;var&gt;destination&lt;/var&gt; array.
     * This method returns the actual number of bytes that 
     * were converted from the Base64 encoding.
     * 
     *
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @return the number of decoded bytes converted
     * @since 1.3
     */
    private static int decode4to3( byte[] source, int srcOffset, byte[] destination, int destOffset )
    {
        // Example: Dk==
        if( source[ srcOffset + 2] == EQUALS_SIGN )
        {
            // Two ways to do the same thing. Don't know which way I like best.
            //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
            //              | ( ( DECODABET[ source[ srcOffset + 1] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 );
            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &amp; 0xFF ) &lt;&lt; 18 )
                          | ( ( DECODABET[ source[ srcOffset + 1] ] &amp; 0xFF ) &lt;&lt; 12 );
            
            destination[ destOffset ] = (byte)( outBuff &gt;&gt;&gt; 16 );
            return 1;
        }
        
        // Example: DkL=
        else if( source[ srcOffset + 3 ] == EQUALS_SIGN )
        {
            // Two ways to do the same thing. Don't know which way I like best.
            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 );
            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &amp; 0xFF ) &lt;&lt; 18 )
                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] &amp; 0xFF ) &lt;&lt; 12 )
                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] &amp; 0xFF ) &lt;&lt;  6 );
            
            destination[ destOffset     ] = (byte)( outBuff &gt;&gt;&gt; 16 );
            destination[ destOffset + 1 ] = (byte)( outBuff &gt;&gt;&gt;  8 );
            return 2;
        }
        
        // Example: DkLE
        else
        {
            try{
            // Two ways to do the same thing. Don't know which way I like best.
            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 )
            //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 24 );
            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &amp; 0xFF ) &lt;&lt; 18 )
                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] &amp; 0xFF ) &lt;&lt; 12 )
                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] &amp; 0xFF ) &lt;&lt;  6)
                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] &amp; 0xFF )      );

            
            destination[ destOffset     ] = (byte)( outBuff &gt;&gt; 16 );
            destination[ destOffset + 1 ] = (byte)( outBuff &gt;&gt;  8 );
            destination[ destOffset + 2 ] = (byte)( outBuff       );

            return 3;
            }catch( Exception e){
                System.out.println(""+source[srcOffset]+ ": " + ( DECODABET[ source[ srcOffset     ] ]  ) );
                System.out.println(""+source[srcOffset+1]+  ": " + ( DECODABET[ source[ srcOffset + 1 ] ]  ) );
                System.out.println(""+source[srcOffset+2]+  ": " + ( DECODABET[ source[ srcOffset + 2 ] ]  ) );
                System.out.println(""+source[srcOffset+3]+  ": " + ( DECODABET[ source[ srcOffset + 3 ] ]  ) );
                return -1;
            }   //e nd catch
        }
    }   // end decodeToBytes
    
    
    
    
    /**
     * Very low-level access to decoding ASCII characters in
     * the form of a byte array. Does not support automatically
     * gunzipping or any other "fancy" features.
     *
     * @param source The Base64 encoded data
     * @param off    The offset of where to begin decoding
     * @param len    The length of characters to decode
     * @return decoded data
     * @since 1.3
     */
    public static byte[] decode( byte[] source, int off, int len )
    {
        int    len34   = len * 3 / 4;
        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output
        int    outBuffPosn = 0;
        
        byte[] b4        = new byte[4];
        int    b4Posn    = 0;
        int    i         = 0;
        byte   sbiCrop   = 0;
        byte   sbiDecode = 0;
        for( i = off; i &lt; off+len; i++ )
        {
            sbiCrop = (byte)(source[i] &amp; 0x7f); // Only the low seven bits
            sbiDecode = DECODABET[ sbiCrop ];
            
            if( sbiDecode &gt;= WHITE_SPACE_ENC ) // White space, Equals sign or better
            {
                if( sbiDecode &gt;= EQUALS_SIGN_ENC )
                {
                    b4[ b4Posn++ ] = sbiCrop;
                    if( b4Posn &gt; 3 )
                    {
                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn );
                        b4Posn = 0;
                        
                        // If that was the equals sign, break out of 'for' loop
                        if( sbiCrop == EQUALS_SIGN )
                            break;
                    }   // end if: quartet built
                    
                }   // end if: equals sign or better
                
            }   // end if: white space, equals sign or better
            else
            {
                System.err.println( "Bad Base64 input character at " + i + ": " + source[i] + "(decimal)" );
                return null;
            }   // end else: 
        }   // each input character
                                   
        byte[] out = new byte[ outBuffPosn ];
        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); 
        return out;
    }   // end decode
    
    
    
    
    /**
     * Decodes data from Base64 notation, automatically
     * detecting gzip-compressed data and decompressing it.
     *
     * @param s the string to decode
     * @return the decoded data
     * @since 1.4
     */
    public static byte[] decode( String s )
    {   
        byte[] bytes;
        try
        {
            bytes = s.getBytes( PREFERRED_ENCODING );
        }   // end try
        catch( java.io.UnsupportedEncodingException uee )
        {
            bytes = s.getBytes();
        }   // end catch
		//&lt;/change&gt;
        
        // Decode
        bytes = decode( bytes, 0, bytes.length );
        
        
        // Check to see if it's gzip-compressed
        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
        if( bytes != null &amp;&amp; bytes.length &gt;= 4 )
        {
            
            int head = ((int)bytes[0] &amp; 0xff) | ((bytes[1] &lt;&lt; 8) &amp; 0xff00);       
            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head ) 
            {
                java.io.ByteArrayInputStream  bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int    length = 0;

                try
                {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream( bytes );
                    gzis = new java.util.zip.GZIPInputStream( bais );

                    while( ( length = gzis.read( buffer ) ) &gt;= 0 )
                    {
                        baos.write(buffer,0,length);
                    }   // end while: reading input

                    // No error? Get new bytes.
                    bytes = baos.toByteArray();

                }   // end try
                catch( java.io.IOException e )
                {
                    // Just return originally-decoded bytes
                }   // end catch
                finally
                {
                    try{ baos.close(); } catch( Exception e ){}
                    try{ gzis.close(); } catch( Exception e ){}
                    try{ bais.close(); } catch( Exception e ){}
                }   // end finally

            }   // end if: gzipped
        }   // end if: bytes.length &gt;= 2
        
        return bytes;
    }   // end decode


    

    /**
     * Attempts to decode Base64 data and deserialize a Java
     * Object within. Returns &lt;tt&gt;null&lt;/tt&gt; if there was an error.
     *
     * @param encodedObject The Base64 data to decode
     * @return The decoded and deserialized object
     * @since 1.5
     */
    public static Object decodeToObject( String encodedObject )
    {
        // Decode and gunzip if necessary
        byte[] objBytes = decode( encodedObject );
        
        java.io.ByteArrayInputStream  bais = null;
        java.io.ObjectInputStream     ois  = null;
        Object obj = null;
        
        try
        {
            bais = new java.io.ByteArrayInputStream( objBytes );
            ois  = new java.io.ObjectInputStream( bais );
        
            obj = ois.readObject();
        }   // end try
        catch( java.io.IOException e )
        {
            e.printStackTrace();
            obj = null;
        }   // end catch
        catch( java.lang.ClassNotFoundException e )
        {
            e.printStackTrace();
            obj = null;
        }   // end catch
        finally
        {
            try{ bais.close(); } catch( Exception e ){}
            try{ ois.close();  } catch( Exception e ){}
        }   // end finally
        
        return obj;
    }   // end decodeObject
    
    
    
    /**
     * Convenience method for encoding data to a file.
     *
     * @param dataToEncode byte array of data to encode in base64 form
     * @param filename Filename for saving encoded data
     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
     *
     * @since 2.1
     */
    public static boolean encodeToFile( byte[] dataToEncode, String filename )
    {
        boolean success = false;
        Base64.OutputStream bos = null;
        try
        {
            bos = new Base64.OutputStream( 
                      new java.io.FileOutputStream( filename ), Base64.ENCODE );
            bos.write( dataToEncode );
            success = true;
        }   // end try
        catch( java.io.IOException e )
        {
            
            success = false;
        }   // end catch: IOException
        finally
        {
            try{ bos.close(); } catch( Exception e ){}
        }   // end finally
        
        return success;
    }   // end encodeToFile
    
    
    /**
     * Convenience method for decoding data to a file.
     *
     * @param dataToDecode Base64-encoded data as a string
     * @param filename Filename for saving decoded data
     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
     *
     * @since 2.1
     */
    public static boolean decodeToFile( String dataToDecode, String filename )
    {
        boolean success = false;
        Base64.OutputStream bos = null;
        try
        {
                bos = new Base64.OutputStream( 
                          new java.io.FileOutputStream( filename ), Base64.DECODE );
                bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
                success = true;
        }   // end try
        catch( java.io.IOException e )
        {
            success = false;
        }   // end catch: IOException
        finally
        {
                try{ bos.close(); } catch( Exception e ){}
        }   // end finally
        
        return success;
    }   // end decodeToFile
    
    
    
    
    /**
     * Convenience method for reading a base64-encoded
     * file and decoding it.
     *
     * @param filename Filename for reading encoded data
     * @return decoded byte array or null if unsuccessful
     *
     * @since 2.1
     */
    public static byte[] decodeFromFile( String filename )
    {
        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try
        {
            // Set up some useful variables
            java.io.File file = new java.io.File( filename );
            byte[] buffer = null;
            int length   = 0;
            int numBytes = 0;
            
            // Check for size of file
            if( file.length() &gt; Integer.MAX_VALUE )
            {
                System.err.println( "File is too big for this convenience method (" + file.length() + " bytes)." );
                return null;
            }   // end if: file too big for int index
            buffer = new byte[ (int)file.length() ];
            
            // Open a stream
            bis = new Base64.InputStream( 
                      new java.io.BufferedInputStream( 
                      new java.io.FileInputStream( file ) ), Base64.DECODE );
            
            // Read until done
            while( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )
                length += numBytes;
            
            // Save in a variable to return
            decodedData = new byte[ length ];
            System.arraycopy( buffer, 0, decodedData, 0, length );
            
        }   // end try
        catch( java.io.IOException e )
        {
            System.err.println( "Error decoding from file " + filename );
        }   // end catch: IOException
        finally
        {
            try{ bis.close(); } catch( Exception e) {}
        }   // end finally
        
        return decodedData;
    }   // end decodeFromFile
    
    
    
    /**
     * Convenience method for reading a binary file
     * and base64-encoding it.
     *
     * @param filename Filename for reading binary data
     * @return base64-encoded string or null if unsuccessful
     *
     * @since 2.1
     */
    public static String encodeFromFile( String filename )
    {
        String encodedData = null;
        Base64.InputStream bis = null;
        try
        {
            // Set up some useful variables
            java.io.File file = new java.io.File( filename );
            byte[] buffer = new byte[ (int)(file.length() * 1.4) ];
            int length   = 0;
            int numBytes = 0;
            
            // Open a stream
            bis = new Base64.InputStream( 
                      new java.io.BufferedInputStream( 
                      new java.io.FileInputStream( file ) ), Base64.ENCODE );
            
            // Read until done
            while( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )
                length += numBytes;
            
            // Save in a variable to return
            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );
                
        }   // end try
        catch( java.io.IOException e )
        {
            System.err.println( "Error encoding from file " + filename );
        }   // end catch: IOException
        finally
        {
            try{ bis.close(); } catch( Exception e) {}
        }   // end finally
        
        return encodedData;
        }   // end encodeFromFile
    
    
    
    
    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */
    
    
    
    /**
     * A {@link Base64.InputStream} will read data from another
     * &lt;tt&gt;java.io.InputStream&lt;/tt&gt;, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     *
     * @see Base64
     * @since 1.3
     */
    public static class InputStream extends java.io.FilterInputStream
    {
        private boolean encode;         // Encoding or decoding
        private int     position;       // Current position in the buffer
        private byte[]  buffer;         // Small buffer holding converted data
        private int     bufferLength;   // Length of buffer (3 or 4)
        private int     numSigBytes;    // Number of meaningful bytes in the buffer
        private int     lineLength;
        private boolean breakLines;     // Break lines at less than 80 characters
        
        
        /**
         * Constructs a {@link Base64.InputStream} in DECODE mode.
         *
         * @param in the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
         * @since 1.3
         */
        public InputStream( java.io.InputStream in )
        {   
            this( in, DECODE );
        }   // end constructor
        
        
        /**
         * Constructs a {@link Base64.InputStream} in
         * either ENCODE or DECODE mode.
         * &lt;p&gt;
         * Valid options:&lt;pre&gt;
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DONT_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)
         *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
         * &lt;/pre&gt;
         * &lt;p&gt;
         * Example: &lt;code&gt;new Base64.InputStream( in, Base64.DECODE )&lt;/code&gt;
         *
         *
         * @param in the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
         * @param options Specified options
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DONT_BREAK_LINES
         * @since 2.0
         */
        public InputStream( java.io.InputStream in, int options )
        {   
            super( in );
            this.breakLines   = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;
            this.encode       = (options &amp; ENCODE) == ENCODE;
            this.bufferLength = encode ? 4 : 3;
            this.buffer   = new byte[ bufferLength ];
            this.position = -1;
            this.lineLength = 0;
        }   // end constructor
        
        /**
         * Reads enough of the input stream to convert
         * to/from Base64 and returns the next byte.
         *
         * @return next byte
         * @since 1.3
         */
        public int read() throws java.io.IOException 
        { 
            // Do we need to get data?
            if( position &lt; 0 )
            {
                if( encode )
                {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for( int i = 0; i &lt; 3; i++ )
                    {
                        try
                        { 
                            int b = in.read();
                            
                            // If end of stream, b is -1.
                            if( b &gt;= 0 )
                            {
                                b3[i] = (byte)b;
                                numBinaryBytes++;
                            }   // end if: not end of stream
                            
                        }   // end try: read
                        catch( java.io.IOException e )
                        {   
                            // Only a problem if we got no data at all.
                            if( i == 0 )
                                throw e;
                            
                        }   // end catch
                    }   // end for: each needed input byte
                    
                    if( numBinaryBytes &gt; 0 )
                    {
                        encode3to4( b3, 0, numBinaryBytes, buffer, 0 );
                        position = 0;
                        numSigBytes = 4;
                    }   // end if: got data
                    else
                    {
                        return -1;
                    }   // end else
                }   // end if: encoding
                
                // Else decoding
                else
                {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for( i = 0; i &lt; 4; i++ )
                    {
                        // Read four "meaningful" bytes:
                        int b = 0;
                        do{ b = in.read(); }
                        while( b &gt;= 0 &amp;&amp; DECODABET[ b &amp; 0x7f ] &lt;= WHITE_SPACE_ENC );
                        
                        if( b &lt; 0 )
                            break; // Reads a -1 if end of stream
                        
                        b4[i] = (byte)b;
                    }   // end for: each needed input byte
                    
                    if( i == 4 )
                    {
                        numSigBytes = decode4to3( b4, 0, buffer, 0 );
                        position = 0;
                    }   // end if: got four characters
                    else if( i == 0 ){
                        return -1;
                    }   // end else if: also padded correctly
                    else
                    {
                        // Must have broken out from above.
                        throw new java.io.IOException( "Improperly padded Base64 input." );
                    }   // end 
                    
                }   // end else: decode
            }   // end else: get data
            
            // Got data?
            if( position &gt;= 0 )
            {
                // End of relevant data?
                if( /*!encode &amp;&amp;*/ position &gt;= numSigBytes )
                    return -1;
                
                if( encode &amp;&amp; breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH )
                {
                    lineLength = 0;
                    return '\n';
                }   // end if
                else
                {
                    lineLength++;   // This isn't important when decoding
                                    // but throwing an extra "if" seems
                                    // just as wasteful.
                    
                    int b = buffer[ position++ ];

                    if( position &gt;= bufferLength )
                        position = -1;

                    return b &amp; 0xFF; // This is how you "cast" a byte that's
                                     // intended to be unsigned.
                }   // end else
            }   // end if: position &gt;= 0
            
            // Else error
            else
            {   
                // When JDK1.4 is more accepted, use an assertion here.
                throw new java.io.IOException( "Error in Base64 code reading stream." );
            }   // end else
        }   // end read
        
        
        /**
         * Calls {@link #read()} repeatedly until the end of stream
         * is reached or &lt;var&gt;len&lt;/var&gt; bytes are read.
         * Returns number of bytes read into array or -1 if
         * end of stream is encountered.
         *
         * @param dest array to hold values
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @return bytes read into array or -1 if end of stream is encountered.
         * @since 1.3
         */
        public int read( byte[] dest, int off, int len ) throws java.io.IOException
        {
            int i;
            int b;
            for( i = 0; i &lt; len; i++ )
            {
                b = read();
                
                //if( b &lt; 0 &amp;&amp; i == 0 )
                //    return -1;
                
                if( b &gt;= 0 )
                    dest[off + i] = (byte)b;
                else if( i == 0 )
                    return -1;
                else
                    break; // Out of 'for' loop
            }   // end for: each byte read
            return i;
        }   // end read
        
    }   // end inner class InputStream
    
    
    
    
    
    
    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */
    
    
    
    /**
     * A {@link Base64.OutputStream} will write data to another
     * &lt;tt&gt;java.io.OutputStream&lt;/tt&gt;, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     *
     * @see Base64
     * @since 1.3
     */
    public static class OutputStream extends java.io.FilterOutputStream
    {
        private boolean encode;
        private int     position;
        private byte[]  buffer;
        private int     bufferLength;
        private int     lineLength;
        private boolean breakLines;
        private byte[]  b4; // Scratch used in a few places
        private boolean suspendEncoding;
        
        /**
         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
         *
         * @param out the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be written.
         * @since 1.3
         */
        public OutputStream( java.io.OutputStream out )
        {   
            this( out, ENCODE );
        }   // end constructor
        
        
        /**
         * Constructs a {@link Base64.OutputStream} in
         * either ENCODE or DECODE mode.
         * &lt;p&gt;
         * Valid options:&lt;pre&gt;
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DONT_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)
         *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
         * &lt;/pre&gt;
         * &lt;p&gt;
         * Example: &lt;code&gt;new Base64.OutputStream( out, Base64.ENCODE )&lt;/code&gt;
         *
         * @param out the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be written.
         * @param options Specified options.
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DONT_BREAK_LINES
         * @since 1.3
         */
        public OutputStream( java.io.OutputStream out, int options )
        {   
            super( out );
            this.breakLines   = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;
            this.encode       = (options &amp; ENCODE) == ENCODE;
            this.bufferLength = encode ? 3 : 4;
            this.buffer       = new byte[ bufferLength ];
            this.position     = 0;
            this.lineLength   = 0;
            this.suspendEncoding = false;
            this.b4           = new byte[4];
        }   // end constructor
        
        
        /**
         * Writes the byte to the output stream after
         * converting to/from Base64 notation.
         * When encoding, bytes are buffered three
         * at a time before the output stream actually
         * gets a write() call.
         * When decoding, bytes are buffered four
         * at a time.
         *
         * @param theByte the byte to write
         * @since 1.3
         */
        public void write(int theByte) throws java.io.IOException
        {
            // Encoding suspended?
            if( suspendEncoding )
            {
                super.out.write( theByte );
                return;
            }   // end if: supsended
            
            // Encode?
            if( encode )
            {
                buffer[ position++ ] = (byte)theByte;
                if( position &gt;= bufferLength )  // Enough to encode.
                {
                    out.write( encode3to4( b4, buffer, bufferLength ) );

                    lineLength += 4;
                    if( breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH )
                    {
                        out.write( NEW_LINE );
                        lineLength = 0;
                    }   // end if: end of line

                    position = 0;
                }   // end if: enough to output
            }   // end if: encoding

            // Else, Decoding
            else
            {
                // Meaningful Base64 character?
                if( DECODABET[ theByte &amp; 0x7f ] &gt; WHITE_SPACE_ENC )
                {
                    buffer[ position++ ] = (byte)theByte;
                    if( position &gt;= bufferLength )  // Enough to output.
                    {
                        int len = Base64.decode4to3( buffer, 0, b4, 0 );
                        out.write( b4, 0, len );
                        //out.write( Base64.decode4to3( buffer ) );
                        position = 0;
                    }   // end if: enough to output
                }   // end if: meaningful base64 character
                else if( DECODABET[ theByte &amp; 0x7f ] != WHITE_SPACE_ENC )
                {
                    throw new java.io.IOException( "Invalid character in Base64 data." );
                }   // end else: not white space either
            }   // end else: decoding
        }   // end write
        
        
        
        /**
         * Calls {@link #write(int)} repeatedly until &lt;var&gt;len&lt;/var&gt; 
         * bytes are written.
         *
         * @param theBytes array from which to read bytes
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @since 1.3
         */
        public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
        {
            // Encoding suspended?
            if( suspendEncoding )
            {
                super.out.write( theBytes, off, len );
                return;
            }   // end if: supsended
            
            for( int i = 0; i &lt; len; i++ )
            {
                write( theBytes[ off + i ] );
            }   // end for: each byte written
            
        }   // end write
        
        
        
        /**
         * Method added by PHIL. [Thanks, PHIL. -Rob]
         * This pads the buffer without closing the stream.
         */
        public void flushBase64() throws java.io.IOException 
        {
            if( position &gt; 0 )
            {
                if( encode )
                {
                    out.write( encode3to4( b4, buffer, position ) );
                    position = 0;
                }   // end if: encoding
                else
                {
                    throw new java.io.IOException( "Base64 input not properly padded." );
                }   // end else: decoding
            }   // end if: buffer partially full

        }   // end flush

        
        /** 
         * Flushes and closes (I think, in the superclass) the stream. 
         *
         * @since 1.3
         */
        public void close() throws java.io.IOException
        {
            // 1. Ensure that pending characters are written
            flushBase64();

            // 2. Actually close the stream
            // Base class both flushes and closes.
            super.close();
            
            buffer = null;
            out    = null;
        }   // end close
        
        
        
        /**
         * Suspends encoding of the stream.
         * May be helpful if you need to embed a piece of
         * base640-encoded data in a stream.
         *
         * @since 1.5.1
         */
        public void suspendEncoding() throws java.io.IOException 
        {
            flushBase64();
            this.suspendEncoding = true;
        }   // end suspendEncoding
        
         /**
         * Resumes encoding of the stream.
         * May be helpful if you need to embed a piece of
         * base640-encoded data in a stream.
         *
         * @since 1.5.1
         */
        public void resumeEncoding()
        {
            this.suspendEncoding = false;
        }   // end resumeEncoding
        
        
        
    }   // end inner class OutputStream
    
    
} </java>
<javaarchive name="jakarta-oro-2.0.8.jar">
UEsDBAoAAAAAAAm4nC8AAAAAAAAAAAAAAAAJAAAATUVUQS1JTkYvUEsDBBQACAAIAAi4nC8AAAAA
AAAAAAAAAAAUAAAATUVUQS1JTkYvTUFOSUZFU1QuTUaFj01rAjEQhu+B/Ic5tofEJNuC7M0WChZU
6ErvY3ZWQ91kSSLFf2+6BVFb8Pp+zPvMAr3rKGXxSTG54GvQUnE28xfKbEC7IyhaMZ9lBZy9RsJM
rXg5/hSepBEbM4WH5uBh4WwM6Zgy9Qnm3spHzjhbYk81hLid4HhtEmLgrBnIus5ZzGVIrF3el9A7
fmHMCKuP1W3ijGSkktO/rm9DPPM2ocvfGAnewsG3Y4SzeT/sqSefryYLl/zlkiPXTep6FoxSldBG
lI+1rpWqdfVP5T4LZydQSwcI5vk1dNIAAAB+AQAAUEsDBAoAAAAAAAi4nC8AAAAAAAAAAAAAAAAE
AAAAb3JnL1BLAwQKAAAAAAAIuJwvAAAAAAAAAAAAAAAACwAAAG9yZy9hcGFjaGUvUEsDBAoAAAAA
AAm4nC8AAAAAAAAAAAAAAAAPAAAAb3JnL2FwYWNoZS9vcm8vUEsDBAoAAAAAAAi4nC8AAAAAAAAA
AAAAAAASAAAAb3JnL2FwYWNoZS9vcm8vaW8vUEsDBAoAAAAAAAm4nC8AAAAAAAAAAAAAAAAUAAAA
b3JnL2FwYWNoZS9vcm8vdGV4dC9QSwMECgAAAAAACbicLwAAAAAAAAAAAAAAABoAAABvcmcvYXBh
Y2hlL29yby90ZXh0L3JlZ2V4L1BLAwQKAAAAAAAJuJwvAAAAAAAAAAAAAAAAGAAAAG9yZy9hcGFj
aGUvb3JvL3RleHQvYXdrL1BLAwQKAAAAAAAJuJwvAAAAAAAAAAAAAAAAGQAAAG9yZy9hcGFjaGUv
b3JvL3RleHQvcGVybC9QSwMECgAAAAAACbicLwAAAAAAAAAAAAAAABQAAABvcmcvYXBhY2hlL29y
by91dGlsL1BLAwQUAAgACAAHuJwvAAAAAAAAAAAAAAAAEAAAAE1FVEEtSU5GL0xJQ0VOU0W1Vk1z
m0gQvedXdOmSOIVlO7t7yX7UYjSyJ4VBy4C9vgXDyKYCjGpAVunf7+sBWbITb/aQpUqCYrpfv37d
PcPJe/r9B1xv6D2lD5r8VV7gpsyy3+RWU1gVuu20R9fadpVp6Wx6Bls2D8xqa6v7h57eFUf04fT0
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
AABvcmcvYXBhY2hlL29yby90ZXh0L2F3ay9RdWVzdGlvbk5vZGUuY2xhc3ONUV9LwnAUPVen++My
K00rs7KgqdB6T3qJHqIwIhCshzFt1WhsopPsO/XQPxIS+gB9qOhO9yptMO757Z5z7u75/fx+fQPY
Q1lGHDkFMpZF5INDQcEKVhVGayKKCkSsiygRJMPq9m3Hcwk7Z17vTje7Zufe0r2ep/vW0NfNxwf9
8sn1zWHDu7EOCMm67dr+IWFXiyKoNAnCESOCbLgDxzHbDuO4VrliL6PDo/moadcnlWjzpXrHCf+A
TZoqFKRUqNjgDWYZXAysvm97bmChYhMpEVsqFrAYCOcI27OEx9NwpjoVWUJpFvW815hseRoplqjR
JQzHuvUJ5f/52Ofblfn+CYUgFEYCv7wgf0kzynE/xlWu1t5AI8ReMX3mkQkpaa7ENSY8hz0OKewV
2S6QZ8aIt6ofEGqfSIyQfJnwJCwhGzLzEx6QGkNsjSC9g8JRf1BLBwhHqE6DTwEAAKICAABQSwME
FAAIAAgACbicLwAAAAAAAAAAAAAAACcAAABvcmcvYXBhY2hlL29yby90ZXh0L2F3ay9Ub2tlbk5v
ZGUuY2xhc3N1j8FKAzEQhv/sZrvtdq1VK4L1sN6yKzQPUPGyp0KpB0XQCjXUVUt1IzVgfRtvXjwo
KAUFH8CHEiftXhuYTPLPlz8zv39fPwBa2AzgYbUCF3UfawHldR8bDKWB0eMsZ2ApXfZH+cgcMHgi
7cQnDDzVlxlDeXCnzPAmeyBFpPGZfTa81TmVhOh34q6eXEt1rwiReqKlyaZGqsexPHrKjZr2yKQd
ooxGiBJ8ht1l/LHtxeKWrjBEy8Bupq568964oE4R0UAeDcoo6AvaXQryICWg0xacuVJNdmZgSfMT
zjsWq4qwgLYJcijXkg84zWf4/AXcfS24FdQKLiJjyzW+4Z5ads89b/X5xeEM/G0B/wNQSwcIB/Al
AQ4BAAB4AQAAUEsDBBQACAAIAAm4nC8AAAAAAAAAAAAAAAAoAAAAb3JnL2FwYWNoZS9vcm8vdGV4
dC9wZXJsL1Blcmw1VXRpbC5jbGFzc6VXeXwTxxX+xlpppdXayMZrshgTAwFsWcbQgCDiSLChjVMb
KAm4LqRCWItRKkuOJKeQJm3S0jNNm6ZHCjkgCanalLakjeU4poRepPd9pPd93/dd+t7uSpZsCbu/
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
cmcvYXBhY2hlL29yby90ZXh0L01hdGNoQWN0aW9uSW5mby5jbGFzc4VRTU8CMRB9FRdwRQQUxa+T
B5WDjWeNiXIiWZVAogdPZelCybIlpWv4W55MPPgD/FHGMmv0YrSHvnZm3pvp6/vH6xuAUxz4yGG3
gL0C9hn8WCXyNp30pWFgbYblRYChFozFk+CxSIa8Z41KhucMxXAkTED5pccWQzlSMh705FQYYbUT
OAy0GXIxFeFIcm00t3JuuZFDOecdYa00iZPJE23GUMmapFbFPFAz63KFibCO7LSa/2vdZLUL2jSL
MHgkwHD0B514XTlL40XLvE7tNLUM9WwcpXnHPdg+GGVJ3FMJ5Rvf+es0iqSRg64UAyrJX6hE2UuG
3PHJvTOxpQeyhG00nCe/zUETXIVW6aSdRNpZ8WP3XX8sQ4szLLmPAnw4PXju5NqgQFjECqGPVcIS
1gjLWCesfMWrqBFuYJOwji1CthjN7TvuVqU74DVfwJ5B6xNQSwcI9Ax4X1EBAAAtAgAAUEsDBBQA
CAAIAAm4nC8AAAAAAAAAAAAAAAAtAAAAb3JnL2FwYWNoZS9vcm8vdGV4dC9HZW5lcmljUGF0dGVy
bkNhY2hlLmNsYXNzlVRbU9NAFP62DaSkQe6XCiqgQttQIqCCBcFSLlbKRbnM8MTEdqlhStoJgUF/
jW+++IAzAoPMqE8++KMcz7alcgmKmcmeze53zvnOnm/z89eXrwD6sKqgFZEqtKBPDLofD9AvY8CP
Cgz68RCPxMpjhfaGZAzLeCIjqkBFxIcRYUd9eKpAwZj4GFfgxzMBjgm3CTHEZUzKmJIxzVC1nspt
5c0stxm0ZM7O6EbeSL3hes7O6Q7fc3SbZ/ievmg4DreteAk8wlC5nhJAhraLbjuOmdXj4pNgtZNT
07GV5PJ6PLYYiyeW1xhYgqE6nrO2HcNyVo3sDvdS5Y0UctS0TGeMIRH8S8z/YBlaZZDiuTSxVIx0
urTNMBxMbhq7hp41rIy+5NimlRlJhP4dmOpRpvZSPO+YRJ9hyCXONcNkuFOmI22b74iiNxiik/Gl
hK/pvFXRhRkV7bil4ibaZDxXkcALhs5/JlAxC01GUsUculXMY0HFfXQzDF7tOmdkN3L2Fj89pXKd
DANuXmV8oSuXnZovnszEzsaGkFljwto1sma6g+/lbb69Tehoh4pFvCRpKCpeYUnFshi6sKIiJCoI
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
C3w1LyHXRsiuy7r8C/O6/BO59ayeXR1C0bO1IfIX5giFc8wRU900P5GVj4ZQv6NOiJQgknx0SH1Q
Xrz+hnzSlBAWQGXtEvkRtIM0EbppJLST6mk6wq2DtE/8BVBLBwjKJv2K/wEAAH0DAABQSwMEFAAI
AAgACbicLwAAAAAAAAAAAAAAACYAAABvcmcvYXBhY2hlL29yby91dGlsL0dlbmVyaWNDYWNoZS5j
bGFzc41TTU8TURQ9rzOdgXaKtFawVrGAQD+Q8RM/QLBW0CYQTUASdNE8yqQMDjOknZKUtf/ClSs2
LjChECUSVy78K/4H8b52IGKb6CQz980959y597w3P359OQIwhscBdCHZiRBSKtIBSMiIl1EV10Uc
C0BBRqT1TlrdEKubQdzCbRV3VNxVMa7iHkP305nZ7Ku5xUIu+zKbyy8uM7A8Qyjn2BWX2+4St6qG
RF+MMgQLdnVjxnbLplFhUApFXlwzGJJv5pxySeeb4lV3yo5edU1Lf2bYRtks5kRWiGoTQuPyFYs0
5+fW+RZvEp/zyto83xTwpGmb7hSDnMynlijknFUiB/jq6oxlbBi2yzCSbEotbpf0FyvrRtGdaM0I
daBkuKey4TayVGuKvvnWqNF0PcnUHy3mXaPMXacs8Iq5TT1JyRTZ1FEUU5tujXo3K7NVy2ogrzVc
wn0NFxBhCLdMKtC4houIMQz9l3UaetCr4QESGh5iQsMkHqmY0jCNAYbEv2rQNv89KUOsncqjRxt0
09EXqAa3zO3mrtFo5KtEvoqt3BJHgyHSzkWFXFwQtPAZHylFYOhMglw0PXvlfjq5XfDhHLohI4Yw
IqDDQsfPhyg9yVCIi9xoRLKQnird5CgxL9PqCfzEBsbTB2BpqQ5f+hDScvwAch3+dPwrlDrUd+w4
/h7R9B7U+CEUAXcs7Bz//CTKygxX0EeLflxFwqs7SFXFj9BLGn9mH53zo98RHP0GZQ+BXbbbaChM
kgFPEKPIKIaEYB/Bz9AYTmiDuObRwh7NTzTfRw8eOoUjHqyIVo9O8GGMeHgftSXwiJA3OB+gyjuQ
pSYXvwFQSwcILWxowHQCAAAyBAAAUEsDBBQACAAIAAm4nC8AAAAAAAAAAAAAAAArAAAAb3JnL2Fw
YWNoZS9vcm8vdXRpbC9HZW5lcmljQ2FjaGVFbnRyeS5jbGFzc11PTUsDMRB90627/Ui11vUDvHgR
2j003i1eipSC4EHotaTbUFNDIsu2VP+VhyJ48Af4o8TJHp0w72UeM3mZn9+vbwBDXLQQo9vEAY4D
9AKcJEgTnCY4I8Rz45Z6R6BpKLbKbjSh97BWWyWtciv5uFjrvLwl1Ocv+o2bRsaZ8o7r/nQwYxr7
pRbo4FyggaZAC20BgTbh2hcrqV5V/qylL7zclMbKiXa6MPk4qPeuLPjJ7n83QlpJxssnblbWvKuF
5Y9F/cEMN7xDDEKCiHdkT4Rg24pFxcTZwSHzEd+uUOMDpNknKLvco5bRHlGA+kc1hT9QSwcIRTl1
P/EAAAAyAQAAUEsDBBQACAAIAAm4nC8AAAAAAAAAAAAAAAAkAAAAb3JnL2FwYWNoZS9vcm8vdXRp
bC9DYWNoZUZJRk8yLmNsYXNzjVJNTxNRFD2vnbZ0GJRvrLXIh0CZFkbADwSsMYQqCUhiCERZjEM7
KYPDlAxTInv/hO5YsYWEloQY4oqFP8ON/0K8d6a6oYm0yXn3nTnnzn3vzI/f5xcAxvFCRht642jF
fYY+hn6ZwOcGZAziQQxDcTRhmGGEIc2CURaoLMgwZGMYi2FcIK7rhYrrmo4nIBYFZF333IOXJcNy
BEIb7wWic5ZjeTkBKb04ukbLfLloCoTTvJFLprdgmzu+fzi9tG3sG5ptOCVtZXPbLHizo9cpchnF
4j/XSANXgz5rCrrRo6AdHQo0PFTQiS4FE5iMYUrBIyQFhspuSTN2jcKWqZXdslbxLFt7ZTqmaxXm
mV1w6HAKHnOPJ3iqYJrhGWYUzDI3h6SC56DD9jZq5ffIL+ZXJgX6/vcuujm9EBTpjaUbTTbLHs/Y
tMnTEdyBL3xt7G0tG7v0uO0aSUlQBmy0nKL5iYt9w65Qh/ZGVy/pH80DEll7+Ypt+zFSxs26U9nh
ESxzjx665k55nzPerVDn6ZsFdJ2icFrpewVC9Kfc/IpSo1WC4DgJ79BuwFcA3WryDEINVxFS1VOE
L75JVUgn4B/rE3V9B6kFrTG1tfMMkUDQj7tI1gUawvQKYJC6RDM1xJazl+jJfkfTG2KksVPEpVVC
+Vgc++YJ3EOqbr4ka5TW87/mGSkhXWIgIZF/JpKIZKuQE5FMFc3cLBHxu52oNShf0UVUS059Ryh9
qKLlCG+JCeVYmZr6gqRfhFc/h0WKy4vDq1/h3NHVTzXF+hCL/aMfoim4CBqCidTkKZpruLUebHiG
oKrPEc0E2xpurwcXgj9QSwcIOXLtp28CAAA3BAAAUEsDBBQACAAIAAm4nC8AAAAAAAAAAAAAAAAi
AAAAb3JnL2FwYWNoZS9vcm8vdXRpbC9DYWNoZUxSVS5jbGFzc41SS08TYRQ9M522UKZYXmJpKxQF
ytCHoCLy8oHlEYFGoxAlpg7tBIrDtCnTBvb+Ck00ccPGBSS0GGOIKxb+EH+Geu9MxQVNpMnc13fO
ubff/X78+noCII55D9pxvRFt6GPTz2aATYTNoIeMdap4MISoG7FGeBDncoKjG2yGOR1h1E1G3WJz
241RN+4IcKXTm5qaFSAsWImp5nQrMLRdU4C4ZpcLRa1MwWTOyJnTAqTIwuAKuZl8VhPgiHDiTae3
82XtWX62mDeI6tnQzKSubWuc9EcWt9SymtBVYyORWt/SMubE4PkSsdRs9ow1UIdVR2dFRgBBGR24
LKOTzRjuyrgCv4wuNuOYcGNSxhTCAvryxY2EWlAzm1oiX8wnSmZOT8xphlbMZWa4mjTM4p6MaRbq
Zt17uC/jAZuHmJHxiA+SCMuYxZyAYD09S2jx6XMBPf9rx/ebsYPI2uKFhptgjqmu68Rpsy/EAs6r
O5tLaoGOW84VaU20ECbmjKy2y0FZ1Uuk0FpvD1L6jbZHoNzObEnXrR2/FNCUNkrbPEJO26HDosYb
p8NCiZTHLrat8yUM09tsp/cuQeQlUiTyHi1PW7R8l+WdEHjXZEOUPYELDvJJJXAMQXFUILJxKMoR
pJNvngqc/0KXYypIifPkEzrZc+IKimup1FtR2P/98xD8Y/mrNfk2aiuQdyu+9mO4bYDIb6IGeEXd
JZ6DpMTARzxm3UB8ipUD8WnOQsFU8D28Vq9Qah8NSogHZICYsuDM5chliaSUAP0Lu1UYPfTZrWLU
mFuFCdUwVEXjUvQUHdHv8CwrsSM0HUMm5z0QDizqMHpxrUb9QkQn+c9/qcuxU3THiDou+aVoBV6/
NFRBs+KXbKFDpYpL7zBKeN8H9NZm89HnsEbmhEZmR2jlBXnpdQW+fXRzC75xxo4cobmKllUGOhho
18URbnmWWJ15sLNKFa2r9gXgD1BLBwh6tlel0wIAAAgFAABQSwMEFAAIAAgACbicLwAAAAAAAAAA
AAAAACUAAABvcmcvYXBhY2hlL29yby91dGlsL0NhY2hlUmFuZG9tLmNsYXNzjVNdTxNRED2Xbrt0
uSi0BayAoPLRbpEKfiFgUbFFCMQEDQR9qEt7A4vbXbLdEnn0xRfjH/AP+ExCi9GE+OSDP8o4dxeN
WhJ5mTtzZubMvWdnv//4fAxgHAsa4uhT0a/hEgY0tGAwihgua2T6pHdFw1UMqRiOIooRaUZlLiVz
aWl02ZSRVWPSXFMxriLL0FosuoZddioMseUdY8/I1jzTyq762AxDZNa0TS/HoKQW02t0zDtlwRBK
yUAzyuW8JSrC9hhGU0G/Zdhb2SebO6LkzTQj6TWObvQwdPw7TMV1jglMyvwNjgS6OG7ilorbHHcw
xTDsuFtZY9cobYus4zpB74KwhWuW5iWatz13n+MupjlmpJnFPY4c5jju4wHHQ8xzPMIURx4FhoHT
+Hyi1RNFBv838dcz/Bc+3a96gro6SzXXJUmemRWxYlqWWfX1WpIaLknZIkXP2LSoOf6H4o+N6vaK
sUuSdzaB1L8lSOKRUyRON0Nywp5h1cTvb/p3Vim+EvtUZFYLNcvyL/ecoa1o1ypSQlPQhdmiZCkF
j0y9WD6T9sQdtcVrr2A5hufzkswRV1ScPbkzuzUCp862Js0Q7UaM/gKA0SbTdpAXIp+WiewFigYR
pgyQ0HuPwPQvaNn4hNARlDrCB4Df2Y3kSXWcahmdqt6ROEIkKJjARfSeFLyHggidb/RDqJkGWqeV
pPINPUnlK6LT4WR4rA4tGc7U0XagN8A/oIsq23P6BlnlZR3tHzFEyLnjt2TDDZzfeZeTXBLrnzxE
WwMd60EgqQJP0vkDg7CBzvXgavgJUEsHCC4MKq5bAgAADQQAAFBLAQIUAwoAAAAAAAm4nC8AAAAA
AAAAAAAAAAAJAAAAAAAAAAAAEADtQQAAAABNRVRBLUlORi9QSwECFAMUAAgACAAIuJwv5vk1dNIA
AAB+AQAAFAAAAAAAAAAAAAAApIEnAAAATUVUQS1JTkYvTUFOSUZFU1QuTUZQSwECFAMKAAAAAAAI
uJwvAAAAAAAAAAAAAAAABAAAAAAAAAAAABAA7UE7AQAAb3JnL1BLAQIUAwoAAAAAAAi4nC8AAAAA
AAAAAAAAAAALAAAAAAAAAAAAEADtQV0BAABvcmcvYXBhY2hlL1BLAQIUAwoAAAAAAAm4nC8AAAAA
AAAAAAAAAAAPAAAAAAAAAAAAEADtQYYBAABvcmcvYXBhY2hlL29yby9QSwECFAMKAAAAAAAIuJwv
AAAAAAAAAAAAAAAAEgAAAAAAAAAAABAA7UGzAQAAb3JnL2FwYWNoZS9vcm8vaW8vUEsBAhQDCgAA
AAAACbicLwAAAAAAAAAAAAAAABQAAAAAAAAAAAAQAO1B4wEAAG9yZy9hcGFjaGUvb3JvL3RleHQv
UEsBAhQDCgAAAAAACbicLwAAAAAAAAAAAAAAABoAAAAAAAAAAAAQAO1BFQIAAG9yZy9hcGFjaGUv
b3JvL3RleHQvcmVnZXgvUEsBAhQDCgAAAAAACbicLwAAAAAAAAAAAAAAABgAAAAAAAAAAAAQAO1B
TQIAAG9yZy9hcGFjaGUvb3JvL3RleHQvYXdrL1BLAQIUAwoAAAAAAAm4nC8AAAAAAAAAAAAAAAAZ
AAAAAAAAAAAAEADtQYMCAABvcmcvYXBhY2hlL29yby90ZXh0L3BlcmwvUEsBAhQDCgAAAAAACbic
LwAAAAAAAAAAAAAAABQAAAAAAAAAAAAQAO1BugIAAG9yZy9hcGFjaGUvb3JvL3V0aWwvUEsBAhQD
FAAIAAgAB7icL3nfTL2WBAAAggoAABAAAAAAAAAAAAAAAKSB7AIAAE1FVEEtSU5GL0xJQ0VOU0VQ
SwECFAMUAAgACAAIuJwvR/4oZpoBAADvAwAAKQAAAAAAAAAAAAAApIHABwAAb3JnL2FwYWNoZS9v
cm8vaW8vQXdrRmlsZW5hbWVGaWx0ZXIuY2xhc3NQSwECFAMUAAgACAAIuJwvL4yQDZYCAAB9BgAA
KwAAAAAAAAAAAAAApIGxCQAAb3JnL2FwYWNoZS9vcm8vaW8vUmVnZXhGaWxlbmFtZUZpbHRlci5j
bGFzc1BLAQIUAxQACAAIAAi4nC/osmThnQEAAPEDAAAqAAAAAAAAAAAAAACkgaAMAABvcmcvYXBh
Y2hlL29yby9pby9HbG9iRmlsZW5hbWVGaWx0ZXIuY2xhc3NQSwECFAMUAAgACAAIuJwvCUAybnUB
AACKAwAAKwAAAAAAAAAAAAAApIGVDgAAb3JnL2FwYWNoZS9vcm8vaW8vUGVybDVGaWxlbmFtZUZp
bHRlci5jbGFzc1BLAQIUAxQACAAIAAi4nC+2U1Hf2gAAAPoBAAAuAAAAAAAAAAAAAACkgWMQAABv
cmcvYXBhY2hlL29yby90ZXh0L3JlZ2V4L1BhdHRlcm5NYXRjaGVyLmNsYXNzUEsBAhQDFAAIAAgA
CLicL9A2iMSFAAAAnAAAACcAAAAAAAAAAAAAAKSBmREAAG9yZy9hcGFjaGUvb3JvL3RleHQvcmVn
ZXgvUGF0dGVybi5jbGFzc1BLAQIUAxQACAAIAAi4nC9ClOgR1gMAAOIIAAAzAAAAAAAAAAAAAACk
gXMSAABvcmcvYXBhY2hlL29yby90ZXh0L3JlZ2V4L1BhdHRlcm5NYXRjaGVySW5wdXQuY2xhc3NQ
SwECFAMUAAgACAAIuJwv/0FCO8YAAAAiAQAAKwAAAAAAAAAAAAAApIGqFgAAb3JnL2FwYWNoZS9v
cm8vdGV4dC9yZWdleC9NYXRjaFJlc3VsdC5jbGFzc1BLAQIUAxQACAAIAAi4nC+BqEJcuwAAAOsA
AAA5AAAAAAAAAAAAAACkgckXAABvcmcvYXBhY2hlL29yby90ZXh0L3JlZ2V4L01hbGZvcm1lZFBh
dHRlcm5FeGNlcHRpb24uY2xhc3NQSwECFAMUAAgACAAIuJwvYp37OcQAAAC/AQAALwAAAAAAAAAA
AAAApIHrGAAAb3JnL2FwYWNoZS9vcm8vdGV4dC9yZWdleC9QYXR0ZXJuQ29tcGlsZXIuY2xhc3NQ
SwECFAMUAAgACAAJuJwvj4HuteIUAADPLQAALAAAAAAAAAAAAAAApIEMGgAAb3JnL2FwYWNoZS9v
cm8vdGV4dC9yZWdleC9QZXJsNU1hdGNoZXIuY2xhc3NQSwECFAMUAAgACAAJuJwvex4/HfoAAACC
AQAALwAAAAAAAAAAAAAApIFILwAAb3JnL2FwYWNoZS9vcm8vdGV4dC9yZWdleC9QZXJsNVJlcGV0
aXRpb24uY2xhc3NQSwECFAMUAAgACAAJuJwvac2vRzoCAABHBAAAMAAAAAAAAAAAAAAApIGfMAAA
b3JnL2FwYWNoZS9vcm8vdGV4dC9yZWdleC9QZXJsNU1hdGNoUmVzdWx0LmNsYXNzUEsBAhQDFAAI
AAgACbicLyUNwJQTAgAAhwMAACwAAAAAAAAAAAAAAKSBNzMAAG9yZy9hcGFjaGUvb3JvL3RleHQv
cmVnZXgvUGVybDVQYXR0ZXJuLmNsYXNzUEsBAhQDFAAIAAgACbicL60NRNw6BwAAtg0AADEAAAAA
AAAAAAAAAKSBpDUAAG9yZy9hcGFjaGUvb3JvL3RleHQvcmVnZXgvUGVybDVTdWJzdGl0dXRpb24u
Y2xhc3NQSwECFAMUAAgACAAJuJwvUsRvCcYBAADFAwAAMgAAAAAAAAAAAAAApIE9PQAAb3JnL2Fw
YWNoZS9vcm8vdGV4dC9yZWdleC9TdHJpbmdTdWJzdGl0dXRpb24uY2xhc3NQSwECFAMUAAgACAAJ
uJwvbLf44qUAAAA5AQAALAAAAAAAAAAAAAAApIFjPwAAb3JnL2FwYWNoZS9vcm8vdGV4dC9yZWdl
eC9TdWJzdGl0dXRpb24uY2xhc3NQSwECFAMUAAgACAAJuJwvWuwvQr0CAAAlBQAAMQAAAAAAAAAA
AAAApIFiQAAAb3JnL2FwYWNoZS9vcm8vdGV4dC9yZWdleC9DaGFyU3RyaW5nUG9pbnRlci5jbGFz
c1BLAQIUAxQACAAIAAm4nC/24DE8RAYAAAINAAAmAAAAAAAAAAAAAACkgX5DAABvcmcvYXBhY2hl
L29yby90ZXh0L3JlZ2V4L09wQ29kZS5jbGFzc1BLAQIUAxQACAAIAAm4nC9PbwiHgRsAABk4AAAt
AAAAAAAAAAAAAACkgRZKAABvcmcvYXBhY2hlL29yby90ZXh0L3JlZ2V4L1Blcmw1Q29tcGlsZXIu
Y2xhc3NQSwECFAMUAAgACAAJuJwvrXqAG58GAAD2CgAAKgAAAAAAAAAAAAAApIHyZQAAb3JnL2Fw
YWNoZS9vcm8vdGV4dC9yZWdleC9QZXJsNURlYnVnLmNsYXNzUEsBAhQDFAAIAAgACbicL5OomLUZ
BAAAOgwAACQAAAAAAAAAAAAAAKSB6WwAAG9yZy9hcGFjaGUvb3JvL3RleHQvcmVnZXgvVXRpbC5j
bGFzc1BLAQIUAxQACAAIAAi4nC/suwkl5QAAANEBAAAmAAAAAAAAAAAAAACkgVRxAABvcmcvYXBh
Y2hlL29yby90ZXh0L1BhdHRlcm5DYWNoZS5jbGFzc1BLAQIUAxQACAAIAAi4nC/Ye7bvvQAAAPEA
AAA4AAAAAAAAAAAAAACkgY1yAABvcmcvYXBhY2hlL29yby90ZXh0L01hbGZvcm1lZENhY2hlUGF0
dGVybkV4Y2VwdGlvbi5jbGFzc1BLAQIUAxQACAAIAAi4nC9liaTvJA4AAE8gAAApAAAAAAAAAAAA
AACkgbBzAABvcmcvYXBhY2hlL29yby90ZXh0L2F3ay9Bd2tDb21waWxlci5jbGFzc1BLAQIUAxQA
CAAIAAi4nC+HaEZX+QAAAIsBAAAoAAAAAAAAAAAAAACkgSuCAABvcmcvYXBhY2hlL29yby90ZXh0
L2F3ay9TeW50YXhOb2RlLmNsYXNzUEsBAhQDFAAIAAgACLicL/DoAy9wAgAAQwQAACgAAAAAAAAA
AAAAAKSBeoMAAG9yZy9hcGFjaGUvb3JvL3RleHQvYXdrL1N5bnRheFRyZWUuY2xhc3NQSwECFAMU
AAgACAAIuJwvXW6sfLUBAADWAgAAJgAAAAAAAAAAAAAApIFAhgAAb3JnL2FwYWNoZS9vcm8vdGV4
dC9hd2svTGVhZk5vZGUuY2xhc3NQSwECFAMUAAgACAAIuJwvAvcZ1eMBAACGAwAALAAAAAAAAAAA
AAAApIFJiAAAb3JnL2FwYWNoZS9vcm8vdGV4dC9hd2svQXdrTWF0Y2hSZXN1bHQuY2xhc3NQSwEC
FAMUAAgACAAIuJwvYgVbvSsHAAD8DwAAKAAAAAAAAAAAAAAApIGGigAAb3JnL2FwYWNoZS9vcm8v
dGV4dC9hd2svQXdrTWF0Y2hlci5jbGFzc1BLAQIUAxQACAAIAAi4nC8E5iPkAwMAANoEAAAsAAAA
AAAAAAAAAACkgQeSAABvcmcvYXBhY2hlL29yby90ZXh0L2F3ay9Bd2tTdHJlYW1JbnB1dC5jbGFz
c1BLAQIUAxQACAAIAAm4nC/apeWh+gUAAHgLAAAoAAAAAAAAAAAAAACkgWSVAABvcmcvYXBhY2hl
L29yby90ZXh0L2F3ay9Bd2tQYXR0ZXJuLmNsYXNzUEsBAhQDFAAIAAgACbicL8mPSrrYAAAACwEA
ACYAAAAAAAAAAAAAAKSBtJsAAG9yZy9hcGFjaGUvb3JvL3RleHQvYXdrL0RGQVN0YXRlLmNsYXNz
UEsBAhQDFAAIAAgACbicL2oGLUpOAgAANQQAACUAAAAAAAAAAAAAAKSB4JwAAG9yZy9hcGFjaGUv
b3JvL3RleHQvYXdrL0NhdE5vZGUuY2xhc3NQSwECFAMUAAgACAAJuJwvhc37dp4BAAB9AgAAMAAA
AAAAAAAAAAAApIGBnwAAb3JnL2FwYWNoZS9vcm8vdGV4dC9hd2svQ2hhcmFjdGVyQ2xhc3NOb2Rl
LmNsYXNzUEsBAhQDFAAIAAgACbicL+DJY01aAQAAewIAACkAAAAAAAAAAAAAAKSBfaEAAG9yZy9h
cGFjaGUvb3JvL3RleHQvYXdrL0Vwc2lsb25Ob2RlLmNsYXNzUEsBAhQDFAAIAAgACbicLygTv9Rf
AQAAEAIAADgAAAAAAAAAAAAAAKSBLqMAAG9yZy9hcGFjaGUvb3JvL3RleHQvYXdrL05lZ2F0aXZl
Q2hhcmFjdGVyQ2xhc3NOb2RlLmNsYXNzUEsBAhQDFAAIAAgACbicLwmOeagXAgAAFwQAACQAAAAA
AAAAAAAAAKSB86QAAG9yZy9hcGFjaGUvb3JvL3RleHQvYXdrL09yTm9kZS5jbGFzc1BLAQIUAxQA
CAAIAAm4nC/XD+SBAAEAAMQBAAAmAAAAAAAAAAAAAACkgVynAABvcmcvYXBhY2hlL29yby90ZXh0
L2F3ay9QbHVzTm9kZS5jbGFzc1BLAQIUAxQACAAIAAm4nC8D4H3M4AEAAGkDAAAmAAAAAAAAAAAA
AACkgbCoAABvcmcvYXBhY2hlL29yby90ZXh0L2F3ay9TdGFyTm9kZS5jbGFzc1BLAQIUAxQACAAI
AAm4nC9HqE6DTwEAAKICAAAqAAAAAAAAAAAAAACkgeSqAABvcmcvYXBhY2hlL29yby90ZXh0L2F3
ay9RdWVzdGlvbk5vZGUuY2xhc3NQSwECFAMUAAgACAAJuJwvB/AlAQ4BAAB4AQAAJwAAAAAAAAAA
AAAApIGLrAAAb3JnL2FwYWNoZS9vcm8vdGV4dC9hd2svVG9rZW5Ob2RlLmNsYXNzUEsBAhQDFAAI
AAgACbicL5vHy9QfDQAAih4AACgAAAAAAAAAAAAAAKSB7q0AAG9yZy9hcGFjaGUvb3JvL3RleHQv
cGVybC9QZXJsNVV0aWwuY2xhc3NQSwECFAMUAAgACAAJuJwvbG/fzsEAAAAOAQAAPQAAAAAAAAAA
AAAApIFjuwAAb3JnL2FwYWNoZS9vcm8vdGV4dC9wZXJsL01hbGZvcm1lZFBlcmw1UGF0dGVybkV4
Y2VwdGlvbi5jbGFzc1BLAQIUAxQACAAIAAm4nC8jnGKACwEAAMgBAAA2AAAAAAAAAAAAAACkgY+8
AABvcmcvYXBhY2hlL29yby90ZXh0L3BlcmwvUGFyc2VkU3Vic3RpdHV0aW9uRW50cnkuY2xhc3NQ
SwECFAMUAAgACAAJuJwvUmN00iQBAADfAQAALAAAAAAAAAAAAAAApIH+vQAAb3JnL2FwYWNoZS9v
cm8vdGV4dC9EZWZhdWx0TWF0Y2hBY3Rpb24uY2xhc3NQSwECFAMUAAgACAAJuJwvYbj3gnIAAACV
AAAAJQAAAAAAAAAAAAAApIF8vwAAb3JnL2FwYWNoZS9vcm8vdGV4dC9NYXRjaEFjdGlvbi5jbGFz
c1BLAQIUAxQACAAIAAm4nC/0DHhfUQEAAC0CAAApAAAAAAAAAAAAAACkgUHAAABvcmcvYXBhY2hl
L29yby90ZXh0L01hdGNoQWN0aW9uSW5mby5jbGFzc1BLAQIUAxQACAAIAAm4nC+Pn8nYGgMAAJUG
AAAtAAAAAAAAAAAAAACkgenBAABvcmcvYXBhY2hlL29yby90ZXh0L0dlbmVyaWNQYXR0ZXJuQ2Fj
aGUuY2xhc3NQSwECFAMUAAgACAAJuJwvr+7goUkEAAA5CAAAJgAAAAAAAAAAAAAApIFexQAAb3Jn
L2FwYWNoZS9vcm8vdGV4dC9HbG9iQ29tcGlsZXIuY2xhc3NQSwECFAMUAAgACAAJuJwv/Hs44UwG
AABWDwAALgAAAAAAAAAAAAAApIH7yQAAb3JnL2FwYWNoZS9vcm8vdGV4dC9NYXRjaEFjdGlvblBy
b2Nlc3Nvci5jbGFzc1BLAQIUAxQACAAIAAm4nC/OChbzHwEAAEoCAAAqAAAAAAAAAAAAAACkgaPQ
AABvcmcvYXBhY2hlL29yby90ZXh0L1BhdHRlcm5DYWNoZUZJRk8uY2xhc3NQSwECFAMUAAgACAAJ
uJwv+8faDyABAABMAgAAKwAAAAAAAAAAAAAApIEa0gAAb3JnL2FwYWNoZS9vcm8vdGV4dC9QYXR0
ZXJuQ2FjaGVGSUZPMi5jbGFzc1BLAQIUAxQACAAIAAm4nC/fmz9PHwEAAEgCAAApAAAAAAAAAAAA
AACkgZPTAABvcmcvYXBhY2hlL29yby90ZXh0L1BhdHRlcm5DYWNoZUxSVS5jbGFzc1BLAQIUAxQA
CAAIAAm4nC/hllMZIAEAAE4CAAAsAAAAAAAAAAAAAACkgQnVAABvcmcvYXBhY2hlL29yby90ZXh0
L1BhdHRlcm5DYWNoZVJhbmRvbS5jbGFzc1BLAQIUAxQACAAIAAm4nC+GcDKPmwAAAPIAAAAfAAAA
AAAAAAAAAACkgYPWAABvcmcvYXBhY2hlL29yby91dGlsL0NhY2hlLmNsYXNzUEsBAhQDFAAIAAgA
CbicL8om/Yr/AQAAfQMAACMAAAAAAAAAAAAAAKSBa9cAAG9yZy9hcGFjaGUvb3JvL3V0aWwvQ2Fj
aGVGSUZPLmNsYXNzUEsBAhQDFAAIAAgACbicLy1saMB0AgAAMgQAACYAAAAAAAAAAAAAAKSBu9kA
AG9yZy9hcGFjaGUvb3JvL3V0aWwvR2VuZXJpY0NhY2hlLmNsYXNzUEsBAhQDFAAIAAgACbicL0U5
dT/xAAAAMgEAACsAAAAAAAAAAAAAAKSBg9wAAG9yZy9hcGFjaGUvb3JvL3V0aWwvR2VuZXJpY0Nh
Y2hlRW50cnkuY2xhc3NQSwECFAMUAAgACAAJuJwvOXLtp28CAAA3BAAAJAAAAAAAAAAAAAAApIHN
3QAAb3JnL2FwYWNoZS9vcm8vdXRpbC9DYWNoZUZJRk8yLmNsYXNzUEsBAhQDFAAIAAgACbicL3q2
V6XTAgAACAUAACIAAAAAAAAAAAAAAKSBjuAAAG9yZy9hcGFjaGUvb3JvL3V0aWwvQ2FjaGVMUlUu
Y2xhc3NQSwECFAMUAAgACAAJuJwvLgwqrlsCAAANBAAAJQAAAAAAAAAAAAAApIGx4wAAb3JnL2Fw
YWNoZS9vcm8vdXRpbC9DYWNoZVJhbmRvbS5jbGFzc1BLBQYAAAAASgBKAHgYAABf5gAAAAA=
</javaarchive>
</javaproject>
</code>
<item name="$JavaCompilerSource">
<text>1.6</text>
</item>
<item name="$JavaCompilerTarget">
<text>1.6</text>
</item>
</scriptlibrary>
