<?xml version="1.0" encoding="UTF-8"?><agent xmlns="http://www.lotus.com/dxl" name="CryptoGost" hide="v3" publicaccess="false">
<noteinfo unid="FF0AD064D0DECD7843257E3E00436979"/>



<trigger type="actionsmenu"/>
<documentset type="runonce"/>
<code event="action">
<javaproject class="JavaAgent.class" compiledebug="true">
<java name="Applet_samples/AppletNew/AppletNew.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 07.06.2008 11:20:03 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import javax.swing.*;
import java.applet.Applet;
import java.applet.AppletContext;
import java.awt.*;

/**
 * Applet.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class AppletNew extends Applet {

static AppletContext context;

public void init() {
    //try set SystemLookAndFeel
    try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (ClassNotFoundException e) {
        //ignore
    } catch (InstantiationException e) {
        //ignore
    } catch (IllegalAccessException e) {
        //ignore
    } catch (UnsupportedLookAndFeelException e) {
        //ignore
    }

    //контекст апплета
    AppletNew.context = getAppletContext();

    setLayout(new BorderLayout());
    add(new runStr("Applet Sample"), BorderLayout.NORTH);
    add(new runStr("Applet Sample"), BorderLayout.SOUTH);
    if (Processor.checkJCP()) {
        if (Processor.checkJCPwork()) {
            add(new MainPane().getRootComponent(), BorderLayout.CENTER);
        } else {
            final DownloadPane dp = new DownloadPane();
            dp.setText("\nJCP don't work \nMaybe reinstall it.\n");
            add(dp.getRootComponent(), BorderLayout.CENTER);
        }
    } else {
        final DownloadPane dp = new DownloadPane();
        dp.setText("\nJCP not installed. \nDownload and install JCP.\n");
        add(dp.getRootComponent(), BorderLayout.CENTER);
    }
}

//public void paint(Graphics g) {
//
//}

}
</java>
<java name="Applet_samples/AppletNew/DownloadPane.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 06.06.2008 18:06:42 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.net.MalformedURLException;
import java.net.URL;

/**
 * Панель со ссылкой на дистрибутив.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class DownloadPane {
private JPanel page;
private JButton loadButton;
private JTextPane text;
private GridBagConstraints gbc;

/**
 * Конструктор
 */
public DownloadPane() {
    setupUI();
    text.setBackground(page.getBackground());
    loadButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            try {
                final URL u =
                        new URL("http://www.cryptopro.ru/cryptopro/products/jcp/");
                AppletNew.context.showDocument(u);
            }
            catch (MalformedURLException e1) {
                e1.printStackTrace();
            }
        }
    });
}

/**
 * Получение панели с элементами
 *
 * @return панель
 */
protected JComponent getRootComponent() {
    return page;
}

/**
 * Сообщение в TextArea
 *
 * @param s сообщение
 */
protected void setText(String s) {
    text.setText(s);
}

/**
 * Графический интерфейс
 */
private void setupUI() {
    page = new JPanel();
    page.setLayout(new GridBagLayout());
    loadButton = new JButton();
    loadButton.setText("download JCP");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 1;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 5, 5, 5);
    page.add(loadButton, gbc);
    text = new JTextPane();
    text.setText("");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.fill = 1;
    gbc.insets = new Insets(5, 5, 5, 5);
    page.add(text, gbc);
}
}
</java>
<java name="Applet_samples/AppletNew/JCPKeyPane.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 07.06.2008 11:20:03 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Enumeration;

/**
 * Выбор контейнера.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class JCPKeyPane extends JFrame {

private JPanel page;
private JButton okButton;
private JComboBox keyBox;
private JPanel stores;
private ButtonGroup group;
private Component root;
private Image icon;
private JTextField textF;
private GridBagConstraints gbc;

/**
 * Конструктор
 *
 * @param tit заголовок
 * @param ico иконка
 * @param location относительно какого компонента
 * @param isResizable изменяемы ли размеры
 * @param text поле для вывода информации о ключе (хранилище/имя)
 */
public JCPKeyPane(String tit, Image ico, Component location,
                  boolean isResizable, JTextField text) {
    setupUI();
    icon = ico;
    root = location;
    textF = text;
    keyBox.setPreferredSize(
            new Dimension(150, keyBox.getPreferredSize().height));
    keyBox.setMaximumSize(keyBox.getPreferredSize());
    rButtonPanel("Stores", Processor.getStores(), stores);
    okButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            onOkButton();
        }
    });
    getContentPane().add(getRootComponent());
    setTitle(tit);
    setIconImage(ico);
    setLocationRelativeTo(location);
    setResizable(isResizable);
}

/**
 * выбор контейнера
 */
private void onOkButton() {
    if (keyBox.getSelectedItem() != null) {
        Processor.setKeyAlias(keyBox.getSelectedItem().toString());
        dispose();
        final PassPane pp = new PassPane("Password", icon, root, false, textF);
        pp.pack();
        pp.show();
    } else {
        JOptionPane.showMessageDialog(page, new String[]{
                "No key is selected"
        }, "Error", 0);
    }
}

/**
 * панель с радио-кнопками
 *
 * @param titl название
 * @param options подписи к кнопкам
 * @param panel панель для размещения
 */
protected void rButtonPanel(String titl, String[] options, JPanel panel) {
    panel.setBorder(BorderFactory.createTitledBorder(
            BorderFactory.createEtchedBorder(), titl));
    panel.setLayout(new BoxLayout(panel, 1));
    group = new ButtonGroup();
    final ActionListener listener = new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            viewKeys();
        }
    };
    for (int i = 0; i &lt; options.length; i++) {
        final JRadioButton button = new JRadioButton(options[i]);
        button.setActionCommand(options[i]);
        panel.add(button);
        group.add(button);
        button.setSelected(i == 0);
        button.addActionListener(listener);
    }
}

/**
 * Просмотр ключей
 */
private void viewKeys() {
    keyBox.removeAllItems();
    final String storeName = group.getSelection().getActionCommand();
    Processor.setKeyStoreName(storeName);
    final Enumeration aliases = Processor.getAliases(storeName);
    while (aliases.hasMoreElements()) {
        keyBox.addItem(aliases.nextElement());
    }
}

/**
 * Получение панели с элементами
 *
 * @return панель
 */
protected JComponent getRootComponent() {
    return page;
}

/**
 * Графический интерфейс
 */
private void setupUI() {
    page = new JPanel();
    page.setLayout(new GridBagLayout());
    keyBox = new JComboBox();
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 1;
    gbc.fill = 2;
    gbc.insets = new Insets(5, 5, 5, 5);
    page.add(keyBox, gbc);
    stores = new JPanel();
    stores.setLayout(new GridBagLayout());
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.fill = 1;
    gbc.insets = new Insets(5, 5, 0, 5);
    page.add(stores, gbc);
    okButton = new JButton();
    okButton.setText("Ok");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 2;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 5, 0, 5);
    page.add(okButton, gbc);
}
}</java>
<java name="Applet_samples/AppletNew/MainPane.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 07.06.2008 11:32:39 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import ru.CryptoPro.JCP.tools.Array;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.security.cert.Certificate;
import java.util.List;

/**
 * Main Panel..
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */

public class MainPane {
private JPanel page;
private JTabbedPane tabbedPane;
private JTextPane chSignKeyTextPane;
private JTextField keyTextField;
private JButton chKeyBut;
private JTextField fileTextField;
private JButton chFileBut;
private JTextPane chFileTextPane;
private JButton signatureButton;
private JComboBox modeCBox;
private JTextPane keyTextPane;
private JTextField keyCrTextField;
private JButton keyButton;
private JButton encryptButton;
private JComboBox CBox;
private JTextPane fileTextPane;
private JTextField fileCrTextField;
private JButton fileButton;
private JTextPane certTextPane;
private JTextField certCrTextField;
private JButton certButton;
private JTextPane infoTextPane;
private JTextPane helpTextPane;
private JComboBox signModeCBox;
private JPanel tabSign;
private JPanel signaturePane;
private JPanel infoPane;
private JPanel tabEncr;
private JPanel encryptPane;
private JPanel tabHelp;
private Image ico;
private boolean isENCRYPT;
private GridBagConstraints gbc;

 /**/
public MainPane() {
    setupUI();
    ico = new ImageIcon(getClass().getResource("ico.png")).getImage();
    //background
    chSignKeyTextPane.setBackground(page.getBackground());
    chFileTextPane.setBackground(page.getBackground());
    keyTextPane.setBackground(page.getBackground());
    fileTextPane.setBackground(page.getBackground());
    certTextPane.setBackground(page.getBackground());
    infoTextPane.setBackground(page.getBackground());
    helpTextPane.setBackground(page.getBackground());
    CBox.setBackground(page.getBackground());
    //help
    InputStream is = null;
    String help;
    try {
        is = getClass().getResource("help.txt").openStream();
        final byte[] helpBytes = new byte[is.available()];
        int total = 0;
        int len;
        do {
            len = is.read(helpBytes, total, helpBytes.length - total);
            total += len;
        } while (len &gt; 0);
        help = new String(helpBytes);
    } catch (IOException e) {
        help = e.toString();
    }
    finally {
        if (is != null)
            try {
                is.close();
            } catch (IOException e) {
                //
            }
    }
    helpTextPane.setText(help);
    //actions
    tabbedPane.addChangeListener(new ChangeListener() {
        public void stateChanged(ChangeEvent e) {
            clean();
        }
    });
    //tab Signature
    signModeCBox.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            if (signModeCBox.getSelectedIndex() == 0) {
                clean();
                chSignKeyTextPane.setText("Choose a signature key");
                signatureButton.setText("Generate signature");
            } else if (signModeCBox.getSelectedIndex() == 1) {
                clean();
                chSignKeyTextPane.setText("Choose a certificate");
                signatureButton.setText("Verify signature");
            }
        }
    });
    chKeyBut.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            if (signModeCBox.getSelectedIndex() == 0) {
                final JCPKeyPane kp = new JCPKeyPane("Keys", ico,
                        getRootComponent(), false, keyTextField);
                kp.pack();
                kp.show();
            } else if (signModeCBox.getSelectedIndex() == 1) {
                final List ret = Processor
                        .genCertFromFile(getFile("getCert", ico, keyTextField));
                final String err = (String) ret.get(0);
                if (err == null) {
                    Processor.setCert((Certificate) ret.get(1));
                } else {
                    JOptionPane.showMessageDialog(page, new String[]{err},
                            "Error", JOptionPane.ERROR_MESSAGE);
                    keyTextField.setText("");
                }
            }
        }
    });
    chFileBut.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            Processor.setFile(getFile("Open", ico, fileTextField));
        }
    });
    signatureButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            if (signModeCBox.getSelectedIndex() == 0) {
                if (Processor.getKeyAlias() == null)
                    JOptionPane.showMessageDialog(page,
                            new String[]{"Key not choosed"}, "Error",
                            JOptionPane.ERROR_MESSAGE);
                else if (!Processor.isSetFile()) {
                    JOptionPane.showMessageDialog(page,
                            new String[]{"File not choosed"}, "Error",
                            JOptionPane.ERROR_MESSAGE);
                } else {
                    final File fileToSave = getFile("Save", ico, null);
                    if (fileToSave.exists()) {
                        if (JOptionPane.showConfirmDialog(page, new String[]{
                                "File already exist", "Replace it?"},
                                "Removing", JOptionPane.YES_NO_OPTION,
                                JOptionPane.INFORMATION_MESSAGE) == JOptionPane
                                .YES_OPTION)
                            signAndWrite(fileToSave);
                    } else {
                        signAndWrite(fileToSave);
                    }
                }
            } else if (signModeCBox.getSelectedIndex() == 1)
                if (!Processor.isSetCert())
                    JOptionPane.showMessageDialog(page, new String[]{
                            "Certificate not choosed"
                    }, "Error", JOptionPane.ERROR_MESSAGE);
                else if (!Processor.isSetFile()) {
                    JOptionPane.showMessageDialog(page, new String[]{
                            "File not choosed"
                    }, "Error", JOptionPane.ERROR_MESSAGE);
                } else {
                    final File fileWithSign = getFile("getSignFile", ico, null);
                    final List ret = Processor.signVerify(fileWithSign);
                    final String err = (String) ret.get(0);
                    if (err == null) {
                        if ("true".equals(ret.get(1)))
                            JOptionPane.showMessageDialog(page,
                                    new String[]{"The signature is true"},
                                    "Info", JOptionPane.INFORMATION_MESSAGE);
                        else
                            JOptionPane.showMessageDialog(page,
                                    new String[]{"The signature is not true"},
                                    "Info", JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        JOptionPane.showMessageDialog(page, new String[]{err},
                                "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
        }
    });
    //tab Encryption
    keyButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            final JCPKeyPane kp =
                    new JCPKeyPane("Keys", ico, getRootComponent(),
                            false, keyCrTextField);
            kp.pack();
            kp.show();
        }
    });
    fileButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            Processor.setFile(getFile("Open", ico, fileCrTextField));
        }
    });
    certButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            final List ret = Processor
                    .genCertFromFile(getFile("getCert", ico, certCrTextField));
            final String err = (String) ret.get(0);
            if (err == null) {
                Processor.setCert((Certificate) ret.get(1));
            } else {
                JOptionPane.showMessageDialog(page, new String[]{err}, "Error",
                        JOptionPane.ERROR_MESSAGE);
                certCrTextField.setText("");
            }
        }
    });
    CBox.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            if (((String) CBox.getSelectedItem()).indexOf("encrypt") != -1) {
                isENCRYPT = true;
                encryptButton.setText("Encrypt");
                fileTextPane.setText("Choose file for encryption");
            } else
            if (((String) CBox.getSelectedItem()).indexOf("decrypt") != -1) {
                isENCRYPT = false;
                encryptButton.setText("Decrypt");
                fileTextPane.setText("Choose file for decryption");
            }
        }
    });
    encryptButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            if (CBox.getSelectedIndex() == 0)
                JOptionPane.showMessageDialog(page,
                        new String[]{"Encyption variant not choosed"}, "Error",
                        JOptionPane.ERROR_MESSAGE);
            else if (modeCBox.getSelectedIndex() == 0)
                JOptionPane.showMessageDialog(page,
                        new String[]{"Encyption mode not choosed"}, "Error",
                        JOptionPane.ERROR_MESSAGE);
            else if (Processor.getKeyAlias() == null)
                JOptionPane.showMessageDialog(page,
                        new String[]{"Key not choosed"}, "Error",
                        JOptionPane.ERROR_MESSAGE);
            else if (!Processor.isSetFile()) {
                JOptionPane.showMessageDialog(page,
                        new String[]{"File not choosed"}, "Error",
                        JOptionPane.ERROR_MESSAGE);
            } else {
                final File fileToSave = getFile("Save", ico, null);
                if (fileToSave.exists()) {
                    if (JOptionPane.showConfirmDialog(page,
                            new String[]{"File already exist", "Replace it?"},
                            "Removing", JOptionPane.YES_NO_OPTION,
                            JOptionPane.INFORMATION_MESSAGE) == JOptionPane
                            .YES_OPTION)
                        cryptAndWrite(fileToSave);
                } else if (fileToSave.getName() != null)
                    cryptAndWrite(fileToSave);
            }
        }
    });
}

/**
 * clean
 */
private void clean() {
    Processor.cleanAll();
    keyTextField.setText("");
    fileTextField.setText("");
    keyCrTextField.setText("");
    fileCrTextField.setText("");
    modeCBox.setSelectedIndex(0);
    CBox.setSelectedIndex(0);
}

/**
 * Шифрование
 *
 * @param fileToSave файл для сохранений результата
 */
private void cryptAndWrite(File fileToSave) {
    final String mod;
    if (isENCRYPT)
        mod = "ENCRYPTION";
    else
        mod = "DECRYPTION";
    try {
        final List ret =
                Processor.crypt((String) modeCBox.getSelectedItem(), isENCRYPT);
        final String err = (String) ret.get(0);
        if (err == null) {
            Array.writeFile(fileToSave, (byte[]) ret.get(1));
            JOptionPane.showMessageDialog(page, new String[]{mod,
                    "Text was writing successfully", fileToSave.getPath()},
                    "Info", JOptionPane.INFORMATION_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(page, new String[]{err}, "Error",
                    JOptionPane.ERROR_MESSAGE);
        }
    }
    catch (IOException e) {
        e.printStackTrace();
    }
}

/**
 * Подпись и запись ее в файл
 *
 * @param fileToSave файл для сохранения подписи
 */
private void signAndWrite(File fileToSave) {
    try {
        final List ret = Processor.sign();
        final String err = (String) ret.get(0);
        if (err == null) {
            Array.writeFile(fileToSave, (byte[]) ret.get(1));
            JOptionPane.showMessageDialog(page, new String[]{
                    "Signature was writing successfully", fileToSave.getPath()},
                    "Info", JOptionPane.INFORMATION_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(page, new String[]{err}, "Error",
                    JOptionPane.ERROR_MESSAGE);
        }
    }
    catch (IOException e) {
        e.printStackTrace();
    }
}

/**
 * Получение файла
 *
 * @param option open/save
 * @param field textfield
 * @param icon icon
 * @return file
 */
private static File getFile(String option, Image icon, JTextField field) {
    final JFileChooser chooser = new JFileChooser();
    final JFrame frame = new JFrame();
    frame.setTitle(option);
    frame.setIconImage(icon);
    chooser.setFileSelectionMode(0);
    chooser.setMultiSelectionEnabled(false);
    final int retval = chooser.showDialog(frame, option);
    File selected = null;
    if (retval == 0)
        selected = chooser.getSelectedFile();
    if (selected != null &amp;&amp; field != null)
        field.setText(selected.getPath());
    return selected;
}

/**
 * Получение панели с элементами
 *
 * @return панель
 */
public JComponent getRootComponent() {
    return page;
}

/**
 * Графический интерфейс
 */
private void setupUI() {
    page = new JPanel();
    page.setLayout(new GridBagLayout());
    tabbedPane = new JTabbedPane();
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.gridwidth = 2;
    gbc.fill = 1;
    page.add(tabbedPane, gbc);
    tabSign = new JPanel();
    tabSign.setLayout(new BorderLayout(0, 0));
    tabbedPane.addTab("Signature", null, tabSign, null);
    signatureButton = new JButton();
    signatureButton.setVerticalAlignment(0);
    signatureButton.setText("Generate signature");
    tabSign.add(signatureButton, "South");
    signaturePane = new JPanel();
    signaturePane.setLayout(new GridBagLayout());
    tabSign.add(signaturePane, "Center");
    chSignKeyTextPane = new JTextPane();
    chSignKeyTextPane.setText("Choose a signature key");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 2;
    gbc.gridwidth = 3;
    gbc.fill = 1;
    gbc.insets = new Insets(5, 5, 0, 5);
    signaturePane.add(chSignKeyTextPane, gbc);
    keyTextField = new JTextField();
    gbc = new GridBagConstraints();
    gbc.gridx = 1;
    gbc.gridy = 3;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.ipadx = 200;
    gbc.insets = new Insets(0, 5, 5, 0);
    signaturePane.add(keyTextField, gbc);
    chKeyBut = new JButton();
    chKeyBut.setText("...");
    gbc = new GridBagConstraints();
    gbc.gridx = 2;
    gbc.gridy = 3;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 0, 5, 5);
    signaturePane.add(chKeyBut, gbc);
    chFileTextPane = new JTextPane();
    chFileTextPane.setText("Choose a file ");
    gbc = new GridBagConstraints();
    gbc.gridx = 1;
    gbc.gridy = 4;
    gbc.gridwidth = 2;
    gbc.fill = 1;
    gbc.insets = new Insets(0, 5, 0, 5);
    signaturePane.add(chFileTextPane, gbc);
    fileTextField = new JTextField();
    gbc = new GridBagConstraints();
    gbc.gridx = 1;
    gbc.gridy = 5;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.ipadx = 200;
    gbc.insets = new Insets(0, 5, 5, 0);
    signaturePane.add(fileTextField, gbc);
    chFileBut = new JButton();
    chFileBut.setText("...");
    gbc = new GridBagConstraints();
    gbc.gridx = 2;
    gbc.gridy = 5;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 0, 5, 5);
    signaturePane.add(chFileBut, gbc);
    infoPane = new JPanel();
    infoPane.setLayout(new GridBagLayout());
    gbc = new GridBagConstraints();
    gbc.gridx = 1;
    gbc.gridy = 0;
    gbc.gridwidth = 2;
    gbc.fill = 1;
    gbc.insets = new Insets(5, 5, 5, 5);
    signaturePane.add(infoPane, gbc);
    infoPane.setBorder(BorderFactory.createTitledBorder(
            BorderFactory.createEtchedBorder(), null, 0, 0, null, null));
    infoTextPane = new JTextPane();
    infoTextPane.setText("This is applet sample." + "\n" +
            "You can work with signature (\"Signature\" pane)" + "\n" +
            "and encrypt/decrypt text (\"Encryption\" pane)");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.gridwidth = 2;
    gbc.fill = 1;
    infoPane.add(infoTextPane, gbc);
    signModeCBox = new JComboBox();
    final DefaultComboBoxModel signModeCBoxModel = new DefaultComboBoxModel();
    signModeCBoxModel.addElement("signature generation");
    signModeCBoxModel.addElement("signature verification");
    signModeCBox.setModel(signModeCBoxModel);
    gbc = new GridBagConstraints();
    gbc.gridx = 1;
    gbc.gridy = 1;
    gbc.gridwidth = 2;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.insets = new Insets(5, 5, 5, 5);
    signaturePane.add(signModeCBox, gbc);
    tabEncr = new JPanel();
    tabEncr.setLayout(new BorderLayout(0, 0));
    tabbedPane.addTab("Encryption", null, tabEncr, null);
    encryptButton = new JButton();
    encryptButton.setText("Encrypt");
    tabEncr.add(encryptButton, "South");
    encryptPane = new JPanel();
    encryptPane.setLayout(new GridBagLayout());
    tabEncr.add(encryptPane, "Center");
    CBox = new JComboBox();
    final DefaultComboBoxModel CBoxModel = new DefaultComboBoxModel();
    CBoxModel.addElement("choose variant");
    CBoxModel.addElement("Classic encrypt");
    CBoxModel.addElement("Classic decrypt");
    CBox.setModel(CBoxModel);
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.gridwidth = 3;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.insets = new Insets(5, 5, 5, 5);
    encryptPane.add(CBox, gbc);
    modeCBox = new JComboBox();
    final DefaultComboBoxModel modeCBoxModel = new DefaultComboBoxModel();
    modeCBoxModel.addElement("choose mode");
    modeCBoxModel.addElement("GOST28147/CFB/NoPadding");
    modeCBoxModel.addElement("GOST28147/CNT/NoPadding");
    modeCBoxModel.addElement("GOST28147/CBC/NoPadding");
    modeCBoxModel.addElement("GOST28147/CBC/PKCS5_PADDING");
    modeCBoxModel.addElement("GOST28147/ECB/NoPadding");
    modeCBoxModel.addElement("GOST28147/ECB/PKCS5_PADDING");
    modeCBox.setModel(modeCBoxModel);
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 1;
    gbc.gridwidth = 3;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.insets = new Insets(5, 5, 5, 5);
    encryptPane.add(modeCBox, gbc);
    keyTextPane = new JTextPane();
    keyTextPane.setText("Choose key");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 2;
    gbc.gridwidth = 3;
    gbc.fill = 1;
    gbc.insets = new Insets(0, 5, 0, 5);
    encryptPane.add(keyTextPane, gbc);
    keyCrTextField = new JTextField();
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 3;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.ipadx = 200;
    gbc.insets = new Insets(0, 5, 5, 0);
    encryptPane.add(keyCrTextField, gbc);
    keyButton = new JButton();
    keyButton.setText("...");
    gbc = new GridBagConstraints();
    gbc.gridx = 2;
    gbc.gridy = 3;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 0, 5, 5);
    encryptPane.add(keyButton, gbc);
    fileTextPane = new JTextPane();
    fileTextPane.setText("Choose file");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 6;
    gbc.gridwidth = 3;
    gbc.fill = 1;
    gbc.insets = new Insets(0, 5, 0, 5);
    encryptPane.add(fileTextPane, gbc);
    fileCrTextField = new JTextField();
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 7;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 5, 5, 0);
    encryptPane.add(fileCrTextField, gbc);
    fileButton = new JButton();
    fileButton = fileButton;
    fileButton.setText("...");
    gbc = new GridBagConstraints();
    gbc.gridx = 2;
    gbc.gridy = 7;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 0, 5, 5);
    encryptPane.add(fileButton, gbc);
    certTextPane = new JTextPane();
    certTextPane.setText("Choose certificate");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 4;
    gbc.gridwidth = 3;
    gbc.fill = 1;
    gbc.insets = new Insets(0, 5, 0, 5);
    encryptPane.add(certTextPane, gbc);
    certCrTextField = new JTextField();
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 5;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.ipadx = 200;
    gbc.insets = new Insets(0, 5, 5, 0);
    encryptPane.add(certCrTextField, gbc);
    certButton = new JButton();
    certButton.setText("...");
    gbc = new GridBagConstraints();
    gbc.gridx = 2;
    gbc.gridy = 5;
    gbc.fill = 2;
    gbc.insets = new Insets(0, 0, 5, 5);
    encryptPane.add(certButton, gbc);
    tabHelp = new JPanel();
    tabHelp.setLayout(new GridBagLayout());
    tabbedPane.addTab("Help", null, tabHelp, null);
    helpTextPane = new JTextPane();
    helpTextPane.setText("help");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.fill = 3;
    tabHelp.add(helpTextPane, gbc);
}
}</java>
<java name="Applet_samples/AppletNew/PassPane.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 06.06.2008 18:12:46 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Ввод пароля.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class PassPane extends JFrame {

private JPanel page;
private JPasswordField passField;
private JButton okButton;
private JCheckBox passCheckBox;
private GridBagConstraints gbc;

/**
 * Конструктор
 *
 * @param tit заголовок
 * @param ico иконка
 * @param location относительно какого компонента
 * @param isResizable изменяемы ли размеры
 * @param text поле для вывода информации о ключе (хранилище/имя)
 */
public PassPane(String tit, Image ico, Component location, boolean isResizable,
                final JTextField text) {
    setupUI();
    passCheckBox.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            if (passCheckBox.isSelected())
                passField.setEnabled(true);
            else
                passField.setEnabled(false);
        }
    });
    okButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            final char[] pass;
            if (!passCheckBox.isSelected())
                pass = null;
            else
                pass = passField.getPassword();
            Processor.setKeyPassword(pass);
            if (Processor.readKey()) {
                text.setText(Processor.getKeyStoreName() + " / " +
                        Processor.getKeyAlias());
                dispose();
            } else {
                JOptionPane.showMessageDialog(page, new String[]{
                        "Password is incorrect"
                }, "Error", 0);
                Processor.cleanAll();
                text.setText("");
                dispose();
            }
        }
    });
    getContentPane().add(getRootComponent());
    setTitle(tit);
    setIconImage(ico);
    setLocationRelativeTo(location);
    setResizable(isResizable);
}

/**
 * Получение панели с элементами
 *
 * @return панель
 */
public JComponent getRootComponent() {
    return page;
}

/**
 * Графический интерфейс
 */
private void setupUI() {
    page = new JPanel();
    page.setLayout(new GridBagLayout());
    passField = new JPasswordField();
    passField.setEnabled(false);
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 2;
    gbc.anchor = 17;
    gbc.fill = 2;
    gbc.ipadx = 100;
    gbc.insets = new Insets(5, 5, 5, 5);
    page.add(passField, gbc);
    okButton = new JButton();
    okButton.setText("Ok");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 3;
    gbc.fill = 2;
    gbc.ipadx = 100;
    gbc.insets = new Insets(0, 5, 5, 5);
    page.add(okButton, gbc);
    final JLabel label = new JLabel();
    label.setText("Input container password");
    label.setHorizontalAlignment(0);
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 1;
    gbc.fill = 2;
    gbc.insets = new Insets(5, 5, 0, 5);
    page.add(label, gbc);
    passCheckBox = new JCheckBox();
    passCheckBox.setSelected(false);
    passCheckBox.setText("Container with password");
    gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.anchor = 17;
    gbc.insets = new Insets(5, 5, 0, 5);
    page.add(passCheckBox, gbc);
}
}</java>
<java name="Applet_samples/AppletNew/Processor.java">/**
 * $RCSfile$
 * version $Revision: 36383 $
 * created 07.06.2008 11:32:39 by kunina
 * last modified $Date: 2012-05-31 16:29:48 +0400 (Thu, 31 May 2012) $ by $Author: cross $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import ru.CryptoPro.JCP.KeyStore.KeyStoreConfig;
import ru.CryptoPro.JCP.tools.Array;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

/**
 * Класс для работы с провайдером.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Processor {
/**
 * Хранилище
 */
private static KeyStore store;
/**
 * Тип хранилища (HDImageStore, FloppyStore и т.д.)
 */
private static String storeName;
/**
 * Ключ
 */
private static Key key;
/**
 * Имя контейнера
 */
private static String alias;
/**
 * Пароль на контейнер
 */
private static char[] keyPass;
/**
 * Файл для подписи/шифрования
 */
private static File file;
/**
 * Сертификат второй стороны
 */
private static Certificate cert;

 /**/
public Processor() {
}

/**
 * Проверка установлен ли провайдер
 *
 * @return true/false
 */
protected static boolean checkJCP() {
    boolean ret = false;
    final Provider[] provs = Security.getProviders();
    for (int i = 0; i &lt; provs.length; i++) {
        if ("JCP".equals(provs[i].getName())) {
            ret = true;
            break;
        }
    }
    return ret;
}

/**
 * Простейшая проверка работы провайдера
 *
 * @return true/false
 */
protected static boolean checkJCPwork() {
    boolean ret;
    try {
        Signature.getInstance("GOST3411withGOST3410EL");
        ret = true;
    } catch (NoSuchAlgorithmException e) {
        ret = false;
    }
    return ret;
}

/**
 * Установка типа хранилища
 *
 * @param keyStoreName тип
 */
protected static void setKeyStoreName(String keyStoreName) {
    storeName = keyStoreName;
}

/**
 * Получение типа хранилища
 *
 * @return тип
 */
protected static String getKeyStoreName() {
    return storeName;
}

/**
 * Установка имени контейнера
 *
 * @param keyAlias имя контейнера
 */
protected static void setKeyAlias(String keyAlias) {
    alias = keyAlias;
}

/**
 * Получение имени контейнера
 *
 * @return имя контейнера
 */
protected static String getKeyAlias() {
    return alias;
}

/**
 * Установка пароля на контейнер
 *
 * @param password пароль на контейнер
 */
protected static void setKeyPassword(char[] password) {
    keyPass = password;
}

/**
 * Получение имен типов хранилищ JCP.
 *
 * @return список имен
 */
protected static String[] getStores() {
    final List strs = KeyStoreConfig.getNames();
    final String[] stores = new String[strs.size()];
    for (int i = 0; i &lt; strs.size(); i++) {
        stores[i] = (String) strs.get(i);
    }
    return stores;
}

/**
 * получение списка имен контенеров в данном хранилище
 *
 * @param storeNam тип хранилища
 * @return список имен
 */
protected static Enumeration getAliases(String storeNam) {
    Enumeration aliases = null;
    try {
        final KeyStore ks = KeyStore.getInstance(storeNam);
        store = ks;
        ks.load(null, null);
        aliases = ks.aliases();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    return aliases;
}

/**
 * Чтение ключа
 *
 * @return true/false
 */
protected static boolean readKey() {
    boolean ret = false;
    try {
        key = store.getKey(alias, keyPass);
        ret = true;
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (UnrecoverableKeyException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    }
    return ret;
}

/**
 * Установка пути к исходному файлу
 *
 * @param pfile файл
 */
protected static void setFile(File pfile) {
    file = pfile;
}

/**
 * Задан ли файл
 *
 * @return true/false
 */
protected static boolean isSetFile() {
    return file != null;
}

/**
 * Установка сертификата
 *
 * @param certificate файл
 */
protected static void setCert(Certificate certificate) {
    cert = certificate;
}

/**
 * Задан ли сертификат
 *
 * @return true/false
 */
protected static boolean isSetCert() {
    return cert != null;
}

/**
 * Получение сертификата из файла
 *
 * @param certFile файл сертификата
 * @return сертификат
 */
protected static List genCertFromFile(File certFile) {
    final List ret = new Vector(2);
    String err = null;
    Certificate certif = null;
    try {
        final CertificateFactory cf = CertificateFactory.getInstance("X509");
        if (certFile != null)
            certif = cf.generateCertificate(new FileInputStream(certFile));
    } catch (CertificateException e) {
        err = "Can't generate certificate";
    } catch (FileNotFoundException e) {
        err = e.toString();
    }
    ret.add(0, err);
    ret.add(1, certif);
    return ret;
}

/**
 * Подпись
 *
 * @return подпись
 */
protected static List sign() {
    final List ret = new Vector(2);
    String err = null;
    byte[] signature = null;
    if (file != null)
        try {
            final Signature sign =
                    Signature.getInstance("GOST3411withGOST3410EL");
            sign.initSign((PrivateKey) key);
            sign.update(Array.readFile(file));
            signature = sign.sign();
        } catch (NoSuchAlgorithmException e) {
            err = e.toString();
        } catch (SignatureException e) {
            err = e.toString();
        } catch (InvalidKeyException e) {
            err = e.toString();
        } catch (IOException e) {
            err = e.toString();
        }
    ret.add(0, err);
    ret.add(1, signature);
    return ret;
}

/**
 * Проверка подписи
 *
 * @param fileWithSign файл с подписью
 * @return /
 */
public static List signVerify(File fileWithSign) {
    final List ret = new Vector(2);
    String err = null;
    boolean ver = false;
    if (file != null &amp;&amp; fileWithSign != null)
        try {
            final Signature sig =
                    Signature.getInstance("GOST3411withGOST3410EL");
            sig.initVerify(cert.getPublicKey());
            sig.update(Array.readFile(file));
            ver = sig.verify(Array.readFile(fileWithSign));
        } catch (NoSuchAlgorithmException e) {
            err = e.toString();
        } catch (InvalidKeyException e) {
            err = e.toString();
        } catch (IOException e) {
            err = e.toString();
        } catch (SignatureException e) {
            err = e.toString();
        }
    ret.add(0, err);
    ret.add(1, String.valueOf(ver));
    return ret;
}

/**
 * Шифрование
 *
 * @param mode режим
 * @param isENCRYPT encrypt/decrypt
 * @return encrypted/decrypted text
 */
public static List crypt(String mode, boolean isENCRYPT) {
    final List ret = new Vector(2);
    String err = null;
    final int mod;
    byte[] crypted = null;
    if (isENCRYPT) mod = Cipher.ENCRYPT_MODE;
    else mod = Cipher.DECRYPT_MODE;
    try {
        final KeyAgreement keyAgree = KeyAgreement.getInstance("GOST3410DH");
        //todo iv
        final AlgorithmParameterSpec iv =
                new IvParameterSpec(new byte[]{1, 2, 3, 4, 5, 6, 7, 8});
        keyAgree.init(key, iv, null);//iv
        keyAgree.doPhase(cert.getPublicKey(), true);
        final SecretKey secret = keyAgree.generateSecret("GOST28147");
        final Cipher cipher = Cipher.getInstance(mode);
        cipher.init(mod, secret, iv);//iv
        crypted = cipher.doFinal(Array.readFile(file));
    } catch (NoSuchAlgorithmException e) {
        err = e.toString();
    } catch (NoSuchPaddingException e) {
        err = e.toString();
    } catch (InvalidKeyException e) {
        err = e.toString();
    } catch (BadPaddingException e) {
        err = e.toString();
    } catch (IOException e) {
        err = e.toString();
    } catch (IllegalBlockSizeException e) {
        err = e.toString();
    } catch (InvalidAlgorithmParameterException e) {
        err = e.toString();
    }
    ret.add(0, err);
    ret.add(1, crypted);
    return ret;
}

/**
 * clean
 */
protected static void cleanAll() {
    store = null;
    storeName = null;
    key = null;
    alias = null;
    keyPass = null;
    file = null;
    cert = null;
}
}
</java>
<java name="Applet_samples/AppletNew/runStr.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 07.06.2008 11:32:39 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Applet_samples.AppletNew;

import javax.swing.*;
import java.awt.*;

/**
 * Бегущая строка.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class runStr extends JPanel implements Runnable {
private int x = 0;
private int y = 10;
private int dx = 1;
private int sw;
private String s;

public runStr(String str) {
    setPreferredSize(new Dimension(getPreferredSize().width, 20));
    s = str;
    final Thread th = new Thread(this);
    th.start();
}

protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    g.setColor(new Color(200, 150, 150));
    final FontMetrics fm = getFontMetrics(getFont());
    sw = fm.stringWidth(s);
    g.drawString(s, x, y);

}

public void run() {
    while (true) {
        repaint();
        x += dx;
        if (x + sw &gt; getSize().width) {
            dx = -1;
        }
        if (x &lt; 0) dx = 1;
        try {
            Thread.sleep(20);
        } catch (InterruptedException e) {
            //
        }
    }
}
}
</java>
<java name="CAdES/Configuration.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import org.bouncycastle.tsp.TimeStampToken;
import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.CAdES.CAdESSigner;
import ru.CryptoPro.CAdES.CAdESType;
import ru.CryptoPro.CAdES.exception.CAdESException;
import ru.CryptoPro.JCP.JCP;

import java.io.FileInputStream;
import java.io.IOException;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

/**
 * Различные константы для примеров.
 * 
 * @author Yevgeniy, 17/04/2012
 *
 */
public class Configuration {

	/**
	 * Алиас ключа.
	 */
	private static final String KEY_ALIAS = "gost_exch";
	/**
	 * Пароль к ключу.
	 */
	private static final char[] KEY_PASSWORD = "Pass1234".toCharArray();
	/**
	 * Данные для подписи.
	 */
	public static final byte[] DATA = "Security is only our business.".getBytes();
	/**
	 * Место хранения файлов.
	 */
	public static final String TEST_DIR = "C:\\TESTS\\";
	/**
	 * Имя файла с подписью для сохранения.
	 */
	public static final String SIGNATURE_FILENAME = "CMSSignature.bin";
	/**
	 * Отступ при печати.
	 */
	private static final String TAG = "***";
	/**
	 * Имя файла с CRL для проверки подписи CAdES-BES. Можно быть null.
	 */
	public static final String CRL_FILENAME = "C:\\TESTS\\CRLS\\certcrl.crl";
	/**
	 * Адрес службы штампов.
	 */
	public static final String TSA_ADDRESS = "http://www.cryptopro.ru:80/tsp/";
	
	/**
	 * Загрузка закрытого ключа и цепочки сертификатов из пользовательского
	 * контейнера.
     *
	 * @param chain Цепочка сертификатов. Заполнится после загрузки хранилища.
	 * @return закрытый ключ из контейнера.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws IOException
	 * @throws UnrecoverableKeyException
	 */
	public static PrivateKey loadConfiguration(Collection&lt;X509Certificate&gt; chain) 
		throws KeyStoreException, NoSuchAlgorithmException, CertificateException, 
		IOException, UnrecoverableKeyException {
		
		return loadConfiguration(JCP.HD_STORE_NAME, null, null, Configuration.KEY_ALIAS, 
			Configuration.KEY_PASSWORD, chain);
	}
	
	/**
	 * Загрузка закрытого ключа и цепочки сертификатов из пользовательского
	 * контейнера.
     *
     * @param storeType Тип хранилища.
     * @param storeFile Путь к хранилищу.
     * @param storePassword Пароль хранилища.
     * @param alias Идентификатор ключа.
     * @param password Пароль ключа.
	 * @param chain Цепочка сертификатов. Заполнится после загрузки хранилища.
	 * @return закрытый ключ из контейнера.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws IOException
	 * @throws UnrecoverableKeyException
	 */
	public static PrivateKey loadConfiguration(String storeType, String storeFile,
		char[] storePassword, String alias, char[] password, Collection&lt;X509Certificate&gt; 
		chain) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, 
		IOException, UnrecoverableKeyException {
		
		KeyStore keyStore = KeyStore.getInstance(storeType);
		keyStore.load(storeFile == null ? null : new FileInputStream(storeFile), 
			storePassword);
		
		PrivateKey privateKey = 
			(PrivateKey) keyStore.getKey(alias, password);

		// Получаем цепочку сертификатов. 
		List&lt;Certificate&gt; lChain = 
			Arrays.asList(keyStore.getCertificateChain(alias));
	
		// Конвертируем цепочку в X509Certificate.
		Collection&lt;X509Certificate&gt; xChain = 
			Arrays.asList((lChain).toArray(new X509Certificate[lChain.size()]));
		
		chain.addAll(xChain);
		
		return privateKey;
	}
	
	/**
	 * Вывод информации об отдельной подписи.
	 * 
	 * @param signer Подпись.
	 * @param index Индекс подписи.
	 * @param tab Отступ для удобства печати.
	 */
	private static void printSignerInfo(CAdESSigner signer, int index, String tab) {
		
		X509Certificate signerCert = signer.getSignerCertificate();
		
		System.out.println(tab + " Signature #" + index + " (" + 
			CAdESType.getSignatureTypeName(signer.getSignatureType()) + ")" + 
			(signerCert != null ? (" verified by " + signerCert.getSubjectDN()) : "" ));
						
		if ( signer.getSignatureType() == CAdESType.CAdES_X_Long_Type_1 ) {
							
			TimeStampToken signatureTimeStamp = signer.getSignatureTimestampToken();
			TimeStampToken cadesCTimeStamp = signer.getCAdESCTimestampToken();
			
			if (signatureTimeStamp != null) {
				System.out.println(tab + TAG + " Signature timestamp set: " + 
					signatureTimeStamp.getTimeStampInfo().getGenTime());
			}
			
			if (cadesCTimeStamp != null) {
				System.out.println(tab + TAG + " CAdES-C timestamp set: " + 
					cadesCTimeStamp.getTimeStampInfo().getGenTime());
			}
		}
		
		printCountersignerInfos(signer.getCAdESCountersignerInfos());
	}
	
	/**
	 * Вывод информации о заверителях отдельной подписи.
	 * 
	 * @param countersigners Список заверителей.
	 */
	private static void printCountersignerInfos(CAdESSigner[] countersigners) {
		
		// Заверяющие подписи.
		int countersignerIndex = 1;
		for (CAdESSigner countersigner : countersigners) {
			printSignerInfo(countersigner, countersignerIndex++, TAG);
		}
	}
	
	/**
	 * Вывод информации о подписи: кто подписал, тип подписи, штампы времени.
	 * 
	 * @param signature CAdES подпись.
	 */
	public static void printSignatureInfo(CAdESSignature signature) {
		
		// Список подписей.
		int signerIndex = 1;
		for (CAdESSigner signer : signature.getCAdESSignerInfos()) {
			printSignerInfo(signer, signerIndex++, "");
		}
	}

    /**
     * Выводим информацию о случившейся ошибке. Для CAdESException дополнительно
     * выводится код ошибки.
     *
     * @param e Исключение.
     */
    public static void printCAdESException(Exception e) {

        if (e instanceof CAdESException) {
            System.out.println(e.getMessage() + " (" + ((CAdESException)e).getErrorCode() + ")");
        } else if (e.getCause() instanceof CAdESException) {
            CAdESException ex = (CAdESException)e.getCause();
            System.out.println(ex.getMessage() + " (" + ex.getErrorCode() + ")");
        } else {
            e.printStackTrace();
        }

    }
}
</java>
<java name="CAdES/CountersignatureExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.SignerInformation;
import org.bouncycastle.cms.SignerInformationStore;
import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.CAdES.CAdESSigner;
import ru.CryptoPro.CAdES.CAdESType;
import ru.CryptoPro.JCP.tools.Array;

import java.io.FileInputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * Пример заверения подписи CAdES-BES двумя подписями CAdES-X Long Type 1.
 * 
 * @author Yevgeniy, 17/04/2012
 *
 */
public class CountersignatureExample {

	/**
	 * @param args
	 */
	public static void main(String[] args) throws InvalidAlgorithmParameterException {

		try {
		
			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			PrivateKey privateKey = Configuration.loadConfiguration(chain);

			// 1. Загрузка и "проверка" подписи.
		
			// Читаем подпись из файла.
			byte[] cadesCms = Array.readFile(Configuration.TEST_DIR + Configuration.SIGNATURE_FILENAME);
				
			// Подпись в тесте была совмещенная, потому данные равны null. Предположим, что
			// подписей несколько, тогда лучше указать тип null и положиться на самоопределение
			// типа подписи.
			CAdESSignature cadesSignature = new CAdESSignature(cadesCms, null, null);
		
			// Список CRL.
			List&lt;X509CRL&gt; crlList = null;
						
			// Если задан CRL, то читаем его из файла.
			if (Configuration.CRL_FILENAME != null) {
										
				X509CRL crl = (X509CRL) CertificateFactory.getInstance("X.509")
					.generateCRL(new FileInputStream(Configuration.CRL_FILENAME));
								
				crlList = Collections.singletonList(crl);
				cadesSignature.verify(chain, crlList);
										
			} else {
				cadesSignature.verify(chain);
			}
		
			// Список всех подписантов в исходной подписи.
			Collection&lt;SignerInformation&gt; srcSignerInfos = new ArrayList&lt;SignerInformation&gt;();
			
			for (CAdESSigner signer : cadesSignature.getCAdESSignerInfos()) {
				srcSignerInfos.add(signer.getSignerInfo());
			}
			
			// 2. Заверение подписи.
		
			// Получаем только первую подпись, которую заверим. Остальных не трогаем.
			CAdESSigner srcSigner = cadesSignature.getCAdESSignerInfo(0);
			
			// Исключаем эту подпись из исходного списка, т.к. ее место займет подпись с
			// заверителями.
			srcSignerInfos.remove(srcSigner.getSignerInfo());
					
			// Создаем заверяющую подпись.
			CAdESSignature counterSignature = new CAdESSignature();
					
			// Добавляем заверяющего подписанта. Последний параметр true, что определяет
			// тип подписанта (заверяющий).
			counterSignature.addSigner(privateKey, chain, CAdESType.CAdES_X_Long_Type_1, 
				Configuration.TSA_ADDRESS, true);
					
			// Подписываем данные заверяемой подписи.
			counterSignature.sign(srcSigner.getSignerInfo().getSignature());
					
			// Получаем единственного заверителя.
			CAdESSigner counterSigner = counterSignature.getCAdESSignerInfo(0);

			// Добавляем заверителя, например, 2 раза к исходной подписи.
			srcSigner.addCountersigner(counterSigner.getSignerInfo());
			srcSigner.addCountersigner(counterSigner.getSignerInfo());
					
			// Получаем заверенную подпись.
			SignerInformation newSigner = srcSigner.getSignerInfo();
			
			// Добавляем ее в исходный список подписей.
			srcSignerInfos.add(newSigner);

			CMSSignedData srcCMSSignedData = cadesSignature.getSignedData();
					
			// Обновляем исходную подпись c ее начальным списком подписантов на тот же,
			// но с первым подписантом с заверенной подписью.
			CMSSignedData dstCMSSignedData = CMSSignedData.replaceSigners(srcCMSSignedData, 
				new SignerInformationStore(srcSignerInfos));

			Array.writeFile(Configuration.TEST_DIR + "countersignature_" + Configuration.SIGNATURE_FILENAME, 
				dstCMSSignedData.getEncoded());

			// 3. Проверка заверенной и заверяющих подписей.
		
			// Проверяем подпись.
			cadesSignature = new CAdESSignature(dstCMSSignedData.getEncoded(), null, null);
			cadesSignature.verify(chain, crlList);
		
			Configuration.printSignatureInfo(cadesSignature);
			
		} catch (Exception e) {
            Configuration.printCAdESException(e);
        }
	}
}
</java>
<java name="CAdES/EnhanceExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.SignerInformation;
import org.bouncycastle.cms.SignerInformationStore;
import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.CAdES.CAdESSigner;
import ru.CryptoPro.CAdES.CAdESType;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.tools.Array;

import java.io.FileInputStream;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * Пример усовершенствования подписи CAdES-BES до CAdES-X Long Type 1.
 * 
 * @author Yevgeniy, 17/04/2012
 *
 */
public class EnhanceExample {

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		try {
			
			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			Configuration.loadConfiguration(chain);

			// 1. Загрузка и "проверка" подписи. 
		
			// Читаем подпись из файла.
			byte[] cadesCms = Array.readFile(Configuration.TEST_DIR + Configuration.SIGNATURE_FILENAME);
				
			// Подпись в тесте была совмещенная, потому данные равны null. Предположим, что
			// подписей несколько, тогда лучше указать тип null и положиться на самоопределение
			// типа подписи.
			CAdESSignature cadesSignature = new CAdESSignature(cadesCms, null, null);

			// Список CRL.
			List&lt;X509CRL&gt; crlList = null;
			
			// Если задан CRL, то читаем его из файла.
			if (Configuration.CRL_FILENAME != null) {
							
				X509CRL crl = (X509CRL) CertificateFactory.getInstance("X.509")
					.generateCRL(new FileInputStream(Configuration.CRL_FILENAME));
					
				crlList = Collections.singletonList(crl);
				cadesSignature.verify(chain, crlList);
							
			} else {
				cadesSignature.verify(chain);
			}
			
			// Список всех подписантов в исходной подписи.
			Collection&lt;SignerInformation&gt; srcSignerInfos = new ArrayList&lt;SignerInformation&gt;();
						
			for (CAdESSigner signer : cadesSignature.getCAdESSignerInfos()) {
				srcSignerInfos.add(signer.getSignerInfo());
			}
			
			// 2. Усовершенствование подписи.
		
			// Получаем только первую CAdES-BES подпись, усовершенствуем ее.
			// Остальных не трогаем.
			CMSSignedData srcSignedData = cadesSignature.getSignedData();
			CAdESSigner srcSigner = cadesSignature.getCAdESSignerInfo(0);
			
			// Исключаем ее из исходного списка, т.к. ее место займет усовершенствованная
			// подпись.
			srcSignerInfos.remove(srcSigner.getSignerInfo());
			
			// Усовершенствуем CAdES-BES до CAdES-X Long Type 1.
			srcSigner.enhance(JCP.PROVIDER_NAME, JCP.GOST_DIGEST_OID, chain, 
				Configuration.TSA_ADDRESS, CAdESType.CAdES_X_Long_Type_1);
						
			// Подписант усовершенствованной подписи.
			SignerInformation enhSigner = srcSigner.getSignerInfo();
			
			// Добавляем его в исходный список подписантов.
			srcSignerInfos.add(enhSigner);
			
			// Список подписантов.
			SignerInformationStore dstSignerInfoStore = new SignerInformationStore(srcSignerInfos);
			
			// Обновляем исходную подпись c ее начальным списком подписантов на тот же,
			// но с первым подписантом с усовершенствованной подписью.
			CMSSignedData dstSignedData = 
				CMSSignedData.replaceSigners(srcSignedData, dstSignerInfoStore);
			
			Array.writeFile(Configuration.TEST_DIR + "enhanced_" + Configuration.SIGNATURE_FILENAME, 
				dstSignedData.getEncoded());
		
			// 3. Проверка усовершенствованной подписи.
		
			// Проверяем подпись.
			cadesSignature = new CAdESSignature(dstSignedData.getEncoded(), null, null);
			cadesSignature.verify(chain, crlList);
			
			Configuration.printSignatureInfo(cadesSignature);
		
		} catch (Exception e) {
            Configuration.printCAdESException(e);
        }
	}
}
</java>
<java name="CAdES/GetSignerInfoTest.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.JCP.tools.Array;

import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;

/**
 * Пример получения списка подписантов.
 * 
 * @author Yevgeniy, 24/04/2012
 *
 */
public class GetSignerInfoTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		try {
		
			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			Configuration.loadConfiguration(chain);

			// Читаем подпись из файла.
			byte[] cadesCms = Array.readFile(Configuration.TEST_DIR + Configuration.SIGNATURE_FILENAME);
	
			// Подпись в тесте была совмещенная, потому данные равны null. Предположим, что
			// подписей несколько, тогда лучше указать тип null и положиться на самоопределение
			// типа подписи.
			CAdESSignature cadesSignature = new CAdESSignature(cadesCms, null, null);
			Configuration.printSignatureInfo(cadesSignature);
			
			System.out.println("------------------------------\n Signer #1 (" + 
				cadesSignature.getCAdESSignerInfo(0).getSignatureType() + ")");

		} catch (Exception e) {
            System.out.println(e);
        }
	}
}
</java>
<java name="CAdES/PKCS7Example.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import org.bouncycastle.cms.CMSProcessable;
import org.bouncycastle.cms.CMSProcessableByteArray;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.tools.Array;

import java.io.FileInputStream;
import java.security.PrivateKey;
import java.security.cert.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

/**
 * Пример формирования простой подписи PKCS7 с помощью BouncyCastle и проверки
 * CAdES API.
 * 
 * @author Yevgeniy, 20/04/2012
 *
 */
public class PKCS7Example {

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		// Этот вызов делается автоматически при использовании класса CAdESSignature,
		// однако тут необходимо его выполнить специально, т.к. начинаем работать с ГОСТ
		// без упоминания CAdESSignature.
		ru.CryptoPro.CAdES.tools.Utility.initJCPAlgorithms();
		
		try {
		
			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			PrivateKey privateKey = Configuration.loadConfiguration(chain);
			
			// Сертификат подписи - первый в списке.
			X509Certificate signerCert = chain.iterator().next();
			CertStore certStore = CertStore.getInstance("Collection", 
				new CollectionCertStoreParameters(chain), "BC");
			
			// Подготавливаем подпись.
			CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
			generator.addSigner(privateKey, signerCert, JCP.GOST_EL_DH_OID, JCP.GOST_DIGEST_OID);
			generator.addCertificatesAndCRLs(certStore);
			  
			// Создаем совмещенную подпись PKCS7.
			CMSProcessable content = new CMSProcessableByteArray(Configuration.DATA);
			CMSSignedData signedData = generator.generate(content, true, JCP.PROVIDER_NAME);
			 
			// Сформированная подпись.
			byte[] pkcs7 = signedData.getEncoded();
			
			Array.writeFile(Configuration.TEST_DIR + "pkcs7.bin", pkcs7);
			
			// Подпись в тесте была совмещенная, потому данные равны null. Предположим, что
			// подписей несколько, тогда лучше указать тип null и положиться на самоопределение
			// типа подписи.
			CAdESSignature pkcs7Signature = new CAdESSignature(pkcs7, null, null);
			
			// Если задан CRL, то читаем его из файла.
			if (Configuration.CRL_FILENAME != null) {
							
				X509CRL crl = (X509CRL) CertificateFactory.getInstance("X.509")
					.generateCRL(new FileInputStream(Configuration.CRL_FILENAME));
							
				pkcs7Signature.verify(chain, Collections.singletonList(crl));
							
			} else {
				pkcs7Signature.verify(chain);
			}
			
			Configuration.printSignatureInfo(pkcs7Signature);
			
		} catch (Exception e) {
            Configuration.printCAdESException(e);
        }
	}
}
</java>
<java name="CAdES/RSASignatureExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.CAdES.CAdESType;
import ru.CryptoPro.JCP.tools.Array;

import java.io.FileInputStream;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

/**
 * Пример формирования и проверки подписи CAdES на алгоритмах SHA-1 и RSA.
 * 
 * @author Yevgeniy, 04/05/2012
 *
 */
public class RSASignatureExample {

	/**
	 * Путь к контейнеру с сертификатами и ключом.
	 */
	private static final String RSA_STORE = "C:\\merlin\\keys\\RSA_test2.pfx";
	/**
	 * Пароль к контейнеру.
	 */
	private static final char[] RSA_STORE_PASSWORD = "123456".toCharArray();
	/**
	 * Идентификатор ключа.
	 */
	private static final String RSA_KEY_ALIAS = "RSA_test2";
	/**
	 * Пароль к ключу.
	 */
	private static final char[] RSA_KEY_PASSWORD = "123456".toCharArray();
	/**
	 * Идентификатор алгоритма хэширования.
	 */
	private static final String OID_SHA1 = "1.3.14.3.2.26";
	/**
	 * Идентификатор алгоритма подписи.
	 */
	private static final String OID_RSA = "1.3.14.3.2.29";
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		try {

            // Включаем возможность онлайновой проверки.
            System.setProperty("ru.CryptoPro.reprov.enableCRLDP", "true");
            System.setProperty("com.sun.security.enableCRLDP", "true");
            System.setProperty("com.ibm.security.enableCRLDP", "true");

			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			PrivateKey privateKey = Configuration.loadConfiguration("PKCS12", RSA_STORE,
				RSA_STORE_PASSWORD, RSA_KEY_ALIAS, RSA_KEY_PASSWORD, chain);
				
			CAdESSignature cadesSignature = new CAdESSignature(false);
		
			// Создаем подписанта CAdES-BES.
			cadesSignature.addSigner(BouncyCastleProvider.PROVIDER_NAME, OID_SHA1, 
				OID_RSA, privateKey, chain, CAdESType.CAdES_BES, null, false);
			// Создаем подписанта CAdES-X Long Type 1.
			cadesSignature.addSigner(BouncyCastleProvider.PROVIDER_NAME, OID_SHA1, OID_RSA, 
				privateKey, chain, CAdESType.CAdES_X_Long_Type_1, Configuration.TSA_ADDRESS, false);
		
			// Завершаем создание подписи с двумя подписантами.
			byte[] cadesCms = cadesSignature.sign(Configuration.DATA);
		
			Array.writeFile(Configuration.TEST_DIR + "rsa_" + Configuration.SIGNATURE_FILENAME, cadesCms);
		
			// Проверяем подпись.
			cadesSignature = new CAdESSignature(cadesCms, null, null);
			
			// Если задан CRL, то читаем его из файла.
			if (Configuration.CRL_FILENAME != null) {
										
				X509CRL crl = (X509CRL) CertificateFactory.getInstance("X.509")
					.generateCRL(new FileInputStream(Configuration.CRL_FILENAME));
										
				cadesSignature.verify(chain, Collections.singletonList(crl));
										
			} else {
				cadesSignature.verify(chain);
			}
			
			Configuration.printSignatureInfo(cadesSignature);
		}
		catch (Exception e) {
            Configuration.printCAdESException(e);
		}
    }
}
</java>
<java name="CAdES/SignExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.CAdES.CAdESType;
import ru.CryptoPro.JCP.tools.Array;

import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;

/**
 * Пример создания подписи CAdES-BES.
 * 
 * @author Yevgeniy, 17/04/2012
 *
 */
public class SignExample {

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		try {

            // Включаем возможность онлайновой проверки.
            System.setProperty("ru.CryptoPro.reprov.enableCRLDP", "true");
            System.setProperty("com.sun.security.enableCRLDP", "true");
            System.setProperty("com.ibm.security.enableCRLDP", "true");

			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			PrivateKey privateKey = Configuration.loadConfiguration(chain);
				
			CAdESSignature cadesSignature = new CAdESSignature(false);
		
			// Создаем подписанта CAdES-BES.
			cadesSignature.addSigner(privateKey, chain, CAdESType.CAdES_BES, null);
			// Создаем подписанта CAdES-X Long Type 1.
			cadesSignature.addSigner(privateKey, chain, CAdESType.CAdES_X_Long_Type_1,
				Configuration.TSA_ADDRESS);
		
			// Завершаем создание подписи с двумя подписантами.
			byte[] cadesCms = cadesSignature.sign(Configuration.DATA);
		
			Array.writeFile(Configuration.TEST_DIR + Configuration.SIGNATURE_FILENAME, cadesCms);

		} catch (Exception e) {
            Configuration.printCAdESException(e);
        }
    }
}
</java>
<java name="CAdES/VerifyExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES;

import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.JCP.tools.Array;

import java.io.FileInputStream;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

/**
 * Пример проверки подписи CAdES.
 * 
 * @author Yevgeniy, 17/04/2012
 *
 */
public class VerifyExample {

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		try {
		
			Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
			Configuration.loadConfiguration(chain);

			// Читаем подпись из файла.
			byte[] cadesCms = Array.readFile(Configuration.TEST_DIR + Configuration.SIGNATURE_FILENAME);
		
			// Подпись в тесте была совмещенная, потому данные равны null. Предположим, что
			// подписей несколько, тогда лучше указать тип null и положиться на самоопределение
			// типа подписи.
			CAdESSignature cadesSignature = new CAdESSignature(cadesCms, null, null);

			// Если задан CRL, то читаем его из файла.
			if (Configuration.CRL_FILENAME != null) {
				
				X509CRL crl = (X509CRL) CertificateFactory.getInstance("X.509")
					.generateCRL(new FileInputStream(Configuration.CRL_FILENAME));
				
				cadesSignature.verify(chain, Collections.singletonList(crl));
				
			} else {
				cadesSignature.verify(chain);
			}
			
			Configuration.printSignatureInfo(cadesSignature);

		} catch (Exception e) {
            Configuration.printCAdESException(e);
        }
	}
}
</java>
<java name="CAdES/speed/ComplexSpeedTest.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES.speed;

import CAdES.speed.OperationManager.OperationType;

import java.text.DecimalFormat;
import java.util.Calendar;
import java.util.Vector;

/**
 * Пример для проверки производительности различных операций с подписью CAdES:
 * создание, проверка, усовершенствование. Можно создать n потоков с выполнением
 * x идентичных операций.
 * 
 * @author Yevgeniy, 26/04/2012
 * 
 */
public class ComplexSpeedTest {

    /**
     * Время ожидания выполнения всех потоков, msec.
     */
    private static final int THREADS_TIMEOUT = 10 * 60 * 1000;

	/**
	 * Класс потока для выполнения определенной операции.
	 * 
	 */
	class TestThread extends Thread {

		/**
		 * Количество итераций.
		 */
		private int iterationCount = 100;
		/**
		 * Тип выполняемой операции.
		 */
		private OperationType operationType = OperationType.otSignCadesBes;
		/**
		 * Время выполнения всех операций в потоке, мс.
		 */
		private long executionTime = 0;

		/**
		 * Конструктор.
		 * 
		 * @param count
		 *            Количество итераций в потоке.
		 */
		public TestThread(int count, OperationType otype) {

			iterationCount = count;
			operationType = otype;
		}

		/**
		 * Поточная функция, выполняющая нужную операцию заданое количество раз.
		 * 
		 */
		@Override
		public void run() {

			byte[] data = null;

			// Если собираемся проверять или усовершенствовать, то создадим одну
			// подпись подходящего типа, которую потом будем использовать.
			if (operationType == OperationType.otVerifyCadesBes
					|| operationType == OperationType.otVerifyCadesXLongType1
					|| operationType == OperationType.otEnhanceCadesBes) {

				OperationManager dataManager = null;

				switch (operationType) {

				case otVerifyCadesBes:
				case otEnhanceCadesBes: {
					dataManager = new OperationManager(
							OperationType.otSignCadesBes);
					break;
				}

				case otVerifyCadesXLongType1: {
					dataManager = new OperationManager(
							OperationType.otSignCadesXLongType1);
					break;
				}

				}

				data = dataManager.execute(null);
			}

			OperationManager operationManager = new OperationManager(
					operationType);

			// Замеряем время.
			long startTime = Calendar.getInstance().getTime().getTime();

			for (int i = 0; i &lt; iterationCount; ++i) {
				operationManager.execute(data);
			}

			executionTime = Calendar.getInstance().getTime().getTime()
					- startTime;
		}

		/**
		 * Получение времени выполнения задания.
		 * 
		 * @return время в миллисекундах.
		 */
		public long getExecutionTime() {
			return executionTime;
		}
	}

	/**
	 * Запуск теста для проверки производительности.
	 * 
	 * @param otype Тип операции.
	 * @param tCount Количество потоков.
	 * @param iCount Количество итераций в потоке.
	 */
	private void runTest(OperationType otype, int tCount, int iCount) {

		Vector&lt;TestThread&gt; threads = new Vector&lt;TestThread&gt;();

		if (iCount &lt;= 0) {
			iCount = 1;
		}

		if (tCount &lt;= 0) {
			tCount = 1;
		}

		try {

			// Создаем потоки.
			for (int i = 0; i &lt; tCount; ++i) {
				threads.add(new TestThread(iCount, otype));
			}

			// Запускаем потоки.
			for (int i = 0; i &lt; tCount; ++i) {
				threads.get(i).start();
			}

			// Ждем потоки не более 10 минут.
			for (int i = 0; i &lt; tCount; ++i) {
				threads.get(i).join(THREADS_TIMEOUT);
			}

			long totalTime = 0;

			// Убиваем потоки, если еще живые.
			for (int i = 0; i &lt; tCount; ++i) {

				if (threads.get(i).isAlive()) {
					threads.get(i).stop();
				}

				long threadTime = threads.get(i).getExecutionTime();

				// Среднее время и скорость по одному потоку.
				System.out.println("---------- Thread # " + (i + 1) + " ----------");
				printInfo("Average speed of execution: ", (double) (iCount * 1000) / threadTime, "op/s");
				printInfo("Average time of an operation: ", (double) threadTime / (iCount * 1000), "s");

				totalTime += threadTime;
			}

			// Среднее время и скорость по всем потокам.
			System.out.println("-------------------------------------");
			printTestInfo(otype, tCount, iCount);
			printInfo("Average speed of execution: ", (double) (tCount * iCount * 1000) / totalTime, "op/s");
			printInfo("Average time of an operation: ", (double) totalTime / (tCount * iCount), "ms");
			printInfo("Total speed of execution: ", (double) (tCount * iCount * 1000) / (totalTime / tCount), "op/s");

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Вывод информации о результате операции.
	 *
	 * @param message Описание результата.
	 * @param value Значение измеряемого параметра.
	 * @param size Единица измерения.
	 */
	private void printInfo(String message, double value, String size) {

		DecimalFormat decFormat = new DecimalFormat("#.###");
		System.out.println(message + decFormat.format(value) + " " + size);
	}

	/**
	 * Вывод сводной информации о производительности.
	 * 
	 * @param otype Тип операции.
	 * @param tCount Количество потоков.
	 * @param iCount Количество итераций.
	 */
	private void printTestInfo(OperationType otype, int tCount, int iCount) {
		
		System.out.print("Test: ");
		
		switch (otype) {
			
			case otSignCadesBes:
				System.out.println("Sign CADES_BES");
				break;
		
			case otSignCadesXLongType1:
				System.out.println("Sign CADES_X_LONG_TYPE_1");
				break;
		
			case otVerifyCadesBes:
				System.out.println("Verify CADES_BES");
				break;
		
			case otVerifyCadesXLongType1:
				System.out.println("Verify CADES_X_LONG_TYPE_1");
				break;
				
			case otEnhanceCadesBes:
				System.out.println("Enhance CADES_BES to CADES_X_LONG_TYPE_1");
				break;
		}
		
		System.out.println("Number of threads: " + tCount);
		System.out.println("Number of iterations: " + iCount);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		ComplexSpeedTest speedTest = new ComplexSpeedTest();

		// Пример запуска 5 потоков для 1000 операций создания подписей
		// CAdES-BES.
		speedTest.runTest(OperationType.otSignCadesBes, 5, 1000);
	}

}
</java>
<java name="CAdES/speed/OperationManager.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CAdES.speed;

import CAdES.Configuration;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.SignerInformation;
import org.bouncycastle.cms.SignerInformationStore;
import ru.CryptoPro.CAdES.CAdESSignature;
import ru.CryptoPro.CAdES.CAdESSigner;
import ru.CryptoPro.CAdES.CAdESType;
import ru.CryptoPro.CAdES.exception.CAdESException;
import ru.CryptoPro.JCP.JCP;

import java.io.FileInputStream;
import java.io.IOException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

/**
 * Класс для проверки производительности определенной операции  - создание, 
 * проверка или усовершенствование подписи CAdES. Все настройки - ключ, 
 * сертификаты, СОС - загружаются по параметрам, записанным в файле Configuration.
 * 
 * @author Yevgeniy, 26/04/2012
 *
 */
public class OperationManager {

	/**
	 * Тип операции, выполняемой в потоке.
	 */
	public static enum OperationType { otSignCadesBes, otSignCadesXLongType1,
		otEnhanceCadesBes, otVerifyCadesBes, otVerifyCadesXLongType1 };
	/**
	 * Текущий тип выполняемой операции.
	 */
	private OperationType operationType;
	/**
	 * Цепочка сертификатов. Используется для создания, усовершенствования или
	 * проверки подписи.
	 */
	private Collection&lt;X509Certificate&gt; chain = new ArrayList&lt;X509Certificate&gt;();
	/**
	 * СОС. Используется для проверки подписи.
	 */
	private Collection&lt;X509CRL&gt; crls = null;
	/**
	 * Закрытый ключ. Используется для подписи.
	 */
	private PrivateKey privateKey = null;
		
	/**
	 * Конструктор. Загрузка цепочки сертификатов и закрытого ключа из 
	 * Configuration.
	 * 
	 * @param otype Тип операции.
	 */
	public OperationManager(OperationType otype) {
		
		operationType = otype;
		
		try {
			
			// Если задан CRL, то читаем его из файла.
			if (Configuration.CRL_FILENAME != null) {
							
				X509CRL crl = (X509CRL) CertificateFactory.getInstance("X.509")
					.generateCRL(new FileInputStream(Configuration.CRL_FILENAME));
				
				crls = Collections.singletonList(crl);
			}
			
			// Закрытый ключ для подписи и сертификаты.
			privateKey = Configuration.loadConfiguration(chain);
		
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Выполнение операции в зависимости от типа.
	 * 
	 * @param data CAdES подпись для проверки.
	 * @return CAdES подпись.
	 */
	public byte[] execute(byte[] data) {
		
		try {
		
			switch (operationType) {
			
				case otSignCadesBes:
				case otSignCadesXLongType1:	{
					return sign();
				}
				
				case otVerifyCadesBes:
				case otVerifyCadesXLongType1: {
					verify(data);
					break;
				}
				
				case otEnhanceCadesBes: {
					return enhance(data);
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	/**
	 * Формирование совмещенной подписи в зависимости от типа.
	 * 
	 * @return CAdES подпись.
	 * @throws CAdESException
	 */
	private byte[] sign() throws CAdESException {
		
		CAdESSignature cadesSignature = new CAdESSignature(false);
		
		switch (operationType) {
		
			case otSignCadesBes: {
				cadesSignature.addSigner(privateKey, chain, CAdESType.CAdES_BES, null);
				break;
			}
			
			case otSignCadesXLongType1: {
				cadesSignature.addSigner(privateKey, chain, CAdESType.CAdES_X_Long_Type_1, 
					Configuration.TSA_ADDRESS);
				break;
			}
		}
		
		return cadesSignature.sign(Configuration.DATA);
	}
	
	/**
	 * Проверка совмещенной подписи.
	 * 
	 * @param data Подпись для проверки.
	 * @throws CAdESException
	 */
	private void verify(byte[] data) throws CAdESException {
		
		if (data == null) {
			throw new IllegalArgumentException("Data is null.");
		}
		
		CAdESSignature cadesSignature = new CAdESSignature(data, null, null);
		cadesSignature.verify(chain, crls);
	}
	
	/**
	 * Усовершенствование подписи CAdES-BES до CAdES-X Long Type 1.
	 * 
	 * @param data CAdES-BES подпись.
	 * @return усовершенствованная CAdES-X Long Type 1 подпись.
	 * @throws CAdESException
	 */
	private byte[] enhance(byte[] data) throws CAdESException {
		
		if (data == null) {
			throw new IllegalArgumentException("Data is null.");
		}
		
		CAdESSignature cadesSignature = new CAdESSignature(data, null, null);
		
		// Список всех подписантов в исходной подписи.
		Collection&lt;SignerInformation&gt; srcSignerInfos = new ArrayList&lt;SignerInformation&gt;();
								
		for (CAdESSigner signer : cadesSignature.getCAdESSignerInfos()) {
			srcSignerInfos.add(signer.getSignerInfo());
		}
		
		// Получаем только первого подписанта CAdES-BES, усовершенствуем его подпись.
		// Остальных не трогаем.
		CMSSignedData srcSignedData = cadesSignature.getSignedData();
		CAdESSigner srcSigner = cadesSignature.getCAdESSignerInfo(0);
					
		// Исключаем его из исходного списка, т.к. его место займет подписант с
		// усовершенствованной подписью.
		srcSignerInfos.remove(srcSigner.getSignerInfo());
					
		// Усовершенствуем CAdES-BES до CAdES-X Long Type 1.
		srcSigner.enhance(JCP.PROVIDER_NAME, JCP.GOST_DIGEST_OID, chain, 
			Configuration.TSA_ADDRESS, CAdESType.CAdES_X_Long_Type_1);
								
		// Подписант с усовершенствованной подписью.
		SignerInformation enhSigner = srcSigner.getSignerInfo();
					
		// Добавляем его в исходный список подписантов.
		srcSignerInfos.add(enhSigner);
		
		// Список подписантов.
		SignerInformationStore dstSignerInfoStore = 
			new SignerInformationStore(srcSignerInfos);
					
		// Обновляем исходную подпись c ее начальным списком подписантов на тот же,
		// но с первым подписантом с усовершенствованной подписью.
		CMSSignedData dstSignedData = 
			CMSSignedData.replaceSigners(srcSignedData, dstSignerInfoStore);

        byte[] dstSignedDataEncoded = null;

        try {
            dstSignedDataEncoded = dstSignedData.getEncoded();
        } catch (IOException e) {
            throw new CAdESException(e, CAdESException.ecUnknown);
        }

        return dstSignedDataEncoded;
	}
}
</java>
<java name="CMS_samples/CMS.java">/**
 * $RCSfile$
 * version $Revision: 36613 $
 * created 15.08.2007 11:42:12 by kunina
 * last modified $Date: 2012-11-14 12:29:19 +0400 (Wed, 14 Nov 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import com.objsys.asn1j.runtime.Asn1Null;
import com.objsys.asn1j.runtime.Asn1ObjectIdentifier;
import com.objsys.asn1j.runtime.Asn1OctetString;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.CertificateSerialNumber;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Name;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.tools.Array;

import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Arrays;


/**
 * CMS sign and verify
 * &lt;p/&gt;
 * csptest -sfsign -in data.txt -my key -sign -out data.sgn
 * &lt;p/&gt;
 * csptest -sfsign -my key -verify -in data.sgn
 * &lt;p/&gt;
 * csptest -lowsign -in data.txt -my key -sign -out data_low.sgn
 * &lt;p/&gt;
 * csptest -lowsign -in data.sgn -verify ???
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CMS {
private static final String CMS_FILE = "cms_data_sgn";
private static final String CMS_FILE_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + CMS_FILE + CMStools.CMS_EXT;
/**
 * detached
 */
private static final String CMS_FILE_D = "cms_data_d_sgn";
private static final String CMS_FILE_D_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + CMS_FILE_D + CMStools.CMS_EXT;

 /**/
private CMS() {
}

/**
 * main Sign / Verify
 *
 * @param args //
 * @throws Exception e
 */
public static void main(String[] args) throws Exception {
    //подготовка данных для запуска примера
    //CMStools.main(args);

    // prepare to sign
    final byte[] data = Array.readFile(CMStools.DATA_FILE_PATH);
    final PrivateKey key = CMStools.loadKey(CMStools.SIGN_KEY_NAME,
            CMStools.SIGN_KEY_PASSWORD);
    final Certificate cert = CMStools.loadCertificate(CMStools.SIGN_KEY_NAME);
    //final Certificate cert = CMStools.readCertificate(CMStools.SIGN_CERT_PATH);

    //Sign
    Array.writeFile(CMS_FILE_PATH, CMSSign(data, key, cert, false));
    //Verify
    CMSVerify(Array.readFile(CMS_FILE_PATH), cert, null);

    //-DETACHED-
    //Sign
    Array.writeFile(CMS_FILE_D_PATH, CMSSign(data, key, cert, true));
    //Verify
    CMSVerify(Array.readFile(CMS_FILE_D_PATH), cert, data);
}

/**
 * sign CMS
 *
 * @param data data
 * @param key key
 * @param cert cert
 * @throws Exception e
 */
public static byte[] CMSSign(byte[] data, PrivateKey key, Certificate cert,
                             boolean detached)
        throws Exception {
    // sign
    final Signature signature =
            Signature.getInstance(JCP.GOST_DHEL_SIGN_NAME);
    signature.initSign(key);
    signature.update(data);
    final byte[] sign = signature.sign();
    // create cms format
    return createCMS(data, sign, cert, detached);
}

/**
 * createCMS
 *
 * @param buffer buffer
 * @param sign sign
 * @param cert cert
 * @return byte[]
 * @throws Exception e
 */
public static byte[] createCMS(byte[] buffer, byte[] sign, Certificate cert,
                               boolean detached)
        throws Exception {
    final ContentInfo all = new ContentInfo();
    all.contentType = new Asn1ObjectIdentifier(
            new OID(CMStools.STR_CMS_OID_SIGNED).value);
    final SignedData cms = new SignedData();
    all.content = cms;
    cms.version = new CMSVersion(1);
    // digest
    cms.digestAlgorithms = new DigestAlgorithmIdentifiers(1);
    final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    a.parameters = new Asn1Null();
    cms.digestAlgorithms.elements[0] = a;
    if (detached)
        cms.encapContentInfo = new EncapsulatedContentInfo(
                new Asn1ObjectIdentifier(
                        new OID(CMStools.STR_CMS_OID_DATA).value), null);
    else
        cms.encapContentInfo =
                new EncapsulatedContentInfo(new Asn1ObjectIdentifier(
                        new OID(CMStools.STR_CMS_OID_DATA).value),
                        new Asn1OctetString(buffer));
    // certificate
    cms.certificates = new CertificateSet(1);
    final ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate certificate =
            new ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate();
    final Asn1BerDecodeBuffer decodeBuffer =
            new Asn1BerDecodeBuffer(cert.getEncoded());
    certificate.decode(decodeBuffer);
    cms.certificates.elements = new CertificateChoices[1];
    cms.certificates.elements[0] = new CertificateChoices();
    cms.certificates.elements[0].set_certificate(certificate);

    // signer info
    cms.signerInfos = new SignerInfos(1);
    cms.signerInfos.elements[0] = new SignerInfo();
    cms.signerInfos.elements[0].version = new CMSVersion(1);
    cms.signerInfos.elements[0].sid = new SignerIdentifier();

    final byte[] encodedName = ((X509Certificate) cert).getIssuerX500Principal()
            .getEncoded();
    final Asn1BerDecodeBuffer nameBuf = new Asn1BerDecodeBuffer(encodedName);
    final Name name = new Name();
    name.decode(nameBuf);

    final CertificateSerialNumber num = new CertificateSerialNumber(
            ((X509Certificate) cert).getSerialNumber());
    cms.signerInfos.elements[0].sid.set_issuerAndSerialNumber(
            new IssuerAndSerialNumber(name, num));
    cms.signerInfos.elements[0].digestAlgorithm =
            new DigestAlgorithmIdentifier(new OID(CMStools.DIGEST_OID).value);
    cms.signerInfos.elements[0].digestAlgorithm.parameters = new Asn1Null();
    cms.signerInfos.elements[0].signatureAlgorithm =
            new SignatureAlgorithmIdentifier(new OID(CMStools.SIGN_OID).value);
    cms.signerInfos.elements[0].signatureAlgorithm.parameters = new Asn1Null();
    cms.signerInfos.elements[0].signature = new SignatureValue(sign);
    // encode
    final Asn1BerEncodeBuffer asnBuf = new Asn1BerEncodeBuffer();
    all.encode(asnBuf, true);
    return asnBuf.getMsgCopy();
}

/**
 * verify CMS
 *
 * @param buffer buffer
 * @param cert cert
 * @param data data
 * @throws Exception e
 *
 * @deprecated начиная с версии 1.0.54, следует использовать функцонал CAdES API (CAdES.jar)
 */
public static void CMSVerify(byte[] buffer, Certificate cert, byte[] data)
        throws Exception {
    int i;
    final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(buffer);
    final ContentInfo all = new ContentInfo();
    all.decode(asnBuf);
    if (!new OID(CMStools.STR_CMS_OID_SIGNED).eq(all.contentType.value))
        throw new Exception("Not supported");
    final SignedData cms = (SignedData) all.content;
    if (cms.version.value != 1)
        throw new Exception("Incorrect version");
    if (!new OID(CMStools.STR_CMS_OID_DATA).eq(
            cms.encapContentInfo.eContentType.value))
        throw new Exception("Nested not supported");
    byte[] text = null;
    if (data != null) text = data;
    else if (cms.encapContentInfo.eContent != null)
        text = cms.encapContentInfo.eContent.value;
    if (text == null) throw new Exception("No content");
    OID digestOid = null;
    DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    for (i = 0; i &lt; cms.digestAlgorithms.elements.length; i++) {
        if (cms.digestAlgorithms.elements[i].algorithm.equals(a.algorithm)) {
            digestOid =
                    new OID(cms.digestAlgorithms.elements[i].algorithm.value);
            break;
        }
    }
    if (digestOid == null)
        throw new Exception("Unknown digest");
    int pos = -1;
    for (i = 0; i &lt; cms.certificates.elements.length; i++) {
        final Asn1BerEncodeBuffer encBuf = new Asn1BerEncodeBuffer();
        cms.certificates.elements[i].encode(encBuf);
        final byte[] in = encBuf.getMsgCopy();
        if (Arrays.equals(in, cert.getEncoded())) {
            System.out.println("Certificate: " + ((X509Certificate)cert).getSubjectDN());
            pos = i;
            break;
        }
    }
    if (pos == -1)
        throw new Exception("Not signed on certificate.");

    final SignerInfo info = cms.signerInfos.elements[pos];
    if (info.version.value != 1)
        throw new Exception("Incorrect version");
    if (!digestOid.equals(new OID(info.digestAlgorithm.algorithm.value)))
        throw new Exception("Not signed on certificate.");
    final byte[] sign = info.signature.value;

    // check
    final Signature signature = Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    signature.initVerify(cert);
    signature.update(text);
    final boolean checkResult = signature.verify(sign);
    if (checkResult) CMStools.logger.info("Valid signature");
    else throw new Exception("Invalid signature.");
    //return text;
}
}
</java>
<java name="CMS_samples/CMSDecrypt.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 28.05.2008 10:26:51 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import ru.CryptoPro.Crypto.spec.GostCipherSpec;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.ContentInfo;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.EnvelopedData;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.KeyTransRecipientInfo;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.RecipientInfo;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_Parameters;
import ru.CryptoPro.JCP.ASN.GostR3410_EncryptionSyntax.GostR3410_KeyTransport;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.tools.Array;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.X509EncodedKeySpec;

/**
 * Decrypt message.
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CMSDecrypt {
//private static final String CMS_FILE_PATH = "envCMS.txt";
private static final String CMS_FILE_PATH = CMSSignAndEncrypt.CMS_FILE_PATH;
private static final String CIPHER_MODE = CMSSignAndEncrypt.CIPHER_MODE;

public static void main(String[] args) throws Exception {
    // cms-сообщение для расшифрования
    final byte[] buffer = Array.readFile(CMS_FILE_PATH);
    //разбор CMS-сообщения
    Asn1BerDecodeBuffer dbuf = new Asn1BerDecodeBuffer(buffer);
    final ContentInfo all = new ContentInfo();
    all.decode(dbuf);
    dbuf.reset();
    final EnvelopedData cms = (EnvelopedData) all.content;

    KeyTransRecipientInfo keytrans = new KeyTransRecipientInfo();
    if (cms.recipientInfos.elements[0].getChoiceID() == RecipientInfo._KTRI)
        keytrans =
                (KeyTransRecipientInfo) (cms.recipientInfos.elements[0].getElement());
    final Asn1BerEncodeBuffer ebuf = new Asn1BerEncodeBuffer();
    dbuf = new Asn1BerDecodeBuffer(keytrans.encryptedKey.value);
    final GostR3410_KeyTransport encrKey = new GostR3410_KeyTransport();
    encrKey.decode(dbuf);
    dbuf.reset();
    encrKey.sessionEncryptedKey.encode(ebuf);
    final byte[] wrapKey = ebuf.getMsgCopy();
    ebuf.reset();
    encrKey.transportParameters.ephemeralPublicKey.encode(ebuf);
    final byte[] encodedPub = ebuf.getMsgCopy();
    ebuf.reset();
    final byte[] sv = encrKey.transportParameters.ukm.value;
    final Gost28147_89_Parameters params =
            (Gost28147_89_Parameters) cms.encryptedContentInfo.contentEncryptionAlgorithm.parameters;
    final byte[] iv = params.iv.value;
    final OID cipherOID = new OID(params.encryptionParamSet.value);
    final byte[] text = cms.encryptedContentInfo.encryptedContent.value;

    //Загрузка хранилища
    final KeyStore hdImageStore = KeyStore.getInstance(CMStools.STORE_TYPE);
    hdImageStore.load(null, null);
    //получатель - закрытый ключ
    final PrivateKey responderKey =
            (PrivateKey) hdImageStore.getKey(CMStools.RECIP_KEY_NAME,
                    CMStools.RECIP_KEY_PASSWORD);

    //отправитель - открытый ключ из cms
    final X509EncodedKeySpec pspec = new X509EncodedKeySpec(encodedPub);
    final KeyFactory kf = KeyFactory.getInstance(CMStools.KEY_ALG_NAME);
    final PublicKey senderPublic = kf.generatePublic(pspec);

    // выработка ключа согласования получателем
    final KeyAgreement responderKeyAgree =
            KeyAgreement.getInstance(CMStools.KEY_ALG_NAME);
    responderKeyAgree.init(responderKey, new IvParameterSpec(sv), null);
    responderKeyAgree.doPhase(senderPublic, true);
    final SecretKey responderSecret = responderKeyAgree
            .generateSecret(CMStools.SEC_KEY_ALG_NAME);

    // Расшифрование симметричного ключа.
    final Cipher cipher = Cipher.getInstance(CIPHER_MODE);
    cipher.init(Cipher.UNWRAP_MODE, responderSecret, (SecureRandom) null);
    final SecretKey simmKey = (SecretKey) cipher
            .unwrap(wrapKey, null, Cipher.SECRET_KEY);

    // Расшифрование текста на симметричном ключе.
    final GostCipherSpec spec = new GostCipherSpec(iv, cipherOID);
    cipher.init(Cipher.DECRYPT_MODE, simmKey, spec, null);
    final byte[] result = cipher.doFinal(text, 0, text.length);
    // if result = signedData ($CMS_FILE)
    CMSVerify.CMSVerify(result, null, null);
}
}
</java>
<java name="CMS_samples/CMSSign.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 16.08.2007 11:04:11 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import com.objsys.asn1j.runtime.Asn1Null;
import com.objsys.asn1j.runtime.Asn1ObjectIdentifier;
import com.objsys.asn1j.runtime.Asn1OctetString;
import com.objsys.asn1j.runtime.Asn1Type;
import com.objsys.asn1j.runtime.Asn1UTCTime;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Attribute;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Attribute_values;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.CertificateSerialNumber;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Name;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Time;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.tools.Array;

import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Calendar;

/**
 * CMSSign n sign параллельные подписи с укладкой сертификатов
 * &lt;p/&gt;
 * проверяется:
 * &lt;p/&gt;
 * CMS_samples.CMSVerify
 * &lt;p/&gt;
 * csptest -sfsign -my key -verify -in data.sgn (без указания сертификата (-my)
 * csptest выдает ошибку приложения)
 * &lt;p/&gt;
 * csptest -lowsign -in data.sgn -verify (не проверяет //недостаточно
 * криптографических параметров//...-my не влияет)
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CMSSign {
/**
 * создать cms сообщение с подписью на хэш данных
 */
private static final boolean LOW_SIGN = true;
private static final String CMS_FILE_LOW = "cms_data_low_sgn";
private static final String CMS_FILE_LOW_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + CMS_FILE_LOW + CMStools.CMS_EXT;

/**
 * создать cms сообщение с подписью на хэш signedAttibutes
 */
private static final boolean SF_SIGN = true;
private static final String CMS_FILE_SF = "cms_data_sf_sgn";
private static final String CMS_FILE_SF_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + CMS_FILE_SF + CMStools.CMS_EXT;

 /**/
private CMSSign() {
}

/**
 * main Sign (+Verify)
 *
 * @throws Exception e
 */
public static void main(String[] args) throws Exception {
    //подготовка данных для запуска примера
    //CMStools.main(args);

    //read data or CMS
    final byte[] data = Array.readFile(CMStools.DATA_FILE_PATH);
//    final byte[] data = Array.readFile(CMStools.CMS_FILE_LOW_PATH);
//    final byte[] data = Array.readFile(CMStools.CMS_FILE_SF_PATH);

    //load keys for sign
    final PrivateKey[] keys = new PrivateKey[1];
    keys[0] = CMStools.loadKey(CMStools.SIGN_KEY_NAME,
            CMStools.SIGN_KEY_PASSWORD);
//    keys[1] = CMStools.loadKey(CMStools.RECIP_KEY_NAME,
//            CMStools.RECIP_KEY_PASSWORD);

    //load certificates
    final Certificate[] certs = new Certificate[1];
    certs[0] = CMStools.loadCertificate(CMStools.SIGN_KEY_NAME);
    //certs[1] = CMStools.loadCertificate(CMStools.RECIP_KEY_NAME);
//        certs[0] = CMStools.readCertificate(CMStools.SIGN_KEY_NAME);
//        //certs[1] = CMStools.readCertificate(CMStools.RECIP_KEY_NAME);

    //Sign (create CMS or sign CMS)
    boolean isCMS = true;
    final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(data);
    final ContentInfo all = new ContentInfo();
    try {
        all.decode(asnBuf);
    } catch (Exception e) {
        //создаем новое cms сообщение
        if (LOW_SIGN) {
            CMStools.logger.info("Create CMS (low)");
            createCMS(data, keys, certs, CMS_FILE_LOW_PATH, false);
        }
        if (SF_SIGN) {
            CMStools.logger.info("Create CMS (sf)");
            createhashCMS(data, keys, certs, CMS_FILE_SF_PATH, false);
        }
        isCMS = false;
    }
    if (isCMS) {
        //подписываем уже созданное cms сообщение
        if (LOW_SIGN) {
            CMStools.logger.info("Sign CMS (low)");
            signCMS(data, keys, certs, CMS_FILE_LOW_PATH, null);
        }
        if (SF_SIGN) {
            CMStools.logger.info("Sign CMS (sf)");
            hashsignCMS(data, keys, certs, CMS_FILE_SF_PATH, null);
        }
    }

//    //создание cms сообщения
//    createCMS(data, keys, certs, CMS_FILE_LOW_PATH, false);
//    createhashCMS(data, keys, certs, CMS_FILE_SF_PATH, false);
//    //вторая подпись
//    byte[] cmsdata = Array.readFile(CMS_FILE_LOW_PATH);
//    signCMS(cmsdata, keys, certs, CMS_FILE_LOW_PATH, null);
//    cmsdata = Array.readFile(CMS_FILE_SF_PATH);
//    hashsignCMS(cmsdata, keys, certs, CMS_FILE_SF_PATH, null);
//    //третья подпись
//    cmsdata = Array.readFile(CMS_FILE_LOW_PATH);
//    signCMS(cmsdata, keys, certs, CMS_FILE_LOW_PATH, null);
//    cmsdata = Array.readFile(CMS_FILE_SF_PATH);
//    hashsignCMS(cmsdata, keys, certs, CMS_FILE_SF_PATH, null);
//    ...

    //Verify
    byte[] signdata = Array.readFile(CMS_FILE_LOW_PATH);
    CMStools.logger.info("Verify created or signed CMS (LOW):");
    CMSVerify.CMSVerify(signdata, certs, null);
    signdata = Array.readFile(CMS_FILE_SF_PATH);
    CMStools.logger.info("Verify created or signed CMS (SF):");
    CMSVerify.CMSVerify(signdata, certs, null);
}

/**
 * Создание сообщения с подписью на хэш signedAttibutes
 *
 * @param data data
 * @param keys keys
 * @param certs certs
 * @param path path to write CMS
 * @param detached true if detached
 * @return byte[]
 * @throws Exception e
 */
public static byte[] createhashCMS(byte[] data, PrivateKey[] keys,
                                   Certificate[] certs, String path,
                                   boolean detached)
        throws Exception {
    //create hashCMS
    final ContentInfo all = new ContentInfo();
    all.contentType =
            new Asn1ObjectIdentifier(
                    new OID(CMStools.STR_CMS_OID_SIGNED).value);
    final SignedData cms = new SignedData();
    all.content = cms;
    cms.version = new CMSVersion(1);
    // digest
    cms.digestAlgorithms = new DigestAlgorithmIdentifiers(1);
    final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    a.parameters = new Asn1Null();
    cms.digestAlgorithms.elements[0] = a;
    if (detached)
        cms.encapContentInfo = new EncapsulatedContentInfo(
                new Asn1ObjectIdentifier(
                        new OID(CMStools.STR_CMS_OID_DATA).value),
                null);
    else
        cms.encapContentInfo =
                new EncapsulatedContentInfo(new Asn1ObjectIdentifier(
                        new OID(CMStools.STR_CMS_OID_DATA).value),
                        new Asn1OctetString(data));
    // certificates
    final int ncerts = certs.length;
    cms.certificates = new CertificateSet(ncerts);
    cms.certificates.elements = new CertificateChoices[ncerts];
    for (int i = 0; i &lt; cms.certificates.elements.length; i++) {
        final ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate certificate =
                new ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate();
        final Asn1BerDecodeBuffer decodeBuffer =
                new Asn1BerDecodeBuffer(certs[i].getEncoded());
        certificate.decode(decodeBuffer);
        cms.certificates.elements[i] = new CertificateChoices();
        cms.certificates.elements[i].set_certificate(certificate);
    }
    // Signature.getInstance
    final Signature signature =
            Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    byte[] sign;
    // signer infos
    final int nsign = keys.length;
    cms.signerInfos = new SignerInfos(nsign);
    for (int i = 0; i &lt; cms.signerInfos.elements.length; i++) {
        cms.signerInfos.elements[i] = new SignerInfo();
        cms.signerInfos.elements[i].version = new CMSVersion(1);
        cms.signerInfos.elements[i].sid = new SignerIdentifier();

        final byte[] encodedName =
                ((X509Certificate) certs[i]).getIssuerX500Principal()
                        .getEncoded();
        final Asn1BerDecodeBuffer nameBuf =
                new Asn1BerDecodeBuffer(encodedName);
        final Name name = new Name();
        name.decode(nameBuf);

        final CertificateSerialNumber num = new CertificateSerialNumber(
                ((X509Certificate) certs[i]).getSerialNumber());
        cms.signerInfos.elements[i].sid.set_issuerAndSerialNumber(
                new IssuerAndSerialNumber(name, num));
        cms.signerInfos.elements[i].digestAlgorithm =
                new DigestAlgorithmIdentifier(
                        new OID(CMStools.DIGEST_OID).value);
        cms.signerInfos.elements[i].digestAlgorithm.parameters = new Asn1Null();
        cms.signerInfos.elements[i].signatureAlgorithm =
                new SignatureAlgorithmIdentifier(
                        new OID(CMStools.SIGN_OID).value);
        cms.signerInfos.elements[i].signatureAlgorithm.parameters =
                new Asn1Null();

        //signedAttributes
        final int kmax = 3;
        cms.signerInfos.elements[i].signedAttrs = new SignedAttributes(kmax);

        //-contentType
        int k = 0;
        cms.signerInfos.elements[i].signedAttrs.elements[k] =
                new Attribute(new OID(CMStools.STR_CMS_OID_CONT_TYP_ATTR).value,
                        new Attribute_values(1));

        final Asn1Type conttype = new Asn1ObjectIdentifier(
                new OID(CMStools.STR_CMS_OID_DATA).value);

        cms.signerInfos.elements[i].signedAttrs.elements[k].values.elements[0] =
                conttype;

        //-Time
        k += 1;
        cms.signerInfos.elements[i].signedAttrs.elements[k] =
                new Attribute(new OID(CMStools.STR_CMS_OID_SIGN_TYM_ATTR).value,
                        new Attribute_values(1));

        final Time time = new Time();
//        final Asn1GeneralizedTime genTime = new Asn1GeneralizedTime();
//        //текущая дата с календаря
//        genTime.setTime(Calendar.getInstance());
//        time.set_generalTime(genTime);

        final Asn1UTCTime UTCTime = new Asn1UTCTime();
        //текущая дата с календаря
        UTCTime.setTime(Calendar.getInstance());
        time.set_utcTime(UTCTime);

        cms.signerInfos.elements[i].signedAttrs.elements[k].values.elements[0] =
                time.getElement();

        //-message digest
        k += 1;
        cms.signerInfos.elements[i].signedAttrs.elements[k] =
                new Attribute(new OID(CMStools.STR_CMS_OID_DIGEST_ATTR).value,
                        new Attribute_values(1));
        final byte[] messagedigestb;
        if (detached)
            messagedigestb = CMStools.digestm(data, CMStools.DIGEST_ALG_NAME);
        else
            messagedigestb =
                    CMStools.digestm(cms.encapContentInfo.eContent.value,
                            CMStools.DIGEST_ALG_NAME);
        final Asn1Type messagedigest = new Asn1OctetString(messagedigestb);

        cms.signerInfos.elements[i].signedAttrs.elements[k].values.elements[0] =
                messagedigest;

        //signature
        Asn1BerEncodeBuffer encBufSignedAttr = new Asn1BerEncodeBuffer();
        cms.signerInfos.elements[i].signedAttrs
                .encode(encBufSignedAttr);
        final byte[] hsign = encBufSignedAttr.getMsgCopy();
        signature.initSign(keys[i]);
        signature.update(hsign);
        sign = signature.sign();

        cms.signerInfos.elements[i].signature = new SignatureValue(sign);
    }
    // encode
    final Asn1BerEncodeBuffer asnBuf = new Asn1BerEncodeBuffer();
    all.encode(asnBuf, true);
    Array.writeFile(path, asnBuf.getMsgCopy());
    return asnBuf.getMsgCopy();

}

/**
 * Создание сообщение с подписью на хэш данных
 *
 * @param data data
 * @param certs certs[]
 * @param keys keys
 * @param path path to write CMS
 * @param detached true if detached
 * @return byte[]
 * @throws Exception e
 */
public static byte[] createCMS(byte[] data, PrivateKey[] keys,
                               Certificate[] certs, String path,
                               boolean detached)
        throws Exception {
    //create CMS
    final ContentInfo all = new ContentInfo();
    all.contentType =
            new Asn1ObjectIdentifier(
                    new OID(CMStools.STR_CMS_OID_SIGNED).value);
    final SignedData cms = new SignedData();
    all.content = cms;
    cms.version = new CMSVersion(1);
    // digest
    cms.digestAlgorithms = new DigestAlgorithmIdentifiers(1);
    final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    a.parameters = new Asn1Null();
    cms.digestAlgorithms.elements[0] = a;
    if (detached)
        cms.encapContentInfo = new EncapsulatedContentInfo(
                new Asn1ObjectIdentifier(
                        new OID(CMStools.STR_CMS_OID_DATA).value),
                null);
    else
        cms.encapContentInfo =
                new EncapsulatedContentInfo(new Asn1ObjectIdentifier(
                        new OID(CMStools.STR_CMS_OID_DATA).value),
                        new Asn1OctetString(data));
    // certificates
    final int ncerts = certs.length;
    cms.certificates = new CertificateSet(ncerts);
    cms.certificates.elements = new CertificateChoices[ncerts];
    for (int i = 0; i &lt; cms.certificates.elements.length; i++) {
        final ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate certificate =
                new ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate();
        final Asn1BerDecodeBuffer decodeBuffer =
                new Asn1BerDecodeBuffer(certs[i].getEncoded());
        certificate.decode(decodeBuffer);
        cms.certificates.elements[i] = new CertificateChoices();
        cms.certificates.elements[i].set_certificate(certificate);
    }
    // Signature.getInstance
    final Signature signature =
            Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    byte[] sign;
    // signer infos
    final int nsign = keys.length;
    cms.signerInfos = new SignerInfos(nsign);
    for (int i = 0; i &lt; cms.signerInfos.elements.length; i++) {
        signature.initSign(keys[i]);
        signature.update(data);
        sign = signature.sign();
        cms.signerInfos.elements[i] = new SignerInfo();
        cms.signerInfos.elements[i].version = new CMSVersion(1);
        cms.signerInfos.elements[i].sid = new SignerIdentifier();

        final byte[] encodedName =
                ((X509Certificate) certs[i]).getIssuerX500Principal()
                        .getEncoded();
        final Asn1BerDecodeBuffer nameBuf =
                new Asn1BerDecodeBuffer(encodedName);
        final Name name = new Name();
        name.decode(nameBuf);

        final CertificateSerialNumber num = new CertificateSerialNumber(
                ((X509Certificate) certs[i]).getSerialNumber());
        cms.signerInfos.elements[i].sid.set_issuerAndSerialNumber(
                new IssuerAndSerialNumber(name, num));
        cms.signerInfos.elements[i].digestAlgorithm =
                new DigestAlgorithmIdentifier(
                        new OID(CMStools.DIGEST_OID).value);
        cms.signerInfos.elements[i].digestAlgorithm.parameters = new Asn1Null();
        cms.signerInfos.elements[i].signatureAlgorithm =
                new SignatureAlgorithmIdentifier(
                        new OID(CMStools.SIGN_OID).value);
        cms.signerInfos.elements[i].signatureAlgorithm.parameters =
                new Asn1Null();
        cms.signerInfos.elements[i].signature = new SignatureValue(sign);
    }
    // encode
    final Asn1BerEncodeBuffer asnBuf = new Asn1BerEncodeBuffer();
    all.encode(asnBuf, true);
    Array.writeFile(path, asnBuf.getMsgCopy());
    return asnBuf.getMsgCopy();
}

/**
 * Подпись существующего сообщения (CMS) //хэш на данные
 *
 * @param buffer CMS
 * @param keys keys
 * @param certs certs
 * @param path path to write signCMS
 * @param data data if detached signature
 * @return byte[]
 * @throws Exception e
 */
public static byte[] signCMS(byte[] buffer, PrivateKey[] keys,
                             Certificate[] certs, String path, byte[] data)
        throws Exception {
    int i;
    final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(buffer);
    final ContentInfo all = new ContentInfo();
    all.decode(asnBuf);
    if (!new OID(CMStools.STR_CMS_OID_SIGNED).eq(all.contentType.value))
        throw new Exception("Not supported");
    final SignedData cms = (SignedData) all.content;
    if (cms.version.value != 1)
        throw new Exception("Incorrect version");
    if (!new OID(CMStools.STR_CMS_OID_DATA).eq(
            cms.encapContentInfo.eContentType.value))
        throw new Exception("Nested not supported");
    final byte[] text;
    if (cms.encapContentInfo.eContent != null)
        text = cms.encapContentInfo.eContent.value;
    else if (data != null) text = data;
    else throw new Exception("No content");
//    final byte[] text = cms.encapContentInfo.eContent.value;
    OID digestOid = null;
    final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    for (i = 0; i &lt; cms.digestAlgorithms.elements.length; i++) {
        if (cms.digestAlgorithms.elements[i].algorithm.equals(a.algorithm)) {
            digestOid =
                    new OID(cms.digestAlgorithms.elements[i].algorithm.value);
            break;
        }
    }
    if (digestOid == null)
        throw new Exception("Unknown digest");
    // certificates
    final CertificateChoices[] choiceses =
            new CertificateChoices[cms.certificates.elements.length];
    for (i = 0; i &lt; cms.certificates.elements.length; i++) {
        choiceses[i] = cms.certificates.elements[i];
    }
    final int ncerts = certs.length + choiceses.length;
    cms.certificates = new CertificateSet(ncerts);
    cms.certificates.elements = new CertificateChoices[ncerts];
    for (i = 0; i &lt; choiceses.length; i++) {
        cms.certificates.elements[i] = choiceses[i];
    }
    for (i = 0; i &lt; cms.certificates.elements.length - choiceses.length; i++) {
        final ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate certificate =
                new ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate();
        final Asn1BerDecodeBuffer decodeBuffer =
                new Asn1BerDecodeBuffer(certs[i].getEncoded());
        certificate.decode(decodeBuffer);
        cms.certificates.elements[i + choiceses.length] =
                new CertificateChoices();
        cms.certificates.elements[i + choiceses.length]
                .set_certificate(certificate);
    }
    // Signature.getInstance
    final Signature signature =
            Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    byte[] sign;
    // signer infos
    final SignerInfo[] infos = new SignerInfo[cms.signerInfos.elements.length];
    for (i = 0; i &lt; cms.signerInfos.elements.length; i++) {
        infos[i] = cms.signerInfos.elements[i];
    }
    final int nsign = keys.length + infos.length;
    cms.signerInfos = new SignerInfos(nsign);
    for (i = 0; i &lt; infos.length; i++) {
        cms.signerInfos.elements[i] = infos[i];
    }
    for (i = 0; i &lt; cms.signerInfos.elements.length - infos.length; i++) {
        signature.initSign(keys[i]);
        signature.update(text);
        sign = signature.sign();
        cms.signerInfos.elements[i + infos.length] = new SignerInfo();
        cms.signerInfos.elements[i + infos.length].version = new CMSVersion(1);
        cms.signerInfos.elements[i + infos.length].sid = new SignerIdentifier();

        final byte[] encodedName =
                ((X509Certificate) certs[i]).getIssuerX500Principal()
                        .getEncoded();
        final Asn1BerDecodeBuffer nameBuf =
                new Asn1BerDecodeBuffer(encodedName);
        final Name name = new Name();
        name.decode(nameBuf);

        final CertificateSerialNumber num = new CertificateSerialNumber(
                ((X509Certificate) certs[i]).getSerialNumber());
        cms.signerInfos.elements[i + infos.length].sid
                .set_issuerAndSerialNumber(
                        new IssuerAndSerialNumber(name, num));
        cms.signerInfos.elements[i + infos.length].digestAlgorithm =
                new DigestAlgorithmIdentifier(
                        new OID(CMStools.DIGEST_OID).value);
        cms.signerInfos.elements[i + infos.length].digestAlgorithm.parameters =
                new Asn1Null();
        cms.signerInfos.elements[i + infos.length].signatureAlgorithm =
                new SignatureAlgorithmIdentifier(
                        new OID(CMStools.SIGN_OID).value);
        cms.signerInfos.elements[i + infos
                .length].signatureAlgorithm.parameters =
                new Asn1Null();
        cms.signerInfos.elements[i + infos.length].signature =
                new SignatureValue(sign);
    }
    // encode
    final Asn1BerEncodeBuffer asn1Buf = new Asn1BerEncodeBuffer();
    all.encode(asn1Buf, true);
    Array.writeFile(path, asn1Buf.getMsgCopy());
    return asn1Buf.getMsgCopy();
}

/**
 * Подпись существующего сообщения (CMS) //хэш на signedAttributes
 *
 * @param buffer CMS
 * @param keys keys
 * @param certs certs
 * @param path path to write signCMS
 * @param data data if detached signature
 * @return byte[]
 * @throws Exception e
 */
public static byte[] hashsignCMS(byte[] buffer, PrivateKey[] keys,
                                 Certificate[] certs, String path, byte[] data)
        throws Exception {
    int i;
    final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(buffer);
    final ContentInfo all = new ContentInfo();
    all.decode(asnBuf);
    if (!new OID(CMStools.STR_CMS_OID_SIGNED).eq(all.contentType.value))
        throw new Exception("Not supported");
    final SignedData cms = (SignedData) all.content;
    if (cms.version.value != 1)
        throw new Exception("Incorrect version");
    if (!new OID(CMStools.STR_CMS_OID_DATA).eq(
            cms.encapContentInfo.eContentType.value))
        throw new Exception("Nested not supported");
    OID digestOid = null;
    final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    for (i = 0; i &lt; cms.digestAlgorithms.elements.length; i++) {
        if (cms.digestAlgorithms.elements[i].algorithm.equals(a.algorithm)) {
            digestOid =
                    new OID(cms.digestAlgorithms.elements[i].algorithm.value);
            break;
        }
    }
    if (digestOid == null)
        throw new Exception("Unknown digest");
    // certificates
    final CertificateChoices[] choiceses =
            new CertificateChoices[cms.certificates.elements.length];
    for (i = 0; i &lt; cms.certificates.elements.length; i++) {
        choiceses[i] = cms.certificates.elements[i];
    }
    final int ncerts = certs.length + choiceses.length;
    cms.certificates = new CertificateSet(ncerts);
    cms.certificates.elements = new CertificateChoices[ncerts];
    for (i = 0; i &lt; choiceses.length; i++) {
        cms.certificates.elements[i] = choiceses[i];
    }
    for (i = 0; i &lt; cms.certificates.elements.length - choiceses.length; i++) {
        final ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate certificate =
                new ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate();
        final Asn1BerDecodeBuffer decodeBuffer =
                new Asn1BerDecodeBuffer(certs[i].getEncoded());
        certificate.decode(decodeBuffer);
        cms.certificates.elements[i + choiceses.length] =
                new CertificateChoices();
        cms.certificates.elements[i + choiceses.length]
                .set_certificate(certificate);
    }
    // Signature.getInstance
    final Signature signature =
            Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    byte[] sign;
    // signer infos
    final SignerInfo[] infos = new SignerInfo[cms.signerInfos.elements.length];
    for (i = 0; i &lt; cms.signerInfos.elements.length; i++) {
        infos[i] = cms.signerInfos.elements[i];
    }
    final int nsign = keys.length + infos.length;
    cms.signerInfos = new SignerInfos(nsign);
    for (i = 0; i &lt; infos.length; i++) {
        cms.signerInfos.elements[i] = infos[i];
    }
    for (i = 0; i &lt; cms.signerInfos.elements.length - infos.length; i++) {
        cms.signerInfos.elements[i + infos.length] = new SignerInfo();
        cms.signerInfos.elements[i + infos.length].version = new CMSVersion(1);
        cms.signerInfos.elements[i + infos.length].sid = new SignerIdentifier();

        final byte[] encodedName =
                ((X509Certificate) certs[i]).getIssuerX500Principal()
                        .getEncoded();
        final Asn1BerDecodeBuffer nameBuf =
                new Asn1BerDecodeBuffer(encodedName);
        final Name name = new Name();
        name.decode(nameBuf);

        final CertificateSerialNumber num = new CertificateSerialNumber(
                ((X509Certificate) certs[i]).getSerialNumber());
        cms.signerInfos.elements[i + infos.length].sid
                .set_issuerAndSerialNumber(
                        new IssuerAndSerialNumber(name, num));
        cms.signerInfos.elements[i + infos.length].digestAlgorithm =
                new DigestAlgorithmIdentifier(
                        new OID(CMStools.DIGEST_OID).value);
        cms.signerInfos.elements[i + infos.length].digestAlgorithm.parameters =
                new Asn1Null();
        cms.signerInfos.elements[i + infos.length].signatureAlgorithm =
                new SignatureAlgorithmIdentifier(
                        new OID(CMStools.SIGN_OID).value);
        cms.signerInfos.elements[i + infos
                .length].signatureAlgorithm.parameters =
                new Asn1Null();
        //signedAttributes
        final int kmax = 3;
        cms.signerInfos.elements[i + infos.length].signedAttrs =
                new SignedAttributes(kmax);

        //-contentType
        int k = 0;
        cms.signerInfos.elements[i + infos.length].signedAttrs.elements[k] =
                new Attribute(new OID(CMStools.STR_CMS_OID_CONT_TYP_ATTR).value,
                        new Attribute_values(1));

        final Asn1Type conttype = new Asn1ObjectIdentifier(
                new OID(CMStools.STR_CMS_OID_DATA).value);

        cms.signerInfos.elements[i + infos
                .length].signedAttrs.elements[k].values.elements[0] =
                conttype;

        //-Time
        k += 1;
        cms.signerInfos.elements[i + infos.length].signedAttrs.elements[k] =
                new Attribute(new OID(CMStools.STR_CMS_OID_SIGN_TYM_ATTR).value,
                        new Attribute_values(1));

        final Time time = new Time();
//        final Asn1GeneralizedTime genTime = new Asn1GeneralizedTime();
//        //текущая дата с календаря
//        genTime.setTime(Calendar.getInstance());
//        time.set_generalTime(genTime);

        final Asn1UTCTime UTCTime = new Asn1UTCTime();
        //текущая дата с календаря
        UTCTime.setTime(Calendar.getInstance());
        time.set_utcTime(UTCTime);

        cms.signerInfos.elements[i + infos
                .length].signedAttrs.elements[k].values.elements[0] =
                time.getElement();

        //-message digest
        k += 1;
        cms.signerInfos.elements[i + infos.length].signedAttrs.elements[k] =
                new Attribute(new OID(CMStools.STR_CMS_OID_DIGEST_ATTR).value,
                        new Attribute_values(1));
        final byte[] messagedigestb;
        if (cms.encapContentInfo.eContent.value != null)
            messagedigestb =
                    CMStools.digestm(cms.encapContentInfo.eContent.value,
                            CMStools.DIGEST_ALG_NAME);
        else if (data != null)
            messagedigestb = CMStools.digestm(data, CMStools.DIGEST_ALG_NAME);
        else throw new Exception("No content");

        final Asn1Type messagedigest = new Asn1OctetString(messagedigestb);

        cms.signerInfos.elements[i + infos
                .length].signedAttrs.elements[k].values.elements[0] =
                messagedigest;

        //signature
        Asn1BerEncodeBuffer encBufSignedAttr = new Asn1BerEncodeBuffer();
        cms.signerInfos.elements[i + infos.length].signedAttrs
                .encode(encBufSignedAttr);
        final byte[] hsign = encBufSignedAttr.getMsgCopy();
        signature.initSign(keys[i]);
        signature.update(hsign);
        sign = signature.sign();

        cms.signerInfos.elements[i + infos.length].signature =
                new SignatureValue(sign);
    }
    // encode
    final Asn1BerEncodeBuffer asn1Buf = new Asn1BerEncodeBuffer();
    all.encode(asn1Buf, true);
    Array.writeFile(path, asn1Buf.getMsgCopy());
    return asn1Buf.getMsgCopy();
}
}
</java>
<java name="CMS_samples/CMSSignAndEncrypt.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 21.05.2008 12:17:43 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import com.objsys.asn1j.runtime.Asn1Null;
import com.objsys.asn1j.runtime.Asn1ObjectIdentifier;
import com.objsys.asn1j.runtime.Asn1OctetString;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_EncryptedKey;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_IV;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_ParamSet;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_Parameters;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax._Gost28147_89_EncryptionSyntaxValues;
import ru.CryptoPro.JCP.ASN.GostR3410_EncryptionSyntax.GostR3410_KeyTransport;
import ru.CryptoPro.JCP.ASN.GostR3410_EncryptionSyntax.GostR3410_TransportParameters;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.AlgorithmIdentifier;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.CertificateSerialNumber;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Name;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.RDNSequence;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.SubjectPublicKeyInfo;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.params.AlgIdInterface;
import ru.CryptoPro.JCP.params.AlgIdSpec;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.params.ParamsInterface;
import ru.CryptoPro.JCP.tools.Array;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.security.auth.x500.X500Principal;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.cert.X509Certificate;

/**
 * CryptSignAndEncryptMessage.
 * &lt;p/&gt;
 * CryptDecryptAndVerivyMessage with:
 * &lt;p/&gt;
 * csptest -sfse -decrypt -in envCMS.txt -out envCMS.txt.decr
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CMSSignAndEncrypt {

private static final String CMS_FILE = "cms_data_encr_sgn";
protected static final String CMS_FILE_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + CMS_FILE;
protected static final String CIPHER_MODE = "GOST28147/CFB/NoPadding";

/**
 * вектор усложнения ключа согласования
 */
private static final byte[] sv =
        {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};

public static void main(String[] args) throws Exception {
    // данные для подписи и последющего шифрования
    final byte[] data = Array.readFile(CMStools.DATA_FILE_PATH);

    //Загрузка хранилища
    final KeyStore hdImageStore = KeyStore.getInstance(CMStools.STORE_TYPE);
    hdImageStore.load(null, null);
    //ключ отправителя
    final PrivateKey senderKey =
            (PrivateKey) hdImageStore
                    .getKey(CMStools.SIGN_KEY_NAME, CMStools.SIGN_KEY_PASSWORD);
    final X509Certificate publicSenderCert =
            (X509Certificate) hdImageStore
                    .getCertificate(CMStools.SIGN_KEY_NAME);
    //ключ получателя
    final X509Certificate publicCert =
            (X509Certificate) hdImageStore
                    .getCertificate(CMStools.RECIP_KEY_NAME);

    //создание SignedData
    final ContentInfo contentSign = new ContentInfo();
    contentSign.contentType =
            new Asn1ObjectIdentifier(
                    new OID(CMStools.STR_CMS_OID_SIGNED).value);
    final SignedData signedData = new SignedData();
    contentSign.content = signedData;
    signedData.version = new CMSVersion(1);
    // digest
    signedData.digestAlgorithms = new DigestAlgorithmIdentifiers(1);
    final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
    a.parameters = new Asn1Null();
    signedData.digestAlgorithms.elements[0] = a;
    signedData.encapContentInfo =
            new EncapsulatedContentInfo(new Asn1ObjectIdentifier(
                    new OID(CMStools.STR_CMS_OID_DATA).value),
                    new Asn1OctetString(data));
    // certificates
    signedData.certificates = new CertificateSet(1);
    signedData.certificates.elements = new CertificateChoices[1];
    final Certificate certificate = new Certificate();
    final Asn1BerDecodeBuffer decodeBuffer =
            new Asn1BerDecodeBuffer(publicSenderCert.getEncoded());
    certificate.decode(decodeBuffer);
    signedData.certificates.elements[0] = new CertificateChoices();
    signedData.certificates.elements[0].set_certificate(certificate);
    // Signature.getInstance
    final Signature signature = Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    // signer infos
    signedData.signerInfos = new SignerInfos(1);
    signature.initSign(senderKey);
    signature.update(data);
    final byte[] sign = signature.sign();
    signedData.signerInfos.elements[0] = new SignerInfo();
    signedData.signerInfos.elements[0].version = new CMSVersion(1);
    signedData.signerInfos.elements[0].sid = new SignerIdentifier();

    final byte[] encodedName =
            publicSenderCert.getIssuerX500Principal()
                    .getEncoded();
    final Asn1BerDecodeBuffer nameBuf =
            new Asn1BerDecodeBuffer(encodedName);
    final Name name = new Name();
    name.decode(nameBuf);

    final CertificateSerialNumber num = new CertificateSerialNumber(
            publicSenderCert.getSerialNumber());
    signedData.signerInfos.elements[0].sid.set_issuerAndSerialNumber(
            new IssuerAndSerialNumber(name, num));
    signedData.signerInfos.elements[0].digestAlgorithm =
            new DigestAlgorithmIdentifier(new OID(CMStools.DIGEST_OID).value);
    signedData.signerInfos.elements[0].digestAlgorithm.parameters =
            new Asn1Null();
    signedData.signerInfos.elements[0].signatureAlgorithm =
            new SignatureAlgorithmIdentifier(
                    new OID(CMStools.SIGN_OID).value);
    signedData.signerInfos.elements[0].signatureAlgorithm.parameters =
            new Asn1Null();
    signedData.signerInfos.elements[0].signature = new SignatureValue(sign);

    // encode
    final Asn1BerEncodeBuffer asnBuf = new Asn1BerEncodeBuffer();
    contentSign.encode(asnBuf, true);

    //данные для envelopedData
    final byte[] buffer = asnBuf.getMsgCopy();

    //===============================

    final PublicKey responderPublic = publicCert.getPublicKey();

    // выработка ключа согласования отправителем
    final KeyAgreement senderKeyAgree =
            KeyAgreement.getInstance(CMStools.KEY_ALG_NAME);
    senderKeyAgree.init(senderKey, new IvParameterSpec(sv), null);
    senderKeyAgree.doPhase(responderPublic, true);
    final SecretKey alisaSecret =
            senderKeyAgree.generateSecret(CMStools.SEC_KEY_ALG_NAME);

    // Генерирование симметричного ключа с параметрами шифрования из контрольной панели.
    final KeyGenerator kg = KeyGenerator.getInstance(CMStools.SEC_KEY_ALG_NAME);
    final ParamsInterface paramss = AlgIdSpec.getDefaultCryptParams();
    kg.init(paramss);
    final SecretKey simm = kg.generateKey();

    // Зашифрование текста на симметричном ключе.
    final Cipher cipher = Cipher.getInstance(CIPHER_MODE);
    cipher.init(Cipher.ENCRYPT_MODE, simm, (SecureRandom) null);
    final byte[] iv = cipher.getIV();
    final byte[] text = cipher.doFinal(buffer, 0, buffer.length);

    //Зашифрование симметричного ключа на ключе согласования отправителя
    cipher.init(Cipher.WRAP_MODE, alisaSecret, (SecureRandom) null);
    final byte[] key = cipher.wrap(simm);

    //формирование CMS-сообщения
    final ContentInfo all = new ContentInfo();
    all.contentType =
            new Asn1ObjectIdentifier(
                    new OID(CMStools.STR_CMS_OID_ENVELOPED).value);
    final EnvelopedData cms = new EnvelopedData();
    all.content = cms;

    cms.version = new CMSVersion(0);

    cms.recipientInfos = new RecipientInfos(1);
    cms.recipientInfos.elements = new RecipientInfo[1];
    cms.recipientInfos.elements[0] = new RecipientInfo();

    final KeyTransRecipientInfo keytrans = new KeyTransRecipientInfo();

    keytrans.version = new CMSVersion(0);

    final Asn1BerEncodeBuffer ebuf = new Asn1BerEncodeBuffer();
    final SubjectPublicKeyInfo spki = new SubjectPublicKeyInfo();
    final Asn1BerDecodeBuffer dbuff = new Asn1BerDecodeBuffer(
            publicSenderCert.getPublicKey().getEncoded());
    spki.decode(dbuff);
    dbuff.reset();
    final AlgIdInterface algid = new AlgIdSpec(spki.algorithm);
    final AlgorithmIdentifier id = (AlgorithmIdentifier) algid.getDecoded();
    id.encode(ebuf);
    Asn1BerDecodeBuffer dbuf = new Asn1BerDecodeBuffer(ebuf.getMsgCopy());
    keytrans.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
    keytrans.keyEncryptionAlgorithm.decode(dbuf);
    ebuf.reset();
    dbuf.reset();
    keytrans.rid = new RecipientIdentifier();
    final IssuerAndSerialNumber issuer = new IssuerAndSerialNumber();
    final X500Principal issuerName = publicCert.getIssuerX500Principal();
    dbuf = new Asn1BerDecodeBuffer(issuerName.getEncoded());
    issuer.issuer = new Name();
    final RDNSequence rnd = new RDNSequence();
    rnd.decode(dbuf);
    issuer.issuer.set_rdnSequence(rnd);
    issuer.serialNumber = new CertificateSerialNumber(
            publicCert.getSerialNumber());
    keytrans.rid.set_issuerAndSerialNumber(issuer);
    dbuf.reset();
    final GostR3410_KeyTransport encrKey = new GostR3410_KeyTransport();
    dbuf = new Asn1BerDecodeBuffer(key);
    encrKey.sessionEncryptedKey = new Gost28147_89_EncryptedKey();
    encrKey.sessionEncryptedKey.decode(dbuf);
    dbuf.reset();
    encrKey.transportParameters = new GostR3410_TransportParameters();
    encrKey.transportParameters.encryptionParamSet =
            new Gost28147_89_ParamSet(algid.getCryptParams()
                    .getOID().value);
    encrKey.transportParameters.ephemeralPublicKey = new SubjectPublicKeyInfo();
    dbuf = new Asn1BerDecodeBuffer(
            publicSenderCert.getPublicKey().getEncoded());
    encrKey.transportParameters.ephemeralPublicKey.decode(dbuf);
    dbuf.reset();
    encrKey.transportParameters.ukm = new Asn1OctetString(sv);
    encrKey.encode(ebuf);
    keytrans.encryptedKey = new EncryptedKey(ebuf.getMsgCopy());
    ebuf.reset();
    cms.recipientInfos.elements[0].set_ktri(keytrans);

    cms.encryptedContentInfo = new EncryptedContentInfo();
    final OID contentType = new OID(CMStools.STR_CMS_OID_DATA);
    cms.encryptedContentInfo.contentType = new ContentType(contentType.value);
    final Gost28147_89_Parameters params = new Gost28147_89_Parameters();
    params.iv = new Gost28147_89_IV(iv);
    params.encryptionParamSet =
            new Gost28147_89_ParamSet(paramss.getOID().value);
    cms.encryptedContentInfo.contentEncryptionAlgorithm =
            new ContentEncryptionAlgorithmIdentifier(
                    _Gost28147_89_EncryptionSyntaxValues.id_Gost28147_89,
                    params);
    cms.encryptedContentInfo.encryptedContent = new EncryptedContent(text);

    all.encode(ebuf);
    Array.writeFile(CMS_FILE_PATH, ebuf.getMsgCopy());
    CMStools.logger.info("ok");
}
}
</java>
<java name="CMS_samples/CMSVerify.java">/**
 * $RCSfile$
 * version $Revision: 36638 $
 * created 16.08.2007 11:28:24 by kunina
 * last modified $Date: 2012-12-03 20:09:25 +0400 (Mon, 03 Dec 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import com.objsys.asn1j.runtime.*;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Attribute;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Time;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.tools.Array;

import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

/**
 * CMS Verify (поиск сертификатов: 1)CMS, 2)заданные сертификаты, 3)store(?))
 * [Проверка параллельных подписей  и подписей с signedAttributes]
 * &lt;p/&gt;
 * Проверяет:
 * &lt;p/&gt;
 * CMS_samples.CMSSign
 * &lt;p/&gt;
 * csptest -lowsign -in data.txt -my key -sign -out data_low.sgn -add
 * &lt;p/&gt;
 * csptest -lowsign -in data.txt -my key -sign -out data_low.sgn (нет вложенного
 * сертификата)
 * &lt;p/&gt;
 * csptest -sfsign -in data.txt -my key -sign -out data_sf.sgn -add
 * &lt;p/&gt;
 * csptest -sfsign -in data.txt -my key -sign -out data_sf.sgn (нет вложенного
 * сертификата)
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CMSVerify {
//CMS.java
private static final String CMS_FILE = "cms_data_sgn";
//CMSSign.java
//private static final String CMS_FILE = "cms_data_low_sgn";
//private static final String CMS_FILE = "cms_data_sf_sgn";

private static final String CMS_FILE_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + CMS_FILE + CMStools.CMS_EXT;

private static StringBuffer out = new StringBuffer("");
private static StringBuffer out1 = new StringBuffer("");
private static int validsign;

 /**/
private CMSVerify() {
}

public static void main(String[] args) throws Exception {
    //данные для проверки (CMS)
    final byte[] signdata = Array.readFile(CMS_FILE_PATH);
//    final Certificate cert = CMStools.loadCertificate(CMStools.SIGN_KEY_NAME);
    //Certificate cert = CMStools.readCertificate(CMStools.SIGN_CERT_PATH);

    //проверка
    final Certificate[] certs = new Certificate[1];
    certs[0] = CMStools.loadCertificate(CMStools.SIGN_KEY_NAME);
    CMSVerify(signdata, certs, null);
}

/**
 * проверка CMS
 *
 * @param buffer буфер
 * @param certs сертификаты
 * @param data данные
 * @throws Exception e
 *
 * @deprecated начиная с версии 1.0.54, следует использовать функцонал CAdES API (CAdES.jar)
 */
public static void CMSVerify(byte[] buffer, Certificate[] certs, byte[] data)
        throws Exception {
    //clear buffers fo logs
    out = new StringBuffer("");
    out1 = new StringBuffer("");
    final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(buffer);
    final ContentInfo all = new ContentInfo();
    all.decode(asnBuf);
    if (!new OID(CMStools.STR_CMS_OID_SIGNED).eq(all.contentType.value))
        throw new Exception("Not supported");
    final SignedData cms = (SignedData) all.content;
    final byte[] text;
    if (cms.encapContentInfo.eContent != null)
        text = cms.encapContentInfo.eContent.value;
    else if (data != null) text = data;
    else throw new Exception("No content for verify");
    System.out.println(new String(text));
    OID digestOid = null;
    final DigestAlgorithmIdentifier digestAlgorithmIdentifier =
            new DigestAlgorithmIdentifier(new OID(CMStools.DIGEST_OID).value);
    for (int i = 0; i &lt; cms.digestAlgorithms.elements.length; i++) {
        if (cms.digestAlgorithms.elements[i].algorithm
                .equals(digestAlgorithmIdentifier.algorithm)) {
            digestOid =
                    new OID(cms.digestAlgorithms.elements[i].algorithm.value);
            break;
        }
    }
    if (digestOid == null)
        throw new Exception("Unknown digest");
    final OID eContTypeOID = new OID(cms.encapContentInfo.eContentType.value);
    if (cms.certificates != null) {
        //Проверка на вложенных сертификатах
        CMStools.logger.info("Validation on certificates founded in CMS.");
        for (int i = 0; i &lt; cms.certificates.elements.length; i++) {
            final Asn1BerEncodeBuffer encBuf = new Asn1BerEncodeBuffer();
            cms.certificates.elements[i].encode(encBuf);

            final CertificateFactory cf =
                    CertificateFactory.getInstance("X.509");
            final X509Certificate cert =
                    (X509Certificate) cf
                            .generateCertificate(encBuf.getInputStream());

            for (int j = 0; j &lt; cms.signerInfos.elements.length; j++) {
                final SignerInfo info = cms.signerInfos.elements[j];
                if (!digestOid
                        .equals(new OID(info.digestAlgorithm.algorithm.value)))
                    throw new Exception("Not signed on certificate.");
                final boolean checkResult = verifyOnCert(cert,
                        cms.signerInfos.elements[j], text, eContTypeOID, true);
                writeLog(checkResult, j, i, cert);
            }
        }
    } else if (certs != null) {
        //Проверка на указанных сертификатах
        CMStools.logger.info("Certificates for validation not found in CMS.\n" +
                "      Try verify on specified certificates...");
        for (int i = 0; i &lt; certs.length; i++) {
            final X509Certificate cert = (X509Certificate) certs[i];
            for (int j = 0; j &lt; cms.signerInfos.elements.length; j++) {
                final SignerInfo info = cms.signerInfos.elements[j];
                if (!digestOid.equals(new OID(
                        info.digestAlgorithm.algorithm.value)))
                    throw new Exception("Not signed on certificate.");
                final boolean checkResult = verifyOnCert(cert,
                        cms.signerInfos.elements[j], text, eContTypeOID, true);
                writeLog(checkResult, j, i, cert);
            }
        }
    } else {
        CMStools.logger.warning("Certificates for validation not found");
    }
    if (validsign == 0) throw new Exception("Signatures are invalid" + out1);
    if (cms.signerInfos.elements.length &gt; validsign)
        throw new Exception("Some signatures are invalid:" + out + out1);
    else CMStools.logger.info("All signatures are valid:" + out);
}

/**
 * Попытка проверки подписи на указанном сертификате.
 * Проверка может быть выполнена как по отсортированным (по RFC,
 * по умолчанию) подписанным аттрибутам, так и по неотсортированным
 * (не по RFC).
 *
 * @param cert сертификат для проверки
 * @param text текст для проверки
 * @param info подпись
 * @param eContentTypeOID тип содержимого
 * @param needSortSignedAttributes False, если необходимо проверить
 * подпись по неотсортированным подписанным аттрибутам. По умолчанию
 * подписанные аттрибуты сортируются (RFC) перед кодированием в
 * лексикографическом порядке.
 * @return верна ли подпись
 * @throws Exception ошибки
 */
private static boolean verifyOnCert(X509Certificate cert, SignerInfo info,
    byte[] text, OID eContentTypeOID, boolean needSortSignedAttributes)
    throws Exception {

    //подпись
    final byte[] sign = info.signature.value;

    //данные для проверки подписи
    final byte[] data;

    if (info.signedAttrs == null) {
        //аттрибуты подписи не присутствуют
        //данные для проверки подписи
        data = text;
    } else {
        //присутствуют аттрибуты подписи (SignedAttr)
        final Attribute[] signAttrElem = info.signedAttrs.elements;

        //проверка аттрибута content-type
        final Asn1ObjectIdentifier contentTypeOid = new Asn1ObjectIdentifier(
                (new OID(CMStools.STR_CMS_OID_CONT_TYP_ATTR)).value);
        Attribute contentTypeAttr = null;

        for (int r = 0; r &lt; signAttrElem.length; r++) {
            final Asn1ObjectIdentifier oid = signAttrElem[r].type;
            if (oid.equals(contentTypeOid)) {
                contentTypeAttr = signAttrElem[r];
            }
        }

        if (contentTypeAttr == null)
            throw new Exception("content-type attribute not present");

        if (!contentTypeAttr.values.elements[0]
                .equals(new Asn1ObjectIdentifier(eContentTypeOID.value)))
            throw new Exception(
                    "content-type attribute OID not equal eContentType OID");

        //проверка аттрибута message-digest
        final Asn1ObjectIdentifier messageDigestOid = new Asn1ObjectIdentifier(
                (new OID(CMStools.STR_CMS_OID_DIGEST_ATTR)).value);

        Attribute messageDigestAttr = null;

        for (int r = 0; r &lt; signAttrElem.length; r++) {
            final Asn1ObjectIdentifier oid = signAttrElem[r].type;
            if (oid.equals(messageDigestOid)) {
                messageDigestAttr = signAttrElem[r];
            }
        }

        if (messageDigestAttr == null)
            throw new Exception("message-digest attribute not present");

        final Asn1Type open = messageDigestAttr.values.elements[0];
        final Asn1OctetString hash = (Asn1OctetString) open;
        final byte[] md = hash.value;

        //вычисление messageDigest
        final byte[] dm = CMStools.digestm(text, CMStools.DIGEST_ALG_NAME);

        if (!Array.toHexString(dm).equals(Array.toHexString(md)))
            throw new Exception("message-digest attribute verify failed");

        //проверка аттрибута signing-time
        final Asn1ObjectIdentifier signTimeOid = new Asn1ObjectIdentifier(
                (new OID(CMStools.STR_CMS_OID_SIGN_TYM_ATTR)).value);

        Attribute signTimeAttr = null;

        for (int r = 0; r &lt; signAttrElem.length; r++) {
            final Asn1ObjectIdentifier oid = signAttrElem[r].type;
            if (oid.equals(signTimeOid)) {
                signTimeAttr = signAttrElem[r];
            }
        }

        if (signTimeAttr != null) {
            //проверка (необязательно)
            Time sigTime = (Time)signTimeAttr.values.elements[0];
            Asn1UTCTime time = (Asn1UTCTime) sigTime.getElement();
            System.out.println(time);
        }

        //данные для проверки подписи
        final Asn1BerEncodeBuffer encBufSignedAttr = new Asn1BerEncodeBuffer();
        info.signedAttrs.needSortSignedAttributes = needSortSignedAttributes;
        info.signedAttrs.encode(encBufSignedAttr);

        data = encBufSignedAttr.getMsgCopy();
    }

    // Проверяем подпись.
    Signature signature = Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    signature.initVerify(cert);
    signature.update(data);

    boolean verified = signature.verify(sign);

    // Если подпись не корректна, а у нас есть подписанные аттрибуты,
    // которые только что были отсортированы согласно rfc перед проверкой,
    // то пробуем проверить подпись также, но несортируя аттрибуты.
    if (!verified &amp;&amp; info.signedAttrs != null &amp;&amp; needSortSignedAttributes) {
        return verifyOnCert(cert, info, text, eContentTypeOID, false);
    }

    return verified;
}

/**
 * write log
 *
 * @param checkResult прошла ли проверка
 * @param signNum номер подписи
 * @param certNum номер сертификата
 * @param cert сертификат
 */
private static void writeLog(boolean checkResult, int signNum, int certNum,
                             X509Certificate cert) {
    if (checkResult) {
        out.append("\n");
        out.append("sign[");
        out.append(signNum);
        out.append("] - Valid signature on cert[");
        out.append(certNum);
        out.append("] (");
        out.append(cert.getSubjectX500Principal());
        out.append(")");
        validsign += 1;
    } else {
        out1.append("\n");
        out1.append("sign[");
        out1.append(signNum);
        out1.append("] - Invalid signature on cert[");
        out1.append(certNum);
        out1.append("] (");
        out1.append(cert.getSubjectX500Principal());
        out1.append(")");
    }
}
}
</java>
<java name="CMS_samples/CMStools.java">/**
 * $RCSfile$
 * version $Revision: 36577 $
 * created 21.04.2009 16:51:19 by kunina
 * last modified $Date: 2012-10-10 13:14:11 +0400 (Wed, 10 Oct 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.tools.Array;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.util.logging.Logger;

/**
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CMStools {

/**
 * расширение файла сертификата
 */
public static final String CERT_EXT = ".cer";
/**
 * расширение файла
 */
public static final String CMS_EXT = ".p7b";
/**
 * разделитель
 */
public static final String SEPAR = File.separator;
/**
 * рабочая директория
 */
public static String TEST_PATH = System.getProperty("user.dir") + SEPAR + "temp";

/**
 * имя отправителя (контейнер, сертификат)
 */
public static final String SIGN_KEY_NAME = "gost_exch";
public static final String SIGN_KEY_NAME_CONT = "gostrexc.000";
public static final char[] SIGN_KEY_PASSWORD = "Pass1234".toCharArray();
public static String SIGN_CERT_PATH =
        TEST_PATH + SEPAR + SIGN_KEY_NAME + CERT_EXT;

/**
 * имя получателя (контейнер, сертификат)
 */
public static final String RECIP_KEY_NAME = "afevma_gost_exch_server";
public static final String RECIP_KEY_NAME_CONT = "afevmarg.003";
public static final char[] RECIP_KEY_PASSWORD = "security".toCharArray();
public static String RECIP_CERT_PATH =
        TEST_PATH + SEPAR + RECIP_KEY_NAME + CERT_EXT;

/**
 * алгоритмы и т.д.
 */
public static final String STORE_TYPE = "HDImageStore";
public static final String KEY_ALG_NAME = JCP.GOST_DH_NAME;
public static final String DIGEST_ALG_NAME = JCP.GOST_DIGEST_NAME;

public static final String SEC_KEY_ALG_NAME = "GOST28147";

/**
 * OIDs для CMS
 */
public static final String STR_CMS_OID_DATA = "1.2.840.113549.1.7.1";
public static final String STR_CMS_OID_SIGNED = "1.2.840.113549.1.7.2";
public static final String STR_CMS_OID_ENVELOPED = "1.2.840.113549.1.7.3";

public static final String STR_CMS_OID_CONT_TYP_ATTR = "1.2.840.113549.1.9.3";
public static final String STR_CMS_OID_DIGEST_ATTR = "1.2.840.113549.1.9.4";
public static final String STR_CMS_OID_SIGN_TYM_ATTR = "1.2.840.113549.1.9.5";

public static final String STR_CMS_OID_TS = "1.2.840.113549.1.9.16.1.4";

public static final String DIGEST_OID = JCP.GOST_DIGEST_OID;
public static final String SIGN_OID = JCP.GOST_EL_KEY_OID;

/**
 * исходные данные
 */
public static final String DATA = "12345";
public static final String DATA_FILE = "data.txt";
public static String DATA_FILE_PATH = TEST_PATH + SEPAR + DATA_FILE;

/**
 * logger
 */
public static final Logger logger = Logger.getLogger("LOG");

/**
 * @param args *
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //создание контейнеров
    createContainer(RECIP_KEY_NAME, RECIP_KEY_PASSWORD);
    createContainer(SIGN_KEY_NAME, SIGN_KEY_PASSWORD);
    prepareCertsAndData();
}

public static void prepareCertsAndData() throws Exception {
    //экспорт сертификатов
    expCert(RECIP_KEY_NAME, RECIP_CERT_PATH);
    expCert(SIGN_KEY_NAME, SIGN_CERT_PATH);
    //запись исходных данных
    Array.writeFile(DATA_FILE_PATH, DATA.getBytes());
}

/**
 * @param name имя
 * @param pathh путь для сохранения
 * @throws KeyStoreException /
 * @throws NoSuchAlgorithmException /
 * @throws IOException /
 * @throws CertificateException /
 */
private static void expCert(String name, String pathh) throws KeyStoreException,
        NoSuchAlgorithmException, IOException, CertificateException {
    final KeyStore ks = KeyStore.getInstance(STORE_TYPE);
    ks.load(null, null);
    final Certificate cert = ks.getCertificate(name);
    Array.writeFile(pathh, cert.getEncoded());
}

/**
 * @param name имя контейнера
 * @param password пароль на контейнер
 * @throws NoSuchAlgorithmException /
 * @throws IOException /
 * @throws SignatureException /
 * @throws InvalidKeyException /
 * @throws CertificateException /
 * @throws KeyStoreException /
 */
private static void createContainer(String name, char[] password)
        throws NoSuchAlgorithmException, IOException, SignatureException,
        InvalidKeyException, CertificateException, KeyStoreException, NoSuchProviderException {
    final KeyPairGenerator kg = KeyPairGenerator.getInstance(KEY_ALG_NAME);
    final KeyPair keyPair = kg.generateKeyPair();
    //генерирование самоподписанного сертификата(клиент)
    final GostCertificateRequest req = new GostCertificateRequest();
    req.init(KEY_ALG_NAME, false);
    req.setPublicKeyInfo(keyPair.getPublic());
    req.setSubjectInfo("CN=" + name);
    req.encodeAndSign(keyPair.getPrivate());

    // TODO использовать адрес внутреннего УЦ ??
    final byte[] encodedCert = req.getEncodedCert("http://www.cryptopro.ru/certsrv/");

    final byte[] encodedRootCert = GostCertificateRequest
            .getEncodedRootCert("http://www.cryptopro.ru/certsrv/");

    final CertificateFactory cf = CertificateFactory.getInstance("X509");

    final Certificate clientCert =
            cf.generateCertificate(new ByteArrayInputStream(encodedCert));
    final Certificate rootCert =
            cf.generateCertificate(new ByteArrayInputStream(encodedRootCert));

    final Certificate[] certs;
    certs = new Certificate[2];
    certs[0] = clientCert;
    certs[1] = rootCert;

    //запись в хранилище ключевой пары с сертификатом
    final KeyStore ks = KeyStore.getInstance(STORE_TYPE);
    ks.load(null, null);
    ks.setKeyEntry(name, keyPair.getPrivate(), password, certs);
}

/**
 * Получение PrivateKey из store.
 *
 * @param name alias ключа
 * @param password пароль на ключ
 * @return PrivateKey
 * @throws Exception in key read
 */
public static PrivateKey loadKey(String name, char[] password)
        throws Exception {
    final KeyStore hdImageStore = KeyStore.getInstance(CMStools.STORE_TYPE);
    hdImageStore.load(null, null);
    return (PrivateKey) hdImageStore.getKey(name, password);
}

/**
 * Получение certificate из store.
 *
 * @param name alias сертификата.
 * @return Certificate
 * @throws Exception in cert read
 */
public static Certificate loadCertificate(String name)
        throws Exception {
    final KeyStore hdImageStore = KeyStore.getInstance(CMStools.STORE_TYPE);
    hdImageStore.load(null, null);
    return hdImageStore.getCertificate(name);
}

/**
 * read certificate from file.
 *
 * @param fileName certificate file name
 * @return certificate
 * @throws IOException in cert read
 * @throws CertificateException if error file format
 */
public static Certificate readCertificate(String fileName) throws IOException,
        CertificateException {
    FileInputStream fis = null;
    BufferedInputStream bis = null;
    final Certificate cert;
    try {
        fis = new FileInputStream(fileName);
        bis = new BufferedInputStream(fis);
        final CertificateFactory cf = CertificateFactory.getInstance("X.509");
        cert = cf.generateCertificate(bis);
        return cert;
    } finally {
        if (bis != null) bis.close();
        if (fis != null) fis.close();
    }
}

/**
 * @param bytes bytes
 * @param digestAlgorithmName algorithm
 * @return digest
 * @throws Exception e
 */
public static byte[] digestm(byte[] bytes, String digestAlgorithmName)
        throws Exception {
    //calculation messageDigest
    final ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
    final MessageDigest digest = MessageDigest.getInstance(digestAlgorithmName);
    final DigestInputStream digestStream =
            new DigestInputStream(stream, digest);
    while (digestStream.available() != 0) digestStream.read();
    return digest.digest();
}
}
</java>
<java name="CMS_samples/CSignDataUse.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 08.07.2008 17:06:43 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import ru.CryptoPro.JCP.tools.Array;
import ru.CryptoPro.JCP.tools.Decoder;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;

/**
 * Пример проверки подписи полученной с помощью CSignData.js.
 * &lt;p/&gt;
 * Обратная процедура аналогична (на вход при генерировании отделенной подписи в
 * java необходимо подавать закодированные в UTF-16LE данные).
 * &lt;p/&gt;
 * Процедура кодирования в UTF-16LE является только особенностью работы скрипта
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CSignDataUse {
 /**/
public CSignDataUse() {
}

/**
 * рабочая директория для данного примера
 */
private static final String DIR_NAME = "CsignDataSample";
private static final String DIR_PATH =
        CMStools.TEST_PATH + CMStools.SEPAR + DIR_NAME;

/**
 * файл cms сообщения
 */
private static final String CMS_FILE = "cap.cms";
private static final String CMS_FILE_PATH =
        DIR_PATH + CMStools.SEPAR + CMS_FILE;

/**
 * файл данных
 */
private static final String DATA_FILE = "text.txt";
private static final String DATA_FILE_PATH =
        DIR_PATH + CMStools.SEPAR + DATA_FILE;

/**
 * @param args /
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //создание рабочей папки
    new File(DIR_PATH).mkdir();

    //подготовка текста для подписи
    Array.writeFile(DATA_FILE_PATH, "text".getBytes());

    //генерирование подписи с помощью CSignData.js (из командной строки)
    //cscript CSignData.js sign $DIR_PATH\text.txt $DIR_PATH\cap.cms

    //проверка
    if (new File(CMS_FILE_PATH).exists()) {
        //проверка подписи
        verify();
    }
}

/**
 * Проверка подписи, полученной с помощью CSignData.js
 *
 * @throws Exception /
 */
public static void verify()
        throws Exception {
    //чтение cms файла
    final byte[] cmsBase = Array.readFile(CMS_FILE_PATH);

    //декодирование из base64 в der
    final Decoder decoder = new Decoder();
    final byte[] cmsDer =
            decoder.decodeBuffer(new ByteArrayInputStream(cmsBase));

    //кодирование данных в UTF-16LE
    final byte[] data = Array.readFile(DATA_FILE_PATH);
    final Charset charset = Charset.forName("UTF-16LE");
    final CharsetEncoder encoder = charset.newEncoder();
    final byte[] encData =
            encoder.encode(CharBuffer.wrap(new String(data))).array();

    //проверка подписи
    CMSVerify.CMSVerify(cmsDer, null, encData);
}
}
</java>
<java name="CMS_samples/DetachedSignatureFileExample.java">package CMS_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import com.objsys.asn1j.runtime.Asn1Null;
import com.objsys.asn1j.runtime.Asn1ObjectIdentifier;
import com.objsys.asn1j.runtime.Asn1OctetString;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.CertificateSerialNumber;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Name;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.tools.Array;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Arrays;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 27.06.12
 * Time: 12:54
 * To change this template use File | Settings | File Templates.
 */
public class DetachedSignatureFileExample {

    /**
     * Файл приличного размера.
     */
    public static final String fileName = "C:\\TESTS\\CMS\\data.exe";

    /**
     * Алиас ключа для подписи.
     */
    public static final String alias = "gost_exch";

    /**
     * Пароль к контейнеру с ключом.
     */
    public static final char[] password = "Pass1234".toCharArray();

    /**
     * Пример.
     *
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {

        // Грузим хранилище.
        KeyStore keyStore = KeyStore.getInstance("HDImageStore");
        keyStore.load(null, null);

        // Получаем ключ и сертификат.
        PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, password);
        X509Certificate certificate = (X509Certificate) keyStore.getCertificate(alias);

        // Создаем подпись, при этом сначала получаем хеш с файла.
        Signature signature = Signature.getInstance(JCP.GOST_DHEL_SIGN_NAME);
        signature.initSign(privateKey);
        readAndHash(signature, fileName);

        // Создаем подпись.
        byte[] cms = CMS.createCMS(null, signature.sign(), certificate, true);

        // Пишем ее в файл - потом можно проверить в csptest:
        /*
            csptest -sfsign -verify -in "C:\TESTS\CMS\data.exe" -signature
            "C:\jcp_sig_64_data_exe.dat" -detached -cades_disable
         */
        Array.writeFile("C:\\jcp_sig_64_data_exe.dat", cms);

        // Проверяем подпись, снова сначала получаем хеш с файла.
        signature = Signature.getInstance(JCP.GOST_DHEL_SIGN_NAME);
        signature.initVerify(certificate.getPublicKey());
        readAndHash(signature, fileName);

        verify(cms, certificate, signature);
    }

    /**
     * Читаем файл и по кусочкам хешируем.
     *
     * @param signature Проинициализированная подпись.
     * @param fileName Имя файла для хеширования.
     * @return подпись с хешем.
     * @throws Exception
     */
    public static Signature readAndHash(Signature signature, String fileName) throws Exception {

        File file = new File(fileName);
        FileInputStream fData = new FileInputStream(file);

        // Не очень удобный способ чтения, но ведь это пример.
        int read;
        while ( (read = fData.read()) != -1) {
            signature.update((byte)read);
        }

        fData.close();

        return signature;
    }

    /**
     * Проверка подписи.
     *
     * @param buffer Отделенная подпись.
     * @param cert Сертификат для проверки подписи.
     * @param signature Проверяемая подпись.
     * @throws Exception
     */
    public static void verify(byte[] buffer, X509Certificate cert, Signature signature)
            throws Exception {

        int i;
        final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(buffer);
        final ContentInfo all = new ContentInfo();

        all.decode(asnBuf);

        if (!new OID(CMStools.STR_CMS_OID_SIGNED).eq(all.contentType.value)) {
            throw new Exception("Not supported");
        }

        final SignedData cms = (SignedData) all.content;

        if (cms.version.value != 1) {
            throw new Exception("Incorrect version");
        }

        if (!new OID(CMStools.STR_CMS_OID_DATA).eq(cms.encapContentInfo.eContentType.value)) {
            throw new Exception("Nested not supported");
        }

        OID digestOid = null;

        DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(new OID(CMStools.DIGEST_OID).value);

        for (i = 0; i &lt; cms.digestAlgorithms.elements.length; i++) {
            if (cms.digestAlgorithms.elements[i].algorithm.equals(a.algorithm)) {
                digestOid =
                        new OID(cms.digestAlgorithms.elements[i].algorithm.value);
                break;
            }
        }

        if (digestOid == null) {
            throw new Exception("Unknown digest");
        }

        int pos = -1;

        for (i = 0; i &lt; cms.certificates.elements.length; i++) {

            final Asn1BerEncodeBuffer encBuf = new Asn1BerEncodeBuffer();
            cms.certificates.elements[i].encode(encBuf);

            final byte[] in = encBuf.getMsgCopy();

            X509Certificate tmp = (X509Certificate) CertificateFactory.getInstance("X.509")
                .generateCertificate(new ByteArrayInputStream(in));

            System.out.println(tmp.getSubjectDN());
            System.out.println(cert.getSubjectDN());

            if (Arrays.equals(in, cert.getEncoded())) {
                pos = i;
                break;
            }
        }

        if (pos == -1) {
            throw new Exception("Not signed on certificate.");
        }

        final SignerInfo info = cms.signerInfos.elements[pos];

        if (info.version.value != 1) {
            throw new Exception("Incorrect version");
        }

        if (!digestOid.equals(new OID(info.digestAlgorithm.algorithm.value))) {
            throw new Exception("Not signed on certificate.");
        }

        final byte[] sign = info.signature.value;

        // check
        final boolean checkResult = signature.verify(sign);

        if (checkResult) {
            CMStools.logger.info("Valid signature");
        }
        else {
            throw new Exception("Invalid signature.");
        }
    }

}
</java>
<java name="CMS_samples/GetIssuerAndSerialNumber.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 07.07.2008 17:47:14 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package CMS_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.ContentInfo;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.IssuerAndSerialNumber;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.SignedData;
import ru.CryptoPro.JCP.tools.Array;
import sun.security.x509.SerialNumber;

import javax.security.auth.x500.X500Principal;

/**
 * get issuer and serial number
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class GetIssuerAndSerialNumber {
 /**/
private GetIssuerAndSerialNumber() {
}

/**
 * @param args /
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //cms for sample
    final byte[] buffer = CMS.CMSSign(Array.readFile(CMStools.DATA_FILE_PATH),
            CMStools.loadKey(CMStools.SIGN_KEY_NAME,
                    CMStools.SIGN_KEY_PASSWORD),
            CMStools.loadCertificate(CMStools.SIGN_KEY_NAME), false);
    //get issuer and serial number
    final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(buffer);
    final ContentInfo all = new ContentInfo();
    all.decode(asnBuf);
    final SignedData cms = (SignedData) all.content;
    Asn1BerEncodeBuffer encBuf = new Asn1BerEncodeBuffer();
    cms.signerInfos.elements[0].sid.encode(encBuf);
    final Asn1BerDecodeBuffer decBuf =
            new Asn1BerDecodeBuffer(encBuf.getMsgCopy());
    IssuerAndSerialNumber isn = new IssuerAndSerialNumber();
    isn.decode(decBuf);
    //name
    encBuf.reset();
    isn.issuer.encode(encBuf);
    X500Principal name = new X500Principal(encBuf.getMsgCopy());
    CMStools.logger.info("name = " + name.getName());
    //serial number
    encBuf.reset();
    isn.serialNumber.encode(encBuf);
    SerialNumber sn = new SerialNumber(encBuf.getInputStream());
    CMStools.logger.info("serial = " + sn.getNumber().toString());
}
}
</java>
<java name="CMS_samples/LargeFileTest.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package CMS_samples;

import org.bouncycastle.cms.*;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import ru.CryptoPro.JCP.JCP;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.CertStore;
import java.security.cert.Certificate;
import java.security.cert.CollectionCertStoreParameters;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Iterator;

/**
 * Пример поточной совмещенной/отделенной подписи и проверки файла (УЭК ЭДО)
 * большого размера. Файл читается порциями. Используется криптопровайдер
 * Bouncycastle с переопределением ГОСТ алгоритмов.
 *
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 24.07.12
 * Time: 18:09
 * To change this template use File | Settings | File Templates.
 */
public class LargeFileTest {

    /**
     * Адиас ключа.
     */
    private static final String ALIAS = "bukin_exch";
    /**
     * Пароль к контейнеру.
     */
    private static final char[] PASSWORD = "Pass1234".toCharArray();
    /**
     * Входящий файл с данными.
     */
    private static final String DATA_FILE = "C:\\large.file";
    /**
     * Исходящий файл с подписью (совмещенная).
     */
    private static final String SIGNATURE_FILE = "C:\\attached.signature";
    /**
     * Флаг, что подпись совмещенная.
     */
    private static final boolean attached = true;
    /**
     * Размер буфера для чтения файла с данными.
     */
    private static final int BUFFER_SIZE = 8 * 1024 * 1024;

    public static void main(String[] args) throws Exception {

        // I. Подготовка.

        // Баунсикасловский провайдер.
        if (Security.getProvider("BC") == null) {
            Security.addProvider(new BouncyCastleProvider());
        }

        // Переопределяем алгоритмы на Крипто-Про.
        org.bouncycastle.cms.CMSConfig.setSigningDigestAlgorithmMapping(JCP.GOST_DIGEST_OID, JCP.GOST_DIGEST_NAME);
        org.bouncycastle.cms.CMSConfig.setSigningEncryptionAlgorithmMapping(JCP.GOST_EL_DH_OID, "GOST3410DHEL");
        org.bouncycastle.cms.CMSConfig.setSigningEncryptionAlgorithmMapping(JCP.GOST_EL_KEY_OID, JCP.GOST_EL_DEGREE_NAME);

        // Грузим ключ и сертификат.
        KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
        keyStore.load(null, null);

        // Первый в списке сертификатов - сертификат ключа подписи.
        PrivateKey privKey = (PrivateKey)keyStore.getKey(ALIAS, PASSWORD);
        Certificate[] certChain = keyStore.getCertificateChain(ALIAS);

        // II. Создание подписи.

        long startTime = Calendar.getInstance().getTimeInMillis();

        // Поточный генератор.
        CMSSignedDataStreamGenerator signGen = new CMSSignedDataStreamGenerator();

        // Добавляем подписанта.
        signGen.addSigner(privKey, (X509Certificate) certChain[0], JCP.GOST_EL_DH_OID,
                JCP.GOST_DIGEST_OID, "JCP");

        ArrayList certList = new ArrayList();
        for ( int i = 0; i &lt; certChain.length;i++) {
            certList.add(certChain[i]);
        }

        // Добавляемые в подпись сертификаты. У нас один сертификат.
        signGen.addCertificatesAndCRLs(CertStore.getInstance("Collection",
            new CollectionCertStoreParameters(certList)));

        // Файловый поток для сохранения подписи и данных.
        FileOutputStream signatureFile = new FileOutputStream(SIGNATURE_FILE);

        // Готовим совмещенную подпись.
        OutputStream signatureOutStream = signGen.open(signatureFile, attached);

        // Входящие данные для подписи.
        FileInputStream fIn = new FileInputStream(DATA_FILE);
        FileChannel fInChannel = fIn.getChannel();

        // Буфер для чтения файла.
        ByteBuffer buffer = ByteBuffer.allocateDirect(BUFFER_SIZE);

        // Читаем файл частями и пишем в поток для хеширования и дальнейшей подписи.
        while ( fInChannel.read(buffer) != -1 ) {

            buffer.flip();

            byte[] byteBufferArray = new byte[buffer.remaining()];
            buffer.get(byteBufferArray);

            signatureOutStream.write(byteBufferArray);
            buffer.clear();
        }

        fInChannel.close();
        fIn.close();

        // Тут сработает генератор.
        signatureOutStream.close();
        signatureFile.close();

        System.out.println("Создали подпись: OK (" + (Calendar.getInstance().getTimeInMillis() - startTime) + " мс)");

        // III. Проверка подписи.

        startTime = Calendar.getInstance().getTimeInMillis();

        // Файловый поток читаемой подписи.
        FileInputStream fInSig = new FileInputStream(SIGNATURE_FILE);

        CMSSignedDataParser parser = null;

        // Декодируем подпись.
        if (attached) {
            parser = new CMSSignedDataParser(fInSig);
        }
        else {
            CMSTypedStream dataStream = new CMSTypedStream(new FileInputStream(DATA_FILE));
            parser = new CMSSignedDataParser(dataStream, fInSig);
        }

        parser.getSignedContent().drain();

        // Список подписантов.
        SignerInformationStore signers = parser.getSignerInfos();

        // Список сертификатов для проверки подписи.
        CertStore cs = parser.getCertificatesAndCRLs("Collection", "BC");
        Collection signerInfos = signers.getSigners();

        Iterator it = signerInfos.iterator();

        while (it.hasNext()) {

            // Получаем подписанта и соответствующий ему сертификат.
            X509Certificate cert = null;
            SignerInformation nextSigner = (SignerInformation)it.next();
            Collection certCollection = cs.getCertificates(nextSigner.getSID());

            if (certCollection.isEmpty() ) {
                break;
            }
            else {
                Iterator certIt = certCollection.iterator();
                cert = (X509Certificate)certIt.next();
            }

            // Проверяем подпись.
            // Можно проверить в CSP так:
            // csptest -cmssfsign -verify -in "C:\attached.signature" -my УЦ -cades_disable
            if (nextSigner.verify(cert.getPublicKey(), JCP.PROVIDER_NAME)) {
                System.out.println("ЭЦП проверена открытым ключом сертификата: " + cert.getSubjectDN());
            }

        }

        System.out.println("Проверили подпись: OK ( " + (Calendar.getInstance().getTimeInMillis() - startTime) + " мс)");

    }
}
</java>
<java name="CMS_samples/PKCS7Env.java">/**
 * Пример зашифрования/расшифрования PKCS7 (detached/attached).
 * Составлен из примеров CMS, CMSDcrypt, CMSSignAndEncrypt. 
 * Требуется наличие набора примеров samples.jar.
 */
package CMS_samples;

import java.io.IOException;
import java.security.*;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.security.auth.x500.X500Principal;

import com.objsys.asn1j.runtime.*;
import CMS_samples.CMSVerify;
import CMS_samples.CMStools;
import ru.CryptoPro.Crypto.spec.GostCipherSpec;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.*;
import ru.CryptoPro.JCP.ASN.GostR3410_EncryptionSyntax.*;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.*;
import ru.CryptoPro.JCP.params.AlgIdInterface;
import ru.CryptoPro.JCP.params.AlgIdSpec;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.params.ParamsInterface;
import ru.CryptoPro.JCP.tools.Array;

/**
 *	*.txt - файл с исходной текстовой информацией.
 *	*.cms - файл с подписью PKCS7 (DETACHED/ATTACHED).
 *	*.env - файл с зашифрованной подписью PKCS7 (ENVELOPED).
 *	client_exch - сертификат отправителя.
 *	afevma_gost_exch_server - сертификат получателя.
 *	Формирование PKCS7 DETACHED:
 *		csptest -cmssfsign -sign -in "in.txt" -my client_exch -add -detached -signature "out.cms"
 *	Проверка PKCS7 CMS DETACHED:
 *		csptest -cmssfsign -verify -in "in.txt" -my client_exch -add -detached -signature "out.cms"
 *	Формирование PKCS7 CMS ATTACHED:
 *		csptest -cmssfsign -sign -in "in.txt" -my client_exch -add -signature "out.cms"
 *	Проверка PKCS&amp; CMS ATTACHED:
 *		csptest -cmssfsign -verify -in "out.cms" -my client_exch -add
 *	Зашифрование PKCS7 CMS DETACHED/ATTACHED:
 *		csptest -sfenc -encrypt -out "in.cms" -in "pkcs7.env" -cert client_exch -my afevma_gost_exch_server
 *	Расшифрование PKCS7 CMS DETACHED/ATTACHED:
 *		csptest -sfenc -decrypt -out "out.cms" -in "pkcs7.env" -cert afevma_gost_exch_server -my client_exch
 *	Подпись и зашифование PKCS7 CMS ATTACHED:
 *		csptest -sfse -encrypt -in "in.txt" -out "pkcs7.env" -senderDN client_exch -recipDN afevma_gost_exch_server
 *	Проверка и расшифрование PKCS7 CMS ATTACHED:
 *		csptest -sfse -decrypt -in "pkcs7.env" -out "out.txt" -senderDN client_exch -recipDN afevma_gost_exch_server
 */

public class PKCS7Env {

	/**
	 * Вектор усложнения ключа согласования.
	 */
	private static final byte[] sv = {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
	
	/**
	 * Алиас отправителя.
	 */
	private final static String SENDER_ALIAS = "client_exch";
	
	/**
	 * Пароль к контейнеру отправителя (при зашифровании).
	 */
	private final static char[] SENDER_PASSWORD = "Pass1234".toCharArray();
	
	/**
	 * Алиас получателя.
	 */
	private final static String RECIPIENT_ALIAS = "afevma_gost_exch_server";
	
	/**
	 * Пароль к контейнеру получателя (при расшифровании).
	 */
	private final static char[] RECIPIENT_PASSWORD = "security".toCharArray();
	
	/**
	 * Папка с файлами.
	 */
	private final static String TEST_DIR = "C:\\Temp\\pkcs7\\";
	
	/**
	 * Загрузка контейнеров.
	 * @return указатель на загруженные контейнеры.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws IOException
	 */
	public static KeyStore loadKeyStore() throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, IOException {
		
		KeyStore keyStore = KeyStore.getInstance(CMStools.STORE_TYPE);
		keyStore.load(null, null);
		return keyStore;
	}
	
	/**
	 * Зашифрование PKCS7 (Enveloped).
	 * @param keyStore - контейнер для чтения ключей и сертификатов.
	 * @param senderAlias - алиас отправителя.
	 * @param senderPassword - пароль отправителя.
	 * @param recipientAlias - алиас получателя (сертификат).
	 * @param pkcs7 - сообщение PKCS7.
	 * @return зашифрованное PKCS7 Enveloped.
	 * @throws UnrecoverableKeyException
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws InvalidAlgorithmParameterException
	 * @throws NoSuchPaddingException
	 * @throws IllegalBlockSizeException
	 * @throws BadPaddingException
	 * @throws Asn1Exception
	 * @throws IOException
	 */
	public static byte[] EncryptPKCS7(KeyStore keyStore, String senderAlias, char[] senderPassword, 
			String recipientAlias, byte[] pkcs7) throws UnrecoverableKeyException, 
	KeyStoreException, NoSuchAlgorithmException, InvalidKeyException, InvalidAlgorithmParameterException, 
	NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, Asn1Exception, IOException {
		
		byte[] pkcs7Env = null;
		
		final PrivateKey senderKey = (PrivateKey) keyStore.getKey(senderAlias, senderPassword);
		final X509Certificate publicSenderCert = (X509Certificate) keyStore.getCertificate(senderAlias);
		final X509Certificate recipientCert = (X509Certificate) keyStore.getCertificate(recipientAlias);
		final PublicKey recipientPublic = recipientCert.getPublicKey();
	    
		// Выработка ключа согласования отправителем
		final KeyAgreement senderKeyAgree = KeyAgreement.getInstance(CMStools.KEY_ALG_NAME);
		senderKeyAgree.init(senderKey, new IvParameterSpec(sv), null);
		senderKeyAgree.doPhase(recipientPublic, true);
		final SecretKey alisaSecret = senderKeyAgree.generateSecret(CMStools.SEC_KEY_ALG_NAME);
		
		// Генерирование симметричного ключа с параметрами шифрования из контрольной панели.
		final KeyGenerator kg = KeyGenerator.getInstance(CMStools.SEC_KEY_ALG_NAME);
		final ParamsInterface paramss = AlgIdSpec.getDefaultCryptParams();
		kg.init(paramss);
		final SecretKey simm = kg.generateKey();
	    
		// Зашифрование текста на симметричном ключе.
		final Cipher cipher = Cipher.getInstance("GOST28147/CFB/NoPadding");
		cipher.init(Cipher.ENCRYPT_MODE, simm, (SecureRandom) null);
		final byte[] iv = cipher.getIV();
		final byte[] text = cipher.doFinal(pkcs7, 0, pkcs7.length);
	    
		// Зашифрование симметричного ключа на ключе согласования отправителя
		cipher.init(Cipher.WRAP_MODE, alisaSecret, (SecureRandom) null);
		final byte[] key = cipher.wrap(simm);

		// Формирование CMS-сообщения
		final ContentInfo all = new ContentInfo();
		all.contentType = new Asn1ObjectIdentifier(new OID(CMStools.STR_CMS_OID_ENVELOPED).value);
		final EnvelopedData cms = new EnvelopedData();
		all.content = cms;

		cms.version = new CMSVersion(0);

		cms.recipientInfos = new RecipientInfos(1);
		cms.recipientInfos.elements = new RecipientInfo[1];
		cms.recipientInfos.elements[0] = new RecipientInfo();

		final KeyTransRecipientInfo keytrans = new KeyTransRecipientInfo();
		keytrans.version = new CMSVersion(0);

		final Asn1BerEncodeBuffer ebuf = new Asn1BerEncodeBuffer();
		final SubjectPublicKeyInfo spki = new SubjectPublicKeyInfo();
		final Asn1BerDecodeBuffer dbuff = new Asn1BerDecodeBuffer(publicSenderCert.getPublicKey().getEncoded());
		spki.decode(dbuff);
		dbuff.reset();
	    
		final AlgIdInterface algid = new AlgIdSpec(spki.algorithm);
		final AlgorithmIdentifier id = (AlgorithmIdentifier) algid.getDecoded();
		id.encode(ebuf);
	    
		Asn1BerDecodeBuffer dbuf = new Asn1BerDecodeBuffer(ebuf.getMsgCopy());
		keytrans.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
		keytrans.keyEncryptionAlgorithm.decode(dbuf);
		ebuf.reset();
		dbuf.reset();
	    
		keytrans.rid = new RecipientIdentifier();
		final IssuerAndSerialNumber issuer = new IssuerAndSerialNumber();
		final X500Principal issuerName = recipientCert.getIssuerX500Principal();
		dbuf = new Asn1BerDecodeBuffer(issuerName.getEncoded());
	    
		issuer.issuer = new Name();
		final RDNSequence rnd = new RDNSequence();
		rnd.decode(dbuf);
	    
		issuer.issuer.set_rdnSequence(rnd);
		issuer.serialNumber = new CertificateSerialNumber(recipientCert.getSerialNumber());
		keytrans.rid.set_issuerAndSerialNumber(issuer);
		dbuf.reset();
	    
		final GostR3410_KeyTransport encrKey = new GostR3410_KeyTransport();
		dbuf = new Asn1BerDecodeBuffer(key);
		encrKey.sessionEncryptedKey = new Gost28147_89_EncryptedKey();
		encrKey.sessionEncryptedKey.decode(dbuf);
		dbuf.reset();
	    
		encrKey.transportParameters = new GostR3410_TransportParameters();
		encrKey.transportParameters.encryptionParamSet = new Gost28147_89_ParamSet(algid.getCryptParams().getOID().value);
		encrKey.transportParameters.ephemeralPublicKey = new SubjectPublicKeyInfo();
		dbuf = new Asn1BerDecodeBuffer(publicSenderCert.getPublicKey().getEncoded());
		encrKey.transportParameters.ephemeralPublicKey.decode(dbuf);
		dbuf.reset();
	    
		encrKey.transportParameters.ukm = new Asn1OctetString(sv);
		encrKey.encode(ebuf);
	    
		keytrans.encryptedKey = new EncryptedKey(ebuf.getMsgCopy());
		ebuf.reset();
	    
		cms.recipientInfos.elements[0].set_ktri(keytrans);

		cms.encryptedContentInfo = new EncryptedContentInfo();
		final OID contentType = new OID(CMStools.STR_CMS_OID_DATA);
		cms.encryptedContentInfo.contentType = new ContentType(contentType.value);
		final Gost28147_89_Parameters params = new Gost28147_89_Parameters();
		params.iv = new Gost28147_89_IV(iv);
		params.encryptionParamSet = new Gost28147_89_ParamSet(paramss.getOID().value);
		cms.encryptedContentInfo.contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier(
	                    _Gost28147_89_EncryptionSyntaxValues.id_Gost28147_89, params);
		cms.encryptedContentInfo.encryptedContent = new EncryptedContent(text);

		all.encode(ebuf);
		pkcs7Env = ebuf.getMsgCopy();
	    
		return pkcs7Env;
	}
		
	/**
	 * Расшифрование PKCS7 Enveloped.
	 * @param keyStore -  контейнер для чтения ключей и сертификатов.
	 * @param recipientAlias - алиас получателя.
	 * @param recipientPassword - пароль получателя.
	 * @param senderAlias - алиас отправителя (сертификат).
	 * @param pkcs7Env - зашифрованное PKCS7 Enveloped.
	 * @param inData - исходные данные. Нужны при проверке detached подписи.
	 * @param detached - флаг detached подписи.
	 * @param textFile - файл с расшифрованными данными (если подпись attached).
	 * @return результат проверки.
	 * @throws Asn1Exception
	 * @throws IOException
	 * @throws KeyStoreException
	 * @throws UnrecoverableKeyException
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 * @throws InvalidKeyException
	 * @throws InvalidAlgorithmParameterException
	 * @throws NoSuchPaddingException
	 * @throws IllegalBlockSizeException
	 * @throws BadPaddingException
	 */
	public static boolean DecryptPKCS7(KeyStore keyStore, String recipientAlias, char[] recipientPassword, 
			String senderAlias, byte[] pkcs7Env, byte[] inData, boolean detached, String outDataFile) throws Asn1Exception, 
			IOException, KeyStoreException, UnrecoverableKeyException, 
			NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, 
			InvalidAlgorithmParameterException, NoSuchPaddingException, IllegalBlockSizeException, 
			BadPaddingException {
		
		boolean verified = false;
		
		// Разбор CMS-сообщения
		Asn1BerDecodeBuffer dbuf = new Asn1BerDecodeBuffer(pkcs7Env);
		final ContentInfo all = new ContentInfo();
		all.decode(dbuf);
		dbuf.reset();
		
		final EnvelopedData cms = (EnvelopedData) all.content;

		KeyTransRecipientInfo keytrans = new KeyTransRecipientInfo();
		if (cms.recipientInfos.elements[0].getChoiceID() == RecipientInfo._KTRI)
	        keytrans = (KeyTransRecipientInfo) (cms.recipientInfos.elements[0].getElement());
		
		final Asn1BerEncodeBuffer ebuf = new Asn1BerEncodeBuffer();
		dbuf = new Asn1BerDecodeBuffer(keytrans.encryptedKey.value);
		final GostR3410_KeyTransport encrKey = new GostR3410_KeyTransport();
		encrKey.decode(dbuf);
		dbuf.reset();
		
		encrKey.sessionEncryptedKey.encode(ebuf);
		final byte[] wrapKey = ebuf.getMsgCopy();
		ebuf.reset();
		
		encrKey.transportParameters.ephemeralPublicKey.encode(ebuf);
		final byte[] encodedPub = ebuf.getMsgCopy();
		ebuf.reset();
		
		final byte[] sv = encrKey.transportParameters.ukm.value;
		final Gost28147_89_Parameters params = (Gost28147_89_Parameters) cms.encryptedContentInfo.contentEncryptionAlgorithm.parameters;
		final byte[] iv = params.iv.value;
		final OID cipherOID = new OID(params.encryptionParamSet.value);
		final byte[] text = cms.encryptedContentInfo.encryptedContent.value;

		// Получатель - закрытый ключ
		final PrivateKey recipientKey = (PrivateKey) keyStore.getKey(recipientAlias, recipientPassword);

		// Отправитель - открытый ключ из cms
		final X509EncodedKeySpec pspec = new X509EncodedKeySpec(encodedPub);
		final KeyFactory kf = KeyFactory.getInstance(CMStools.KEY_ALG_NAME);
		final PublicKey senderPublic = kf.generatePublic(pspec);

		// Выработка ключа согласования получателем
		final KeyAgreement recipientKeyAgree = KeyAgreement.getInstance(CMStools.KEY_ALG_NAME);
		recipientKeyAgree.init(recipientKey, new IvParameterSpec(sv), null);
		recipientKeyAgree.doPhase(senderPublic, true);
		final SecretKey alisaSecret = recipientKeyAgree.generateSecret(CMStools.SEC_KEY_ALG_NAME);

		// Расшифрование симметричного ключа.
		final Cipher cipher = Cipher.getInstance("GOST28147/CFB/NoPadding");
		cipher.init(Cipher.UNWRAP_MODE, alisaSecret, (SecureRandom) null);
		final SecretKey simmKey = (SecretKey) cipher.unwrap(wrapKey, null, Cipher.SECRET_KEY);

		// Расшифрование текста на симметричном ключе.
		final GostCipherSpec spec = new GostCipherSpec(iv, cipherOID);
		cipher.init(Cipher.DECRYPT_MODE, simmKey, spec, null);
		final byte[] result = cipher.doFinal(text, 0, text.length);
	    
		// Проверка подписи PKCS7.
		try {
			
			CMSVerify.CMSVerify(result, null, detached ? inData : null);
			verified = true;

			// Извлечение текста, если он есть (для attached).
			final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(result);
			final ContentInfo cInfo = new ContentInfo();
			cInfo.decode(asnBuf);
			final SignedData pkcs7 = (SignedData) cInfo.content;
		               
			// Сохранение текста в файл (для attached).
			if (pkcs7.encapContentInfo.eContent != null) {
				byte[] data = pkcs7.encapContentInfo.eContent.value;
				Array.writeFile(outDataFile, data);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return verified;
	}
	
	/**
	 * @param args
	 * @throws Exception 
	 */
	public static void main(String[] args) throws Exception {
			
		// Внимание! Для зашифрования/расшифрования нужна PKCS7 подпись. Ее можно
		// сформировать с помощью примера CMS или csptest (см. начало файла).
		
		KeyStore keyStore = loadKeyStore();
		final boolean detached = false;
		// Данные для attached подписи. Нужны, если detached = true.
		final byte[] data = Array.readFile(TEST_DIR + "in.txt");
		// Файл с PKCS7.
		final byte[] pkcs7Data = Array.readFile(TEST_DIR + "in_a.cms");
				
		// Зашифрование PKCS7.
		byte[] pkcs7Env =  EncryptPKCS7(keyStore, SENDER_ALIAS, SENDER_PASSWORD, 
				RECIPIENT_ALIAS, pkcs7Data );

        Array.writeFile(TEST_DIR + "env.cms", pkcs7Env);
		
		// Расшифрование и проверка подписи.
		System.out.println( "Verified: " + DecryptPKCS7(keyStore, RECIPIENT_ALIAS, RECIPIENT_PASSWORD, 
				SENDER_ALIAS, pkcs7Env, data, detached, TEST_DIR + "out.txt" ) );
	}
}
</java>
<java name="ComLine/Certs.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 28.06.2007 14:49:57 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Построение цепочки сертификатов
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Certs {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 * forbidden
 */
private Certs() {
}

/**
 * Certs -alias name_of_key [-storetype HDImageStore] [-storepath null]
 * [-storepass null] [-keypass password] -certs C:/my.cer,C:/*.cer,...,C:/root.cer
 * &lt;p/&gt;
 * &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -alias &lt;/b&gt;  &lt;DD&gt;уникальное имя ключа&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -keypass &lt;/b&gt;
 * &lt;DD&gt;пароль на ключ &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storetype &lt;/b&gt;
 * &lt;DD&gt;имя ключевого носителя HDImageStore (жесткий диск), FloppyStore
 * (дискета), OCFStore или J6CFStore (карточки) &lt;DD&gt;(по умолчанию
 * HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;-storepath &lt;/b&gt; &lt;DD&gt;путь к хранилищу доверенных
 * сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storepass &lt;/b&gt; &lt;DD&gt;пароль
 * на хранилище доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -сerts&lt;/b&gt; &lt;DD&gt;пути к сертификатам&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args аргументы командной строки
 */
public static void main(String[] args) {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.CertsHelpHD);
    else
        try {
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties();
            //уникальное имя ключа
            ArgList.setProperty(ComLine.ALIAS,
                    ComLine.getValue(ComLine.ALIAS, args, null));
            //пароль на записываемый ключ
            ArgList.setProperty(ComLine.keypass,
                    ComLine.getValue(ComLine.keypass, args, "null"));
            //тип ключевого носителя
            ArgList.setProperty(ComLine.storetype,
                    ComLine.getValue(ComLine.storetype, args,
                            ComLine.HDImageStore));
            //путь к хранилищу доверенных сертификатов
            ArgList.setProperty(ComLine.storepath,
                    ComLine.getValue(ComLine.storepath, args, "null"));
            //пароль на хранилище доверенных сертификатов
            ArgList.setProperty(ComLine.storepass,
                    ComLine.getValue(ComLine.storepass, args, "null"));
            //пути к сертификатам
            ArgList.setProperty(ComLine.certs,
                    ComLine.getValue(ComLine.certs, args, null));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.storetype);
            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else {
                ArgList.setProperty(ComLine.storetype, ComLine.HDImageStore);
                log.info("Incorrect keystore type: " + ks +
                        ". Value by default is appropriated: " + ComLine
                        .HDImageStore);
            }

            //Построение цепочки сертификатов и ее запись к ключу
            Certs(
                    ArgList.getProperty(ComLine.ALIAS),
                    ArgList.getProperty(ComLine.keypass),
                    ArgList.getProperty(ComLine.storetype),
                    ArgList.getProperty(ComLine.storepass),
                    ArgList.getProperty(ComLine.storepath),
                    ArgList.getProperty(ComLine.certs));

        } catch (NullPointerException e) {
            //System.out.println(e.toString());
            log.info(ComLine.CertsHelpHD);
        } catch (ArrayIndexOutOfBoundsException ae) {
            log
                    .info("\nWrong input in command line (" + ComLine.certs +
                            ")\n\n" + ComLine.CertsHelpHD);
        } catch (Exception e1) {
            final String sss = "java.lang.Exception:";
            log.info("\n" +
                    e1.toString()
                            .substring(sss.length(), e1.toString().length()) +
                    "\n" + ComLine.CertsHelpHD);
        }

}

/**
 * @param alias имя ключа
 * @param keypass пароль на ключ
 * @param keystoreName тип ключевого носителя
 * @param keystorePass пароль на хранилище доверенных сертификатов
 * @param keystorePath путь к хранилищу доверенных сертификатов
 * @param certs пути к сертификатам
 * @throws Exception ...
 */
private static void Certs(String alias,
                          String keypass,
                          String keystoreName,
                          String keystorePass,
                          String keystorePath,
                          String certs) throws Exception {

    //Чтение сертификатов
    final String[] certnames = certs.split(",");
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    final Certificate[] Certificates = new Certificate[certnames.length];
    for (int i = 0; i &lt; certnames.length; i++) {
        Certificates[i] =
                cf.generateCertificate(new FileInputStream(certnames[i]));
    }

    //запись в хранилище ключевой пары и сертификатов
    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);
    final PrivateKey key;
    char[] Keypass = null;
    if (!"null".equalsIgnoreCase(keypass)) {
        Keypass = keypass.toCharArray();
    }
    key = (PrivateKey) ks.getKey(alias, Keypass);
    ks.setKeyEntry(alias, key, Keypass, Certificates);
    OutputStream os = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        os = new FileOutputStream(keystorePath);
    }
    ks.store(os, KeyStorePass);
    log.info(
            "Recording of certificates to " + keystoreName +
                    " is completed.");

}
}
</java>
<java name="ComLine/CheckConf.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 04.07.2007 14:31:39 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.Security;
import java.util.logging.Logger;

/**
 * Проверка установки и настроек провайдеров.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CheckConf {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 *
 */
private CheckConf() {
}

/**
 * CheckConf (без параметров)
 *
 * @param args без параметров
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    if (ComLine.getFunc(ComLine.hllp, args))
        log.info(ComLine.HCheckConf + "   (without parameters)");
    else
        check();
}

/**
 * Проверка установки компонентов
 *
 * @throws Exception ошибки
 */
private static void check() throws Exception {
    //Проверка правильности установки провайдеров
    final Provider[] provs = Security.getProviders();
    int flag_jcp = 0;
    int flag_crypto = 0;
    int flag_jtls = 0;
    String s = "";
    for (int i = 0; i &lt; provs.length; i++) {
        //System.out.println(provs[i].getName());
        if ("JCP".equals(provs[i].getName()))
            flag_jcp = 1;
        if ("Crypto".equals(provs[i].getName()))
            flag_crypto |= 1;
        if ("JTLS".equals(provs[i].getName()))
            flag_jtls |= 1;
    }
    if (flag_jcp != 1) s = s + "Провайдер не установлен.\n";
    if (flag_crypto != 1) s = s + "Провайдер Crypto не установлен\n";
    if (flag_jtls != 1) s = s + "Провайдер JTLS не установлен\n";
    if (s.length() &gt; 0) log.info(s + "\n\nПроверка настроек:\n");
    else log.info(
            "Провайдеры JCP,Crypto,JTLS установлены\n\nПроверка настроек:\n");
    // проверка правильности работы JCP
    final String[] sout = new String[3];
    int i = 0;
    try {
        final java.security.Signature sig =
                java.security.Signature.getInstance("GOST3411withGOST3410EL");
        sout[i] = "Провайдер JCP настроен верно";
        i++;
    } catch (NoSuchAlgorithmException e) {
        sout[i] = "Провайдер JCP не установлен.";
        i++;
    }
    // проверка правильности работы Crypto
    try {
        final KeyPairGenerator keyGen =
                KeyPairGenerator.getInstance("GOST3410DHEPH");
        sout[i] = "Провайдер Crypto настроен верно";
        i++;
    } catch (NoSuchAlgorithmException e) {
        sout[i] = "Провайдер Crypto не установлен.";
        i++;
    }
    // проверка правильности настроек TLS
    int j = 0;
    String[] sout1 = new String[4];
    final String factoryProvider =
            Security.getProperty("ssl.SocketFactory.provider");
    if (factoryProvider == null ||
            !factoryProvider.equals("ru.CryptoPro.ssl.SSLSocketFactoryImpl")) {
        sout1[j] =
                "Неверное значение ssl.SocketFactory.provider в java.security";
        j++;
    }
    final String serverProvider = Security
            .getProperty("ssl.ServerSocketFactory.provider");
    if (serverProvider == null || !serverProvider
            .equals("ru.CryptoPro.ssl.SSLServerSocketFactoryImpl")) {
        sout1[j] =
                "Неверное значение ssl.ServerSocketFactory.provider в java.security";
        j++;
    }
    final String keyManager = Security
            .getProperty("ssl.KeyManagerFactory.algorithm");
    if (keyManager == null || !keyManager.equals("GostX509")) {
        sout1[j] =
                "Неверное значение ssl.KeyManagerFactory.algorithm в java.security";
        j++;
    }
    final String trust = Security
            .getProperty("ssl.TrustManagerFactory.algorithm");
    if (trust == null || !trust.equals("GostX509")) {
        sout1[j] =
                "Неверное значение ssl.TrustManagerFactory.algorithm в java.security";
        j++;
    }

    final int jmax = j - 1;
    if (j == 0) {
        sout[i] = "Провайдер JTLS настроен верно";
        i++;
    } else {
        String ss = "";
        for (int jj = 0; jj &lt;= jmax; jj++) {
            ss = ss + "\n" + sout1[jj];
        }
        sout[i] = "Провайдер JTLS настроен неверно:" + ss;
        i++;
    }


    final int imax = i - 1;
    String Sout = "\n" + sout[0];
    for (i = 1; i &lt;= imax; i++) {
        Sout = Sout + "\n" + sout[i];
    }
    log.info(Sout + "\n");
}
}
</java>
<java name="ComLine/CheckConfFull.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 30.09.2008 10:37:34 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import JTLS_samples.Client;
import JTLS_samples.Server;
import ru.CryptoPro.JCP.tools.Array;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Security;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Проверка работы провайдера.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CheckConfFull {

private static boolean f_jcp = false;
private static boolean f_crypto = false;
private static boolean f_jtls = false;
private static Logger log = Logger.getLogger("Log");
private static String signKey = "jcptestsignkey";
private static String kpAlg = "GOST3410";
private static String kpAlgDH = "GOST3410DH";
private static String ksName = "HDImageStore";
private static char[] keyPass = null;
private static char[] keyPass_1 = "jcptest".toCharArray();
private static String dNameCN = "CN=";
private static String dNameE = ",OU=Security,O=CryptoPro,C=RU";
private static String signAlg = "GOST3411withGOST3410EL";
private static String dhKey = "jcptestcryptokey";
private static int sslPort = 1212;
private static String serverKey = "jcptestserverkey";
private static String clientKey = "jcptestclientkey";
private static String truststore = "jcptesttrust.store";
private static String keystore = "jcptestkey.store";
private static String in = "jcptestdoc.in";
private static String out = "jcptestdoc.out";
private static String out_a = "jcptestdoc_a.out";
private static String doc;
private static String get_doc;
private static String get_doc_a;
private static String trustSt;
private static String keySt;
private static String serverKeyCert = serverKey + "cert";
private static String clientKeyCert = clientKey + "cert";

 /**/
private CheckConfFull() {
}

/**
 * CheckConfFull [-servDir C:/*.*]
 * &lt;p/&gt;
 * &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -servDir &lt;/b&gt;  &lt;DD&gt;рабочая директория&lt;DD&gt;(по умолчанию
 * текущая)&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args аргументы командной строки
 * @throws IOException /
 */
public static void main(String[] args) throws IOException {
    if (ComLine.getFunc(ComLine.hllp, args))
        log.info(ComLine.CheckConfFullHelp);
    else {
        checkProvs();
        if (f_jcp) {
            if (checkJCP()) log.info("\nJCP - OK\n");
            else log.warning("\nJCP - FAIL\n");
            if (f_crypto) {
                if (checkCrypto()) log.info("\nCrypto - OK\n");
                else log.warning("\nCrypto - FAIL\n");
                if (f_jtls) {
                    final Properties ArgList = new Properties();
                    //server working dir
                    ArgList.setProperty(ComLine.servDir,
                            ComLine.getValue(ComLine.servDir,
                                    args, new File(".").getCanonicalPath()));

                    if (checkJTLS(ArgList)) log.info("\nJTLS - OK\n");
                    else log.warning("\nJTLS - FAIL\n");
                }
            }
        }
    }
}

/**
 * Проверка установки провайдеров
 */
private static void checkProvs() {
    final Provider[] provs = Security.getProviders();
    for (int i = 0; i &lt; provs.length; i++) {
        if ("JCP".equals(provs[i].getName()))
            f_jcp = true;
        if ("Crypto".equals(provs[i].getName()))
            f_crypto = true;
        if ("JTLS".equals(provs[i].getName()))
            f_jtls = true;
    }
    if (!f_jcp) log.info("Provider JCP not installed.");
    if (!f_crypto) log.info("Provider Crypto not installed.");
    if (!f_jtls) log.info("Provider JTLS  not installed.");
}

 /**/
private static boolean checkJCP() {
    boolean ok = true;
    try {
        log.info("***Check JCP key pair generation and writing to store");
        final String dName = dNameCN + signKey + dNameE;
        if (keyGen(signKey, kpAlg, keyPass, dName, false)) log.info(
                "***Check JCP key pair generation and writing to store - OK");
    } catch (Exception e) {
        ok = false;
        e.printStackTrace();
    }
    try {
        log.info("***Check JCP signature generation|verifycation");
        if (signVer(signKey, keyPass))
            log.info("***JCP signature generation|verifycation - OK");
    } catch (Exception e) {
        ok = false;
        e.printStackTrace();
    }
    return ok;
}

 /**/
private static boolean checkCrypto() {
    boolean ok = true;
    try {
        log.info("***Check Crypto key pair generation and writing to store");
        final String dName = dNameCN + dhKey + dNameE;
        if (keyGen(dhKey, kpAlgDH, keyPass, dName, false)) log.info(
                "***Check Crypto key pair generation and writing to store - OK");
    } catch (Exception e) {
        ok = false;
        e.printStackTrace();
    }
    return ok;
}

 /**/
private static boolean checkJTLS(Properties argList) {
    boolean ok = true;
    try {
        log.info("***Prepare keys");
        String dName = dNameCN + serverKey + dNameE;
        keyGen(serverKey, kpAlgDH, keyPass_1, dName, true);
        dName = dNameCN + clientKey + dNameE;
        keyGen(clientKey, kpAlgDH, keyPass_1, dName, false);
        log.info("***Prepare files");
        final String dir = argList.getProperty(ComLine.servDir);
        doc = dir + File.separator + in;
        get_doc = dir + File.separator + out;
        get_doc_a = dir + File.separator + out_a;
        Array.writeFile(doc, "12345".getBytes());
        if (!new File(doc).exists())
            throw new Exception("Can't create file for test");
        log.info("***Prepare TrustStore");
        
        keySt = dir + File.separator + keystore;
        createTrustStore(keySt, serverKey, serverKeyCert);
        
        trustSt = dir + File.separator + truststore;
        createTrustStore(trustSt, clientKey, clientKeyCert);
        
        log.info("***Test ssl without autentification of client");
        tls(false, dir, get_doc);
        log.info("***Test ssl with autentification of client");
        tls(true, dir, get_doc_a);

    } catch (Exception e) {
        ok = false;
        e.printStackTrace();
    }

    return ok;
}

/**
 * Создание хранилища доверенных сертификатов
 */
private static void createTrustStore(String stPath, String alias, String tAlias)
        throws Exception {
    //загрузка сертификата из контейнера
    final KeyStore ks = KeyStore.getInstance(ksName);
    ks.load(null, null);
    final Certificate cert = ks.getCertificate(alias);
    if (cert == null)
        throw new Exception("Certificate named \"" + alias + "\" not found");
    log.info("Loading of a certificate is completed");
    ks.setCertificateEntry(tAlias, cert);
    ks.store(new FileOutputStream(stPath), keyPass_1);


}

/**
 * TLS соединение
 */
private static boolean tls(boolean isAuth, String dir, String outPath)
        throws Exception {
    boolean ok = true;
    Server server = null;
    try {
        //Настройки для сервера
        System.setProperty("javax.net.ssl.keyStoreType", ksName);
        System.setProperty("javax.net.ssl.keyStorePassword",
                new String(keyPass_1));
        
        //настройки для клиента
        System.setProperty("javax.net.ssl.trustStoreType", ksName);
        System.setProperty("javax.net.ssl.trustStore", trustSt);
        System.setProperty("javax.net.ssl.trustStorePassword",
                new String(keyPass_1));

        server = new Server(sslPort, isAuth, dir);
        server.setTimeout(100000);
        server.start();

        final Client client = new Client("localhost", sslPort);
        client.setTimeout(100000);

        if (!server.isAlive())
            throw new Exception("server not running");
        else log.info("server started");

        client.get(in, outPath, dir);

        if (!server.isAlive())
            throw new Exception("server not alive after client Get");
        else log.info("GET complete");

    } catch (Exception e) {
        ok = false;
        e.printStackTrace();
    } finally {
        if (server == null) {
            ok = false;
            throw new Exception("server not running at the test");
        }
        server.stop();
        Thread.sleep(100);
    }
    return ok;
}

/**
 * Генерирование ключевой пары и запись в хранилище
 */
private static boolean keyGen(String alias, String keypairAlgorithm,
                              char[] keypass, String name,
                              boolean isServer)
        throws Exception {
    //генерирование ключевой пары
    final KeyPairGenerator kg =
            KeyPairGenerator.getInstance(keypairAlgorithm);
    final KeyPair pair = kg.generateKeyPair();
    log.info("Generation of key pair is completed (" + keypairAlgorithm + ")");
    //Запрос на сертификат
    final GostCertificateRequest req;
    req = new GostCertificateRequest();
    req.init(keypairAlgorithm, isServer);
    final byte[] encodedCert = req.getEncodedSelfCert(pair, name);

    //генерирование самоподписанного сертификата
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    final Certificate[] certs;
    certs = new Certificate[1];
    certs[0] =
            cf.generateCertificate(new ByteArrayInputStream(encodedCert));
    log.info("Generation of certificate is completed"); /**/

    //запись в хранилище ключевой пары с самоподписанным сертификатом
    final KeyStore ks = KeyStore.getInstance(ksName);
    ks.load(null, null);
    final PrivateKey key;
    key = pair.getPrivate();
    ks.setKeyEntry(alias, key, keypass, certs);
    ks.store(null, null);
    log.info("Recording of a private key named \"" + alias + "\" to " +
            ksName + " is completed.");
    return true;
}

/**
 * Создание и проверка подписи
 */
private static boolean signVer(String alias, char[] keypass) throws Exception {
    //загрузка ключа из хранилища HDImageStore
    final KeyStore ks = KeyStore.getInstance(ksName);
    ks.load(null, null);
    final PrivateKey privateKey;
    privateKey = (PrivateKey) ks.getKey(alias, keypass);
    if (privateKey == null)
        throw new Exception("Key named \"" + alias + "\" not found");
    log.info("Loading of a private key is completed");

    //текст
    final byte[] text = "sample".getBytes();
    log.info("Loading of a text is completed");

    //генерирование ЭЦП
    final java.security.Signature sig;
    sig = java.security.Signature.getInstance(signAlg);
    sig.initSign(privateKey);
    sig.update(text);

    //подпись
    final byte[] signature = sig.sign();
    Logger.getLogger("LOGGER").info("Generation of the signature is completed");

    //загрузка открытого ключа из хранилища HDImageStore
    ks.load(null, null);
    final Certificate cert = ks.getCertificate(alias);
    final PublicKey publicKey;
    publicKey = cert.getPublicKey();
    if (publicKey == null)
        throw new Exception("Key named \"" + alias + "\" not found");
    log.info("Loading of a public key is completed");

    //проверка подписи
    final java.security.Signature sign;
    sign = java.security.Signature.getInstance(signAlg);
    sign.initVerify(publicKey);
    sign.update(text);
    final boolean verifies;
    verifies = sign.verify(signature);
    final String s;
    if (verifies) s = "The signature is true";
    else s = "The signature is not true";
    log.info(s);
    return verifies;
}
}
</java>
<java name="ComLine/Client.java">package ComLine;

import java.io.IOException;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Пример запуска клиента из командной строки (см. JTLS_samples.Client).
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Client {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

 /**/
private Client() {
}

/**
 * Client [-port port] [-server serverName] [-keyStoreType HDImageStore]
 * [-trustStoreType HDImageStore] -trustStorePath C:/*.* -trustStorePassword
 * trust_pass -keyStorePassword key_pass [-fileget gettingFileName] [-fileout
 * outputFilePath]
 * &lt;p/&gt;
 * &lt;/DD&gt; &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -port &lt;/b&gt;  &lt;DD&gt;порт сервера &lt;DD&gt;(по умолчанию 443)&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -server &lt;/b&gt; &lt;DD&gt;имя сервера &lt;DD&gt;(по умолчанию localhost)&lt;br&gt; &lt;DT&gt;&lt;b&gt;
 * -keyStoreType &lt;/b&gt; &lt;DD&gt;тип ключевого носителя HDImageStore (жесткий диск),
 * FloppyStore (дискета), OCFStore или J6CFStore (карточки) &lt;DD&gt;(по умолчанию
 * HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -trustStoreType &lt;/b&gt; &lt;DD&gt;тип носителя для
 * хранилища доверенных сертификатов HDImageStore (жесткий диск), FloppyStore
 * (дискета) &lt;DD&gt;(по умолчанию HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -trustStorePath &lt;/b&gt;
 * &lt;DD&gt;путь к хранилищу доверенных сертификатов&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -trustStorePassword
 * &lt;/b&gt; &lt;DD&gt;пароль на хранилище доверенных сертификатов&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -keyStorePassword &lt;/b&gt;  &lt;DD&gt;пароль на ключ&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -fileget&lt;/b&gt;  &lt;DD&gt;имя
 * ресурса &lt;DD&gt;(по умолчанию index.html)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -fileout &lt;/b&gt; &lt;DD&gt;путь к
 * файлу вывода &lt;DD&gt;(по умолчанию out.html)&lt;br&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args аргументы командной строки
 * @throws IOException ошибки ввода-вывода
 */
public static void main(String[] args) throws IOException {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.HELP_ClIENT);
    else
        try {
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties(); 

            //порт
            ArgList.setProperty(ComLine.PORT,
                    ComLine.getValue(ComLine.PORT, args, "443"));
            //хост
            ArgList.setProperty(ComLine.SERVER, ComLine.getValue(
                    ComLine.SERVER, args, "localhost"));
            //keyStoreType
            ArgList.setProperty(ComLine.keyStoreType,
                    ComLine.getValue(ComLine.keyStoreType, args,
                            ComLine.HDImageStore));
            //trustStoreType
            ArgList.setProperty(ComLine.trustStoreType,
                    ComLine.getValue(ComLine.trustStoreType, args,
                            ComLine.HDImageStore));
            //trustStorePath
            ArgList.setProperty(ComLine.trustStorePath,
                    ComLine.getValue(ComLine.trustStorePath, args, null));
            //keyStorePassword
            ArgList.setProperty(ComLine.keyStorePassword,
                    ComLine.getValue(ComLine.keyStorePassword, args, "null"));
            //trustStorePassword
            ArgList.setProperty(ComLine.trustStorePassword,
                    ComLine.getValue(ComLine.trustStorePassword, args, null));
            //Get file (filename)
            ArgList.setProperty(ComLine.fileget, ComLine.getValue(
                    ComLine.fileget, args, "index.html"));
            //file for output (fileout path)
            ArgList.setProperty(ComLine.fileout, ComLine.getValue(
                    ComLine.fileout, args, "out.html"));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.keyStoreType);

            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.NO_STORE)) {
            } else {
                ArgList.setProperty(ComLine.keyStoreType, ComLine.HDImageStore);
                log.info("Incorrect keystore type: " + ks +
                        ". Value by default is appropriated: " + ComLine
                        .HDImageStore);
            }

            System.setProperty("javax.net.ssl.keyStorePassword", "Pass1234");
            
            if (!"null"
                    .equalsIgnoreCase(
                            ArgList.getProperty(ComLine.keyStorePassword))) {
                final String keyStpass =
                        ArgList.getProperty(ComLine.keyStorePassword);
                System.setProperty("javax.net.ssl.keyStorePassword", keyStpass);
            }
            
            System.setProperty("javax.net.ssl.keyStoreType", 
            		ArgList.getProperty(ComLine.keyStoreType));

            System.setProperty("javax.net.ssl.trustStoreType",
                    ArgList.getProperty(ComLine.trustStoreType));
            System.setProperty("javax.net.ssl.trustStore",
                    ArgList.getProperty(ComLine.trustStorePath));
            System.setProperty("javax.net.ssl.trustStorePassword",
                    ArgList.getProperty(ComLine.trustStorePassword));

            //System.setProperty("javax.net.ssl.supportGVO", "true");
//=============================================================================
            final int sslPort = Integer.decode(ArgList.getProperty(ComLine.PORT))
                            .intValue();

            final String sslhost = ArgList.getProperty(ComLine.SERVER);

            final JTLS_samples.Client client =
                    new JTLS_samples.Client(sslhost, sslPort);
            client.setTimeout(100000);
            client.get(ArgList.getProperty(ComLine.fileget),
                    ArgList.getProperty(
                            ComLine.fileout), null);

        } catch (NullPointerException e) {
            log.info(ComLine.HELP_ClIENT);
        } catch (ArrayIndexOutOfBoundsException e) {
            log.info(ComLine.HELP_ClIENT);
        } catch (Exception e) {
            e.printStackTrace();
        }
}
}
</java>
<java name="ComLine/ComLine.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 20.06.2007 17:15:15 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import java.lang.reflect.Method;
import java.util.logging.Logger;

/**
 * Командная строка
 *
 * @kunina Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class ComLine {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 * forbidden
 */
private ComLine() {

}


/**
 * Разбор командной строки
 *
 * @param args параметры командной строки
 */
public static void main(String[] args) {
    try {
        final Class aClass = Class.forName("ComLine." + args[0]);
        final Method[] methods = aClass.getMethods();
        Method main = null;
        for (int i = 0; i &lt; methods.length; i++) {
            if ("main".equalsIgnoreCase(methods[i].getName()))
                main = methods[i];
        }
        final Object[] Args = {args};
        if (main != null) {
            main.invoke(null, Args);
        }

    } catch (ArrayIndexOutOfBoundsException e) {
        log.info(HELP);
    } catch (ClassNotFoundException e) {
        log.info("Name of function is case sensitive\n" + HELP);
    } catch (NoClassDefFoundError e) {
        log.info("Name of function is case sensitive\n" + HELP);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

/**
 * @param com параметр
 * @param arg аргументы командной строки (пары парамтр значение параметра)
 * @param parDef значение параметра по умолчанию
 * @return значение параметра
 */
public static String getValue(String com, String[] arg, String parDef) {
    String par = null;
    int i;
    for (i = 0; i &lt; arg.length; i++)
        if (arg[i].equalsIgnoreCase(com) &amp;&amp;
                !"-".equals(arg[i + 1].substring(0, 1))) {
            par = arg[i + 1];
        }
    if (par == null) par = parDef;

    return par;
}

/**
 * @param com параметр
 * @param arg аргументы командной строки (пары парамтр значение параметра)
 * @return присутствует или нет
 */
public static boolean getFunc(String com, String[] arg) {
    int i;
    boolean par = false;
    for (i = 0; i &lt; arg.length; i++)
        if (arg[i].equalsIgnoreCase(com)) {
            par = true;
        }
    return par;
}

//----------------------------------------------------------------------------//
/**
 * Аргументы командной строки
 */
//работа с ключами и сетификатами
public static final String HDImageStore = "HDImageStore";
public static final String FloppyStore = "FloppyStore";
public static final String OCFStore = "OCFStore";
public static final String J6CFStore = "J6CFStore";
public static final String NO_STORE = "NONE";
public static final String ALIAS = "-alias";
public static final String storetype = "-storetype";
public static final String storepath = "-storepath";
public static final String storepass = "-storepass";
public static final String keypass = "-keypass";
public static final String dname = "-dname";
public static final String SignAlgoritm = "SignAlgoritm";
public static final String signpath = "-signpath";
public static final String filepath = "-filepath";
public static final String alg = "-alg";
public static final String KeyPairAlgoritm = "KeyPairAlgoritm";
public static final String nameEx = "CN=autor,OU=Security,O=CryptoPro,C=RU";
public static final String reqCertpath = "-reqCertpath";
public static final String http = "-http";
public static final String certpath = "-certpath";
public static final String certs = "-certs";
public static final String isServer = "-isServer";
public static final String encoding = "-encoding";
//пуск клиента/сервера
public static final String PORT = "-port";
public static final String SERVER = "-server";
public static final String keyStoreType = "-keyStoreType";
public static final String trustStoreType = "-trustStoreType";
public static final String trustStorePath = "-trustStorePath";
public static final String trustStorePassword = "-trustStorePassword";
public static final String keyStorePassword = "-keyStorePassword";
public static final String fileget = "-fileget";
public static final String fileout = "-fileout";
public static final String auth = "-auth";
public static final String servDir = "-servDir";
//функции
public static final String HCheckConf = "CheckConf";
public static final String HCheckConfFull = "CheckConfFull";
public static final String HKeyPairGen = "KeyPairGen";
public static final String HSignature = "Signature";
public static final String HSignatureVerif = "SignatureVerif";
public static final String HgetCert = "getCert";
public static final String HCerts = "Certs";
public static final String HServer = "Server";
public static final String HClient = "Client";
//вызов справки
public static final String hllp = "-help";
/**
 * HELP
 */
public static final String HELP = "HELP\n" +
        "Function" + "        Parameters\n\n" +
        HCheckConf + "        (without parameters)\n" +
        HCheckConfFull + "    &lt;args&gt;\n" +
        HKeyPairGen + "       args\n" +
        HSignature + "        args\n" +
        HSignatureVerif + "   args\n" +
        HgetCert + "          args\n" +
        HCerts + "            args\n" +
        HServer + "           args\n" +
        HClient + "           args\n" +
        "\nargs:\n" +
        hllp + "            call help\n" +
        "\nCall function for help...\n";

public static final String KeyPairGenHelpHD = "HELP\n" +
        "KeyPairGen \n" +
        ALIAS + "       alias                  (def: no def)\n" +
        alg + "         algorithm              (def: GOST3410)\n" +
        storetype + "   storetype              (def: HDImageStore)\n" +
        storepath + "   storepath              (def: null)\n" +
        storepass + "   storepass              (def: null)\n" +
        keypass + "     keypass                (def: null)\n" +
        isServer + "    isServer               (def: false)\n" +
        dname + "       subject of certificate (def: no def)\n" +
        reqCertpath + " C:/*.*                 (def: no def)\n" +
        encoding + "    der/base64             (def: der)\n\n" +
        hllp + "        call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String SignGenHelpHD = "HELP\n" +
        "Signature\n" +
        ALIAS + "       alias           (def: no def)\n" +
        storetype + "   storetype       (def: HDImageStore)\n" +
        storepath + "   storepath       (def: null)\n" +
        storepass + "   storepass       (def: null)\n" +
        keypass + "     keypass         (def: null)\n" +
        signpath + "    C:/*.*          (def: no def)\n" +
        filepath + "    C:/*.*          (def: no def)\n\n" +
        hllp + "        call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String SignVerHelpHD = "HELP\n" +
        "SignatureVerif\n" +
        ALIAS + "       alias           (def: no def)\n" +
        storetype + "   storetype       (def: HDImageStore)\n" +
        storepath + "   storepath       (def: null)\n" +
        storepass + "   storepass       (def: null)\n" +
        signpath + "    C:/*.*          (def: no def)\n" +
        filepath + "    C:/*.*          (def: no def)\n\n" +
        hllp + "        call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String GetCertHelpHD = "HELP\n" +
        "getCert\n" +
        ALIAS + "       alias                   (def: no def)\n" +
        storetype + "   storetype               (def: HDImageStore)\n" +
        storepath + "   storepath               (def: null)\n" +
        storepass + "   storepass               (def: null)\n" +
        http + "        center of certification (def: no def)\n" +
        reqCertpath + " C:/*.*                  (def: no def)\n" +
        certpath + "    C:/*.cer                (def: no def)\n" +
        encoding + "    der/base64              (def: der)\n\n" +
        hllp + "        call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String CertsHelpHD = "HELP\n" +
        "Certs\n" +
        ALIAS + "       alias                              (def: no def)\n" +
        storetype +
        "   storetype                          (def: HDImageStore)\n" +
        storepath + "   storepath                          (def: null)\n" +
        storepass + "   storepass                          (def: null)\n" +
        keypass + "     keypass                            (def: null)\n" +
        certs + "       C:/my.cer,C:/*.cer,...,C:/root.cer (def: no def)\n\n" +
        hllp + "        call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String HELP_SERV = "HELP\n" +
        "Server\n" +
        PORT + "               port                 (def: 443)\n" +
        auth + "               auth. of client      (def: false)\n" +
        keyStoreType + "       keyStoreType         (def: \"HDImageStore\")\n" +
        trustStoreType + "     trustStoreType       (def: \"HDImageStore\")\n" +
        trustStorePath + "     trustStorePath       (def: no def)\n" +
        trustStorePassword + " trustStorePassword   (def: no def)\n" +
        keyStorePassword + "   keyStorePassword     (def: null)\n" +
        servDir + "            serverWorkDir        (def: current)\n\n" +
        hllp + "               call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String HELP_ClIENT = "HELP\n" +
        "Client\n" +
        PORT + "               port                 (def: 443)\n" +
        SERVER + "             server name          (def: \"localhost\")\n" +
        keyStoreType + "       keyStoreType         (def: \"HDImageStore\")\n" +
        trustStoreType + "     trustStoreType       (def: \"HDImageStore\")\n" +
        trustStorePath + "     trustStorePath       (def: no def)\n" +
        trustStorePassword + " trustStorePassword   (def: no def)\n" +
        keyStorePassword + "   keyStorePassword     (def: null)\n" +
        fileget + "            name of getting file (def: index.html)\n" +
        fileout + "            path to output file  (def: out.html)\n\n" +
        hllp + "               call help\n" +
        "\n parameters with (def: no def) must be defined necessarily\n";

public static final String CheckConfFullHelp = "HELP\n" +
        "CheckConfFull\n" +
        servDir + "            serverWorkDir        (def: current)\n\n" +
        hllp + "               call help\n";

//public static final String HELP_1 = HELP + KeyPairGenHelpHD + SignGenHelpHD +
//        SignVerHelpHD + GetCertHelpHD + CertsHelpHD + HELP_SERV + HELP_ClIENT;
}
</java>
<java name="ComLine/KeyPairGen.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 20.06.2007 17:15:15 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Генерирование ключевой пары в соответствие с алгоритмом ГОСТ Р 34.10-2001 и
 * соответствующего ему самоподписанного сертификата. Запись их на носитель.
 * Генерирование запроса на сертификат и запись его в файл.
 *
 * @kunina Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class KeyPairGen {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 * forbidden.
 */
private KeyPairGen() {

}

/**
 * KeyPairGen -alias name_of_key [-alg GOST3410] [-storetype HDImageStore]
 * [-storepath null] [-storepass null] [-keypass password] [-isServer true]
 * -dname CN=autor,OU=Security,O=CryptoPro,C=RU -reqCertpath C:/*.* -encoding
 * der
 * &lt;p/&gt;
 * &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -alias &lt;/b&gt;  &lt;DD&gt;уникальное имя записываемого ключа&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -alg &lt;/b&gt; &lt;DD&gt;алгоритм для генерирования&lt;DD&gt;(по умолчанию GOST3410)&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -storetype &lt;/b&gt; &lt;DD&gt;имя ключевого носителя HDImageStore (жесткий
 * диск), FloppyStore (дискета), OCFStore (карточки) &lt;DD&gt;(по умолчанию
 * HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;-storepath &lt;/b&gt;  &lt;DD&gt;путь к хранилищу доверенных
 * сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storepass &lt;/b&gt;  &lt;DD&gt;пароль
 * на хранилище доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -keypass &lt;/b&gt; &lt;DD&gt;пароль на записываемый ключ &lt;DD&gt;(по умолчанию null)&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt;-isServer&lt;/b&gt; &lt;DD&gt;если ключ серверный, то значение true &lt;DD&gt;(по
 * умолчанию false)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -dname&lt;/b&gt;  &lt;DD&gt;имя субъекта для генерирования
 * самоподписанного сертификата&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -encoding&lt;/b&gt;  &lt;DD&gt;кодировка
 * (DER/BASE64) &lt;DD&gt;(по умолчанию DER)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -reqCertpath &lt;/b&gt; &lt;DD&gt;путь
 * для записи запроса&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args аргументы командной строки
 */
public static void main(String[] args) {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.KeyPairGenHelpHD);
    else
        try {
//----------------------------------------------------------------------------//
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties();
            //уникальное имя записываемого ключа
            ArgList.setProperty(ComLine.ALIAS,
                    ComLine.getValue(ComLine.ALIAS, args, null));
            //тип ключевого носителя
            ArgList.setProperty(ComLine.storetype,
                    ComLine.getValue(ComLine.storetype, args,
                            ComLine.HDImageStore));
            //путь к хранилищу доверенных сертификатов
            ArgList.setProperty(ComLine.storepath,
                    ComLine.getValue(ComLine.storepath, args, "null"));
            //пароль на хранилище доверенных сертификатов
            ArgList.setProperty(ComLine.storepass,
                    ComLine.getValue(ComLine.storepass, args, "null"));
            //пароль на записываемый ключ
            ArgList.setProperty(ComLine.keypass,
                    ComLine.getValue(ComLine.keypass, args, "null"));
            //имя субъекта для генерирования самодписанного сертификата
            ArgList.setProperty(ComLine.dname,
                    ComLine.getValue(ComLine.dname, args, null));
            //алгоритм ГОСТ Р 34.10-2001 (для генерирования ключевой пары)
            ArgList.setProperty(ComLine.KeyPairAlgoritm,
                    ComLine.getValue(ComLine.alg, args, "GOST3410"));
            //путь для записи GostCertificateRequest EncodedSelfCert
            ArgList.setProperty(ComLine.reqCertpath,
                    ComLine.getValue(ComLine.reqCertpath, args, null));
            //серверный ли ключ
            ArgList.setProperty(ComLine.isServer,
                    ComLine.getValue(ComLine.isServer, args, "false"));
            //в какой кодировке сохранять запрос
            ArgList.setProperty(ComLine.encoding,
                    ComLine.getValue(ComLine.encoding, args, "der"));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.storetype);
            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else {
                ArgList.setProperty(ComLine.storetype, ComLine.HDImageStore);
                log.info("Incorrect keystore type: " + ks +
                        ". Value by default is appropriated: " + ComLine
                        .HDImageStore);
            }
            //Проверка правильности имени субъекта для сертификата(длины параметра С)
            final String nf;
            nf = ArgList.getProperty(ComLine.dname);
            final String[] nfs = nf.split(",");
            for (int i = 0; i &lt; nfs.length; i++) {
                final String[] ss = nfs[i].split("=");
                if ("C".equals(ss[0]) &amp;&amp; ss[1].length() != 2)
                    throw new Exception("Incorrect name of the certificate");
            }
//============================================================================//
            //Генерирование ключевой пары в соответствие с алгоритмом ГОСТ Р 34.10-2001
            //и соответствующего ему самоподписанного сертификата.
            //Запись их на носитель. Запись запроса на сертификат (DER) в файл
            keyGen(
                    ArgList.getProperty(ComLine.ALIAS),
                    ArgList.getProperty(ComLine.KeyPairAlgoritm),
                    ArgList.getProperty(ComLine.storetype),
                    ArgList.getProperty(ComLine.keypass),
                    ArgList.getProperty(ComLine.dname),
                    ArgList.getProperty(ComLine.storepass),
                    ArgList.getProperty(ComLine.storepath),
                    ArgList.getProperty(ComLine.reqCertpath),
                    ArgList.getProperty(ComLine.isServer),
                    ArgList.getProperty(ComLine.encoding));

        } catch (NullPointerException e) {
            log.info(ComLine.KeyPairGenHelpHD);
        } catch (IllegalArgumentException e) {
            log.info("\n" +
                    e.toString() + "\n" + ComLine.KeyPairGenHelpHD);
        } catch (ArrayIndexOutOfBoundsException e) {
            log.info(ComLine.KeyPairGenHelpHD);
        } catch (Exception e) {
            e.printStackTrace();
        }

}

/**
 * Генерирование ключевой пары и запроса на сертификат.
 *
 * @param alias уникальное имя записываемого ключа
 * @param keypairAlgorithm алгоритм ГОСТ Р 34.10-2001 (генерирование ключ.
 * пары)
 * @param keystoreName имя ключевого носителя
 * @param keypass пароль на записываемый ключ
 * @param name имя субъекта для генерирования самодписанного сертификата
 * @param keystorePass пароль на хранилище доверенных сертификатов
 * @param keystorePath путь к хранилищу доверенных сертификатов
 * @param reqpath путь к файлу для записи запроса
 * @param server true - ключ аутентификации сервера, false - ключ аутентификации
 * клиента
 * @param encoding der - запись запроса в der-кодировке, base64 - запись запроса
 * в base64-кодировке
 * @throws Exception ...
 */
private static void keyGen(String alias, String keypairAlgorithm,
                           String keystoreName, String keypass, String name,
                           String keystorePass, String keystorePath,
                           String reqpath, String server, String encoding)
        throws Exception {
    //генерирование ключевой пары
    final KeyPairGenerator kg =
            KeyPairGenerator.getInstance(keypairAlgorithm);
    final KeyPair pair = kg.generateKeyPair();
    //log.info("Generation of key pair is completed");

    //генерирование самоподписанного сертификата
    final GostCertificateRequest req;
    req = new GostCertificateRequest();
    boolean isServer = false;
    if ("true".equalsIgnoreCase(server)) isServer = true;
    req.init(keypairAlgorithm, isServer);
    final byte[] encodedCert = req.getEncodedSelfCert(pair, name);

    //генерирование самоподписанного сертификата
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    final Certificate[] certs;
    certs = new Certificate[1];
    certs[0] =
            cf.generateCertificate(new ByteArrayInputStream(encodedCert));
    //log.info("Generation of certificate is completed"); /**/

    //запись в хранилище ключевой пары с самоподписанным сертификатом
    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);/**/
    final PrivateKey key;
    key = pair.getPrivate();
    char[] Keypass = null;
    if (!"null".equalsIgnoreCase(keypass)) {
        Keypass = keypass.toCharArray();
    }
    ks.setKeyEntry(alias, key, Keypass, certs);
    OutputStream os = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        os = new FileOutputStream(keystorePath);
    }
    ks.store(os, KeyStorePass);
    log
            .info("Recording of a private key named \"" + alias + "\" to " +
                    keystoreName + " is completed. Request: " + reqpath);

//----------------------------------------------------------------------------//
    //Подписанный запрос (DER кодировка)
    //Определение параметров открытого ключа субъекта
    final PublicKey publicKey = pair.getPublic();
//    boolean isServer = false;
//    if ("true".equalsIgnoreCase(server)) isServer = true;
//    req.init(keypairAlgorithm, isServer);
    req.setPublicKeyInfo(publicKey);
    //Определение имени субъекта
    req.setSubjectInfo(name);
    //Кодирование и подпись запроса
    final PrivateKey privateKey = pair.getPrivate();
    req.encodeAndSign(privateKey);

    //Запись в файл
    boolean toBASE64 = false;
    if ("base64".equalsIgnoreCase(encoding)) toBASE64 = true;
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream(reqpath);
        final PrintStream stream = new PrintStream(fos);
        if (toBASE64)
            req.printToBASE64(stream);
        else
            req.printToDER(stream);
    } finally {
        if (fos != null) fos.close();
    }
//----------------------------------------------------------------------------//
    //Отправка запроса в центр, получение сертификата и его запись

    /*String httpAddress = "http://www.cryptopro.ru/certsrv/";

    byte[] encCert = req.getEncodedCert(httpAddress);
    Certificate aliascert = cf.generateCertificate(new ByteArrayInputStream(encCert));
    //в хранилище
    ks.load(is, KeyStorePass);
    ks.setCertificateEntry(alias,aliascert);
    ks.store(os, KeyStorePass);

    //в файл
    ks.load(is, KeyStorePass);
    Certificate Cert = ks.getCertificate(alias);
    byte[] encoCert = Cert.getEncoded();
    ks.store(os, KeyStorePass);
    FileOutputStream fost = null;
    try {
        fost = new FileOutputStream("D:\\Job\\test\\myData\\prKey.cer");
        fost.write(encoCert);
    } finally {
        if (fost!=null) fost.close();
    } /**/

}


}
</java>
<java name="ComLine/Server.java">package ComLine;

import java.io.File;
import java.io.IOException;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Пример запуска сервера из командной строки (см. JTLS_samples.Server).
 * &lt;p/&gt;
 * При запросе "shutdown" прекращение работы сервера...
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Server {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

 /**/
private Server() {
}

/**
 * Server [-port port] [-auth true] [-keyStoreType HDImageStore]
 * [-trustStoreType HDImageStore] -trustStorePath C:/*.* -trustStorePassword
 * trust_pass -keyStorePassword key_pass
 * &lt;p/&gt;
 * &lt;/DD&gt; &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -port &lt;/b&gt;  &lt;DD&gt;порт сервера &lt;DD&gt;(по умолчанию 443)&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -auth &lt;/b&gt; &lt;DD&gt;нужна ли аутентификация клиента &lt;DD&gt;(по умолчанию
 * false)&lt;br&gt; &lt;DT&gt;&lt;b&gt; -keyStoreType &lt;/b&gt; &lt;DD&gt;тип ключевого носителя HDImageStore
 * (жесткий диск), FloppyStore (дискета), OCFStore или J6CFStore (карточки)
 * &lt;DD&gt;(по умолчанию HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -trustStoreType &lt;/b&gt; &lt;DD&gt;тип
 * носителя для хранилища доверенных сертификатов HDImageStore (жесткий диск),
 * FloppyStore (дискета) &lt;DD&gt;(по умолчанию HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -trustStorePath &lt;/b&gt; &lt;DD&gt;путь к хранилищу доверенных сертификатов&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -trustStorePassword &lt;/b&gt; &lt;DD&gt;пароль на хранилище доверенных
 * сертификатов&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -keyStorePassword &lt;/b&gt;  &lt;DD&gt;пароль на ключ&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -servDir &lt;/b&gt;  &lt;DD&gt;рабочая директория сервера &lt;DD&gt;(по умолчанию
 * текущая)&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args аргументы командной строки
 * @throws IOException ошибки ввода-вывода
 */
public static void main(String[] args) throws IOException {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.HELP_SERV);
    else
        try {
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties();
            //порт
            ArgList.setProperty(ComLine.PORT,
                    ComLine.getValue(ComLine.PORT, args, "443"));
            //keyStoreType
            ArgList.setProperty(ComLine.keyStoreType,
                    ComLine.getValue(ComLine.keyStoreType, args,
                            ComLine.HDImageStore));
            //trustStoreType
            ArgList.setProperty(ComLine.trustStoreType,
                    ComLine.getValue(ComLine.trustStoreType, args,
                            ComLine.HDImageStore));
            //trustStorePath
            ArgList.setProperty(ComLine.trustStorePath,
                    ComLine.getValue(ComLine.trustStorePath, args, null));
            //keyStorePassword
            ArgList.setProperty(ComLine.keyStorePassword,
                    ComLine.getValue(ComLine.keyStorePassword, args, "null"));
            //trustStorePassword
            ArgList.setProperty(ComLine.trustStorePassword,
                    ComLine.getValue(ComLine.trustStorePassword, args, null));
            //autentification of client
            ArgList.setProperty(ComLine.auth,
                    ComLine.getValue(ComLine.auth, args, "false"));
            //server working dir
            ArgList.setProperty(ComLine.servDir,
                    ComLine.getValue(ComLine.servDir,
                            args, new File(".").getCanonicalPath()));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.keyStoreType);
            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else {
                ArgList.setProperty(ComLine.storetype, ComLine.HDImageStore);
                log.info("Incorrect keystore type: " + ks +
                        ". Value by default is appropriated: " + ComLine
                        .HDImageStore);
            }
            if (!"null"
                    .equalsIgnoreCase(
                            ArgList.getProperty(ComLine.keyStorePassword))) {
                final String keyStpass =
                        ArgList.getProperty(ComLine.keyStorePassword);
                System.setProperty("javax.net.ssl.keyStorePassword", keyStpass);
            }
            //
            if (!new File(ArgList.getProperty(ComLine.servDir)).isDirectory())
                ArgList.setProperty(ComLine.servDir,
                        new File(".").getCanonicalPath());

            System.setProperty("javax.net.ssl.keyStoreType",
                    ArgList.getProperty(ComLine.keyStoreType));

            System.setProperty("javax.net.ssl.trustStoreType",
                    ArgList.getProperty(ComLine.trustStoreType));
            System.setProperty("javax.net.ssl.trustStore",
                    ArgList.getProperty(ComLine.trustStorePath));
            System.setProperty("javax.net.ssl.trustStorePassword",
                    ArgList.getProperty(ComLine.trustStorePassword));

            System.setProperty("javax.net.ssl.supportGVO", "true");
//=============================================================================
            final int sslPort =
                    Integer.decode(ArgList.getProperty(ComLine.PORT))
                            .intValue();
            boolean auth = false;
            if (ArgList.getProperty(ComLine.auth).equalsIgnoreCase("true"))
                auth = true;
            //сервер с аутентификацией auth
            final JTLS_samples.Server server = new JTLS_samples.Server(sslPort,
                    auth, ArgList.getProperty(ComLine.servDir));
            server.setTimeout(100000);
            server.start();
            if (!server.isAlive()) throw new IOException();
        } catch (NullPointerException e) {
            log.info(ComLine.HELP_SERV);
        } catch (ArrayIndexOutOfBoundsException e) {
            log.info(ComLine.HELP_SERV);
        } catch (Exception e) {
            e.printStackTrace();
        }
}
}
</java>
<java name="ComLine/Signature.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 22.06.2007 14:13:15 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Формирование электронной цифровой подписи в соответствии с алгоритмом ГОСТ Р
 * 34.10-2001
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Signature {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 * forbidden.
 */
private Signature() {
}

/**
 * Signature -alias name_of_key [-storetype HDImageStore] [-storepath null]
 * [-storepass null] [-keypass password] -signpath C:/*.* -filepath C:/*.*
 * &lt;p/&gt;
 * &lt;/DD&gt; &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -alias &lt;/b&gt;  &lt;DD&gt;уникальное имя ключа&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -keypass &lt;/b&gt; &lt;DD&gt;пароль на записываемый ключ &lt;DD&gt;(по умолчанию null)&lt;br&gt;
 * &lt;DT&gt;&lt;b&gt; -storetype &lt;/b&gt; &lt;DD&gt;имя ключевого носителя HDImageStore (жесткий
 * диск), FloppyStore (дискета), OCFStore или J6CFStore (карточки) &lt;DD&gt;(по
 * умолчанию HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;-storepath &lt;/b&gt; &lt;DD&gt;путь к хранилищу
 * доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storepass &lt;/b&gt;
 * &lt;DD&gt;пароль на хранилище доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -signpath &lt;/b&gt; &lt;DD&gt;путь к файлу подписи &lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -filepath&lt;/b&gt;
 * &lt;DD&gt;путь к подписываемому файлу&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args пары аргументов командной строки
 */
public static void main(String[] args) {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.SignGenHelpHD);
    else
        try {
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties();
            //уникальное имя ключа
            ArgList.setProperty(ComLine.ALIAS,
                    ComLine.getValue(ComLine.ALIAS, args, null));
            //пароль на ключ
            ArgList.setProperty(ComLine.keypass,
                    ComLine.getValue(ComLine.keypass, args, "null"));
            //тип ключевого носителя
            ArgList.setProperty(ComLine.storetype,
                    ComLine.getValue(ComLine.storetype, args,
                            ComLine.HDImageStore));
            //путь к хранилищу доверенных сертификатов
            ArgList.setProperty(ComLine.storepath,
                    ComLine.getValue(ComLine.storepath, args, "null"));
            //пароль на хранилище доверенных сертификатов
            ArgList.setProperty(ComLine.storepass,
                    ComLine.getValue(ComLine.storepass, args, "null"));
            //алгоритм формирования ЭЦП
            ArgList.setProperty(ComLine.SignAlgoritm, "GOST3411withGOST3410EL");
            //путь к файлу подписи
            ArgList.setProperty(ComLine.signpath,
                    ComLine.getValue(ComLine.signpath, args, null));
            //путь к подписываемому файлу
            ArgList.setProperty(ComLine.filepath,
                    ComLine.getValue(ComLine.filepath, args, null));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.storetype);
            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else {
                ArgList.setProperty(ComLine.storetype, ComLine.HDImageStore);
                Logger.getLogger("LOGGER")
                        .info("Incorrect keystore type: " + ks +
                                ". Value by default is appropriated: " + ComLine
                                .HDImageStore);
            }
            //Генерирование и запись ЭЦП
            Sign(
                    ArgList.getProperty(ComLine.ALIAS),
                    ArgList.getProperty(ComLine.keypass),
                    ArgList.getProperty(ComLine.storetype),
                    ArgList.getProperty(ComLine.SignAlgoritm),
                    ArgList.getProperty(ComLine.filepath),
                    ArgList.getProperty(ComLine.storepass),
                    ArgList.getProperty(ComLine.storepath),
                    ArgList.getProperty(ComLine.signpath));

        } catch (NullPointerException e) {
            //System.out.println(e.toString());
            Logger.getLogger("LOGGER").info(ComLine.SignGenHelpHD);
        } catch (Exception e1) {
            final String sss = "java.lang.Exception:";
            log.info("\n" +
                    e1.toString()
                            .substring(sss.length(), e1.toString().length()) +
                    "\n" + ComLine.SignGenHelpHD);
        }
}

/**
 * @param alias уникальное имя ключа
 * @param keypass пароль на ключ
 * @param keystoreName тип ключевого носителя
 * @param signAlgoritm алгоритм ЭЦП
 * @param filePath путь к подписываемому файлу
 * @param keystorePass пароль на хранилище доверенных сертификатов
 * @param keystorePath путь к хранилищу доверенных сертификатов
 * @param signPath путь к файлу подписи
 * @throws Exception ...
 */
private static void Sign(String alias, String keypass,
                         String keystoreName, String signAlgoritm,
                         String filePath,
                         String keystorePass, String keystorePath,
                         String signPath)
        throws Exception {
    //загрузка ключа из хранилища HDImageStore
    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);
    //ks.load(null, null);
    final PrivateKey privateKey;
    char[] Keypass = null;
    if (!"null".equalsIgnoreCase(keypass)) {
        Keypass = keypass.toCharArray();
    }
    privateKey = (PrivateKey) ks.getKey(alias, Keypass);
    if (privateKey == null)
        throw new Exception("Key named \"" + alias + "\" not found");
    //log.info("Loading of a private key is completed");

    //чтение текста
    final byte[] text;
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(filePath);
        text = new byte[fis.available()];
        int len;
        int tot = 0;
        do {
            len = fis.read(text, tot, text.length - tot);
            tot += len;
        } while (len &gt; 0);
    } finally {
        if (fis != null) fis.close();
    }
    //log.info("Loading of a text is completed");

    //генерирование ЭЦП
    final java.security.Signature sig;
    sig = java.security.Signature.getInstance(signAlgoritm);
    sig.initSign(privateKey);
    sig.update(text);

    //запись подписи в файл
    final byte[] signature;
    signature = sig.sign();
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream(signPath);
        fos.write(signature);
    } finally {
        if (fos != null) fos.close();
    }
    log.info("Generation and recording of the signature is completed");

}


}

</java>
<java name="ComLine/SignatureVerif.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 25.06.2007 14:29:44 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import java.io.FileInputStream;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.PublicKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Проверка электронной цифровой подписи в соответствии с алгоритмами ГОСТ Р
 * 34.10-94 и ГОСТ Р 34.10-2001.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class SignatureVerif {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 * forbidden.
 */
private SignatureVerif() {
}

/**
 * SignatureVerif -alias name_of_key [-storetype HDImageStore] [-storepath null]
 * [-storepass null] -signpath C:/*.* -filepath C:/*.*
 * &lt;p/&gt;
 * &lt;/DD&gt; &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -alias &lt;/b&gt;  &lt;DD&gt;уникальное имя ключа&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -keypass &lt;/b&gt; &lt;DD&gt;пароль на записываемый ключ &lt;DD&gt;(по умолчанию null)&lt;br&gt;
 * &lt;DT&gt;&lt;b&gt; -storetype &lt;/b&gt; &lt;DD&gt;имя ключевого носителя HDImageStore (жесткий
 * диск), FloppyStore (дискета), OCFStore или J6CFStore (карточки) &lt;DD&gt;(по
 * умолчанию HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;-storepath &lt;/b&gt; &lt;DD&gt;путь к хранилищу
 * доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storepass &lt;/b&gt;
 * &lt;DD&gt;пароль на хранилище доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt;
 * &lt;DT&gt;&lt;b&gt; -signpath &lt;/b&gt; &lt;DD&gt;путь к файлу подписи &lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -filepath&lt;/b&gt;
 * &lt;DD&gt;путь к проверяемому файлу&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args пары аргументов командной строки
 */
public static void main(String[] args) {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.SignVerHelpHD);
    else
        try {
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties();
            //уникальное имя ключа
            ArgList.setProperty(ComLine.ALIAS,
                    ComLine.getValue(ComLine.ALIAS, args, null));
            //тип ключевого носителя
            ArgList.setProperty(ComLine.storetype,
                    ComLine.getValue(ComLine.storetype, args,
                            ComLine.HDImageStore));
            //путь к хранилищу доверенных сертификатов
            ArgList.setProperty(ComLine.storepath,
                    ComLine.getValue(ComLine.storepath, args, "null"));
            //пароль на хранилище доверенных сертификатов
            ArgList.setProperty(ComLine.storepass,
                    ComLine.getValue(ComLine.storepass, args, "null"));
            //алгоритм формирования ЭЦП
            ArgList.setProperty(ComLine.SignAlgoritm, "GOST3411withGOST3410EL");
            //путь к файлу подписи
            ArgList.setProperty(ComLine.signpath,
                    ComLine.getValue(ComLine.signpath, args, null));
            //путь к подписываемому файлу
            ArgList.setProperty(ComLine.filepath,
                    ComLine.getValue(ComLine.filepath, args, null));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.storetype);
            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else {
                ArgList.setProperty(ComLine.storetype, ComLine.HDImageStore);
                log.info("Incorrect keystore type: " + ks +
                        ". Value by default is appropriated: " + ComLine
                        .HDImageStore);
            }

            //Проверка ЭЦП
            SignVer(
                    ArgList.getProperty(ComLine.ALIAS),
                    ArgList.getProperty(ComLine.storetype),
                    ArgList.getProperty(ComLine.SignAlgoritm),
                    ArgList.getProperty(ComLine.filepath),
                    ArgList.getProperty(ComLine.storepass),
                    ArgList.getProperty(ComLine.storepath),
                    ArgList.getProperty(ComLine.signpath));

        } catch (NullPointerException e) {
            //System.out.println(e.toString());
            log.info(ComLine.SignVerHelpHD);
        } catch (Exception e1) {
            final String sss = "java.lang.Exception:";
            log.info("\n" +
                    e1.toString()
                            .substring(sss.length(), e1.toString().length()) +
                    "\n" + ComLine.SignVerHelpHD);
        }
}

/**
 * Проверка ЭЦП.
 *
 * @param alias уникальное имя ключа
 * @param keystoreName имя ключевого носителя
 * @param signAlgoritm пароль на записываемый ключ
 * @param filePath путь к подписанному файлу
 * @param keystorePass пароль на хранилище доверенных сертификатов
 * @param keystorePath путь к хранилищу доверенных сертификатов
 * @param signPath путь к файлу подписи
 * @throws Exception ...
 */
private static void SignVer(String alias,
                            String keystoreName, String signAlgoritm,
                            String filePath,
                            String keystorePass, String keystorePath,
                            String signPath)
        throws Exception {
    //чтение текста
    final byte[] text;
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(filePath);
        text = new byte[fis.available()];
        int len;
        int tot = 0;
        do {
            len = fis.read(text, tot, text.length - tot);
            tot += len;
        } while (len &gt; 0);
    } finally {
        if (fis != null) fis.close();
    }
    //log.info("Loading of a text is completed");

    //чтение подписи из файла
    final byte[] signature;
    FileInputStream fis1 = null;
    try {
        fis1 = new FileInputStream(signPath);
        signature = new byte[fis1.available()];
        int len;
        int tot = 0;
        do {
            len = fis1.read(signature, tot, signature.length - tot);
            tot += len;
        } while (len &gt; 0);
    } finally {
        if (fis1 != null) fis1.close();
    }
    //log.info("Loading of a signature is completed");

    //загрузка открытого ключа из хранилища HDImageStore
    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);
    final Certificate cert;
    cert = ks.getCertificate(alias);
    final PublicKey publicKey;
    publicKey = cert.getPublicKey();
    if (publicKey == null)
        throw new Exception("Key named \"" + alias + "\" not found");
    //log.info("Loading of a public key is completed");

    //проверка подписи
    final java.security.Signature sig;
    sig = Signature.getInstance(signAlgoritm);
    sig.initVerify(publicKey);
    sig.update(text);
    final boolean verifies;
    verifies = sig.verify(signature);
    final String s;
    if (verifies) s = "The signature is true";
    else s = "The signature is not true";
    log.info(s);

}
}
</java>
<java name="ComLine/getCert.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 26.06.2007 14:59:43 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package ComLine;

import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * Получение сертификата из запроса, представленного в DER-кодировке и запись
 * его в хранилище и в файл
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class getCert {
/**
 * logger
 */
private static Logger log = Logger.getLogger("LOGGER");

/**
 * forbidden
 */
private getCert() {
}

/**
 * getCert -alias name_of_key [-storetype HDImageStore] [-storepath null]
 * [-storepass null] -http http://www.cryptopro.ru/certsrv/ -certpath C:/*.cer
 * -reqCertpath C:/*.*
 * &lt;p/&gt;
 * &lt;DL&gt; &lt;DT&gt;&lt;b&gt; -alias &lt;/b&gt;  &lt;DD&gt;уникальное имя ключа&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storetype
 * &lt;/b&gt; &lt;DD&gt;имя ключевого носителя HDImageStore (жесткий диск), FloppyStore
 * (дискета), OCFStore или J6CFStore (карточки)&lt;DD&gt;(по умолчанию
 * HDImageStore)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;-storepath &lt;/b&gt; &lt;DD&gt;путь к хранилищу доверенных
 * сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -storepass &lt;/b&gt; &lt;DD&gt;пароль
 * на хранилище доверенных сертификатов &lt;DD&gt;(по умолчанию null)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt;
 * -http &lt;/b&gt; &lt;DD&gt;путь к центру сертификации&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -reqCertpath&lt;/b&gt;
 * &lt;DD&gt;путь к файлу с запросом&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -encoding&lt;/b&gt;  &lt;DD&gt;кодировка запроса
 * (DER/BASE64)&lt;DD&gt;(по умочанию DER)&lt;/DD&gt; &lt;DT&gt;&lt;b&gt; -сertpath&lt;/b&gt; &lt;DD&gt;путь к файлу
 * для записи сертификата&lt;/DD&gt;&lt;/DT&gt; &lt;/DL&gt;
 *
 * @param args аргументы командной строки
 */
public static void main(String[] args) {
    if (ComLine.getFunc(ComLine.hllp, args)) log.info(ComLine.CertsHelpHD);
    else
        try {
            //Заполнение таблицы свойств значениями параметров командной строки
            //или значениями по умолчанию при отсутствии первых
            final Properties ArgList = new Properties();
            //уникальное имя ключа
            ArgList.setProperty(ComLine.ALIAS,
                    ComLine.getValue(ComLine.ALIAS, args, null));
            //тип ключевого носителя
            ArgList.setProperty(ComLine.storetype,
                    ComLine.getValue(ComLine.storetype, args,
                            ComLine.HDImageStore));
            //путь к хранилищу доверенных сертификатов
            ArgList.setProperty(ComLine.storepath,
                    ComLine.getValue(ComLine.storepath, args, "null"));
            //пароль на хранилище доверенных сертификатов
            ArgList.setProperty(ComLine.storepass,
                    ComLine.getValue(ComLine.storepass, args, "null"));
            //путь к центру сертификации
            ArgList.setProperty(ComLine.http,
                    ComLine.getValue(ComLine.http, args, null));
            //путь к запросу на сертификат
            ArgList.setProperty(ComLine.reqCertpath,
                    ComLine.getValue(ComLine.reqCertpath, args, null));
            //путь к файлу для записи сертификата
            ArgList.setProperty(ComLine.certpath,
                    ComLine.getValue(ComLine.certpath, args, null));
            //кодировка запроса
            ArgList.setProperty(ComLine.encoding,
                    ComLine.getValue(ComLine.encoding, args, "der"));

            //Проверка типа хранилища.
            //При неверном вводе присваивается значение по умолчанию HDImageStore.
            final String ks;
            ks = ArgList.getProperty(ComLine.storetype);
            if (ks.equalsIgnoreCase(ComLine.HDImageStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.FloppyStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.OCFStore)) {
            } else if (ks.equalsIgnoreCase(ComLine.J6CFStore)) {
            } else {
                ArgList.setProperty(ComLine.storetype, ComLine.HDImageStore);
                log.info("Incorrect keystore type: " + ks +
                        ". Value by default is appropriated: " + ComLine
                        .HDImageStore);
            }

            //Запрос сертификата и его запись
            getCert(
                    ArgList.getProperty(ComLine.ALIAS),
                    ArgList.getProperty(ComLine.reqCertpath),
                    ArgList.getProperty(ComLine.storetype),
                    ArgList.getProperty(ComLine.storepass),
                    ArgList.getProperty(ComLine.storepath),
                    ArgList.getProperty(ComLine.http),
                    ArgList.getProperty(ComLine.certpath),
                    ArgList.getProperty(ComLine.encoding));

        } catch (NullPointerException e) {
            //System.out.println(e.toString());
            log.info(ComLine.GetCertHelpHD);
        } catch (Exception e1) {
            final String sss = "java.lang.Exception:";
            log.info("\n" +
                    e1.toString()
                            .substring(sss.length(), e1.toString().length()) +
                    "\n" + ComLine.GetCertHelpHD);
        }

}

/**
 * @param alias имя ключа
 * @param reqpath путь к файлу с запросом
 * @param keystoreName тип ключевого носителя
 * @param keystorePass пароль на хранилище доверенных сертификатов
 * @param keystorePath путь к хранилищу доверенных сертификатов
 * @param httpAddr путь к центру сертификации
 * @param cerpath путь к файлу для записи сертификата
 * @param encoding кодировка запроса
 * @throws Exception ...
 */
private static void getCert(String alias,
                            String reqpath,
                            String keystoreName,
                            String keystorePass,
                            String keystorePath,
                            String httpAddr,
                            String cerpath,
                            String encoding) throws Exception {

    //чтение запроса из файла
    InputStream is = null;
    FileOutputStream fost = null;
    final byte[] encodedCert;
    try {
        is = new FileInputStream(reqpath);
        if ("base64".equals(encoding)) {
            //Получение сертификата из запроса, представленного в BASE64 кодировке
            encodedCert =
                    GostCertificateRequest.getEncodedCertFromDER(httpAddr, is);
        } else {
            //Получение сертификата из запроса, представленного в DER кодировке
            encodedCert =
                    GostCertificateRequest.getEncodedCertFromDER(httpAddr, is);
        }
        //запись в файл
        fost = new FileOutputStream(cerpath);
        fost.write(encodedCert);

        //запись в хранилище
        final KeyStore ks = KeyStore.getInstance(keystoreName);
        char[] KeyStorePass = null;
        if (!"null".equalsIgnoreCase(keystorePass)) {
            KeyStorePass = keystorePass.toCharArray();
        }
        InputStream Is = null;
        if (!"null".equalsIgnoreCase(keystorePath)) {
            Is = new FileInputStream(keystorePath);
        }
        ks.load(Is, KeyStorePass);

        final CertificateFactory cf = CertificateFactory.getInstance("X509");
        final Certificate cert;
        cert = cf.generateCertificate(new ByteArrayInputStream(encodedCert));
        ks.setCertificateEntry(alias, cert);
        OutputStream os = null;
        if (!"null".equalsIgnoreCase(keystorePath)) {
            os = new FileOutputStream(keystorePath);
        }
        ks.store(os, KeyStorePass);
        log.info(
                "Recording of a certificate to " + cerpath + " and to " +
                        keystoreName + " is completed.");
    } finally {
        if (is != null) is.close();
        if (fost != null) fost.close();
    }


}
}
</java>
<java name="Crypt_samples/Decrypt.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 16.02.2009 12:39:55 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Crypt_samples;

import com.objsys.asn1j.runtime.Asn1BerEncodeBuffer;
import com.objsys.asn1j.runtime.Asn1Exception;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_EncryptedKey;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_Key;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_MAC;
import ru.CryptoPro.JCP.tools.Array;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.util.Arrays;

/**
 * Пример расшифрования сессионного ключа и текста на нем.
 * &lt;p/&gt;
 * Совместим с Encrypt.java и примером из CSP (...\samples\CSP\EncryptFile)
 * &lt;p/&gt;
 * Контейнер получателя и сертификат отправителя должны быть уже созданы
 * (см. GenKeys.java)
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Decrypt {
/**
 * Секретный ключ получателя
 */
private static PrivateKey responderPrivateKey;
/**
 * Открытый ключ отправителя (из сертификата)
 */
private static PublicKey senderPublicKey;
/**
 * Синхропосылка
 */
private static IvParameterSpec sv;
/**
 * Вектор инициализации
 */
private static IvParameterSpec iv;
/**
 * рабочая директория
 */
private static final String W_PATH = GenKeys.W_PATH;
/**
 * имя получателя
 */
private static final String RESPONDER = GenKeys.RESPONDER;
/**
 * имя отправителя
 */
private static final String SENDER = GenKeys.SENDER;
/**
 * разделитель
 */
private static final String F_SEP = File.separator;

/**
 * @param args *
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    prepareForSample();
    unWrapAndDecrypt();
}

/**
 * получение сертификата из файла
 *
 * @param filePath файл сертификата
 * @return Certificate
 * @throws FileNotFoundException /
 * @throws CertificateException /
 */
private static Certificate generateCert(String filePath)
        throws FileNotFoundException, CertificateException {
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    return cf.generateCertificate(new FileInputStream(filePath));
}

/**
 * Ключи и случайные данные
 *
 * @throws NoSuchAlgorithmException /
 * @throws KeyStoreException /
 * @throws IOException /
 * @throws CertificateException /
 * @throws UnrecoverableKeyException /
 */
private static void prepareForSample()
        throws NoSuchAlgorithmException, KeyStoreException, IOException,
        CertificateException, UnrecoverableKeyException {
    //создание ключей для примера (см. GenKeys.java)
    //сторона получателя
    final KeyStore ks = KeyStore.getInstance("HDImageStore");
    ks.load(null, null);
    responderPrivateKey = (PrivateKey) ks.getKey(RESPONDER, null);
    //сертификат отправителя
    final Certificate responderCert =
            generateCert(W_PATH + F_SEP + SENDER + GenKeys.CERT_EXT);
    senderPublicKey = responderCert.getPublicKey();
    //на строне отправителя были выработаны случайные вектор инициализации
    //и синхропосылка
    sv = new IvParameterSpec(Array.readFile(W_PATH + F_SEP + "session_SV.bin"));
    iv = new IvParameterSpec(Array.readFile(W_PATH + F_SEP + "vector.bin"));
}

/**
 * Расшифрование ключа и текста на нем
 *
 * @throws NoSuchAlgorithmException /
 * @throws InvalidAlgorithmParameterException /
 * @throws InvalidKeyException /
 * @throws NoSuchPaddingException /
 * @throws IOException /
 * @throws Asn1Exception /
 * @throws BadPaddingException /
 * @throws IllegalBlockSizeException /
 */
private static void unWrapAndDecrypt() throws NoSuchAlgorithmException,
        InvalidAlgorithmParameterException, InvalidKeyException,
        NoSuchPaddingException, IOException, Asn1Exception, BadPaddingException,
        IllegalBlockSizeException {

    //выработка ключа согласования для расшифрования ключа key
    final KeyAgreement keyAgree = KeyAgreement.getInstance("GOST3410DH");
    keyAgree.init(responderPrivateKey, sv, null);
    keyAgree.doPhase(senderPublicKey, true);
    final SecretKey secretKey = keyAgree.generateSecret("GOST28147");

    //создание шифратора
    Cipher cipher = Cipher.getInstance("GOST28147/PRO_EXPORT/NoPadding");

    //key
    final Gost28147_89_EncryptedKey ek = new Gost28147_89_EncryptedKey();
    final byte[] enc =
            Array.readFile(W_PATH + F_SEP + "session_EncryptedKey.bin");
    ek.encryptedKey = new Gost28147_89_Key(enc);
    //mac
    final byte[] mc = Array.readFile(W_PATH + F_SEP + "session_MacKey.bin");
    ek.macKey = new Gost28147_89_MAC(mc);

    final Asn1BerEncodeBuffer ebuf = new Asn1BerEncodeBuffer();
    ek.encode(ebuf);
    final byte[] wrap = ebuf.getMsgCopy();
    //расшифрование ключа
    cipher.init(Cipher.UNWRAP_MODE, secretKey, sv);
    final SecretKey key_ =
            (SecretKey) cipher.unwrap(wrap, null, Cipher.SECRET_KEY);
    final byte[] encr = Array.readFile(W_PATH + F_SEP + "encrypt.bin");

    //расшифрование данных на ключе key_
    cipher = Cipher.getInstance("GOST28147");
    cipher.init(Cipher.DECRYPT_MODE, key_, iv);
    final byte[] decr_ = cipher.doFinal(encr);

    final byte[] txt = Array.readFile(W_PATH + F_SEP + "source.txt");

    if (Arrays.equals(txt, decr_)) System.out.println("OK");
}
}
</java>
<java name="Crypt_samples/Encrypt.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 16.02.2009 12:39:34 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Crypt_samples;

import com.objsys.asn1j.runtime.Asn1BerDecodeBuffer;
import com.objsys.asn1j.runtime.Asn1Exception;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_EncryptedKey;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_Key;
import ru.CryptoPro.JCP.ASN.Gost28147_89_EncryptionSyntax.Gost28147_89_MAC;
import ru.CryptoPro.JCP.tools.Array;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.util.Arrays;
import java.util.Random;

/**
 * Пример зашифрования сессионного ключа и текста на нем.
 * &lt;p/&gt;
 * Совместим с Decrypt.java и примером из CSP (...\samples\CSP\DecryptFile)
 * &lt;p/&gt;
 * Контейнер отправителя и сертификат получателя должны быть уже созданы
 * (см. GenKeys.java)
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Encrypt {
/**
 * генератор случайных чисел
 */
private static final Random rnd = new Random();
/**
 * Секретный ключ отправителя
 */
private static PrivateKey senderPrivateKey;
/**
 * Открытый ключ получателя (из сертификата)
 */
private static PublicKey responderPublicKey;
/**
 * Синхропосылка
 */
private static IvParameterSpec sv;
/**
 * Вектор инициализации
 */
private static IvParameterSpec iv;
/**
 * текст
 */
private static final byte[] TEXT = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
/**
 * рабочая директория
 */
private static final String W_PATH = GenKeys.W_PATH;
/**
 * имя получателя
 */
private static final String RESPONDER = GenKeys.RESPONDER;
/**
 * имя отправителя
 */
private static final String SENDER = GenKeys.SENDER;
/**
 * разделитель
 */
private static final String F_SEP = File.separator;

/**
 * @param args *
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    prepareForSample();
    wrapAndEncrypt();
}

/**
 * создание случайной синхропосылки или вектора инициализации
 *
 * @return IvParameterSpec
 */
private static IvParameterSpec generateNewSyncro() {
    final byte[] syncro = new byte[8];
    for (int j = 0; j &lt; 8; j++) syncro[j] = (byte) rnd.nextInt();
    return new IvParameterSpec(syncro);
}

/**
 * получение сертификата из файла
 *
 * @param filePath файл сертификата
 * @return Certificate
 * @throws FileNotFoundException /
 * @throws CertificateException /
 */
private static Certificate generateCert(String filePath)
        throws FileNotFoundException, CertificateException {
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    return cf.generateCertificate(new FileInputStream(filePath));
}

/**
 * Ключи и случайные данные
 *
 * @throws NoSuchAlgorithmException /
 * @throws KeyStoreException /
 * @throws IOException /
 * @throws CertificateException /
 * @throws UnrecoverableKeyException /
 */
private static void prepareForSample()
        throws NoSuchAlgorithmException, KeyStoreException, IOException,
        CertificateException, UnrecoverableKeyException {
    //создание ключей для примера (см. GenKeys.java)
    //сторона отправителя
    final KeyStore ks = KeyStore.getInstance("HDImageStore");
    ks.load(null, null);
    senderPrivateKey = (PrivateKey) ks.getKey(SENDER, null);
    //сертификат получателя
    final Certificate responderCert =
            generateCert(W_PATH + F_SEP + RESPONDER + GenKeys.CERT_EXT);
    responderPublicKey = responderCert.getPublicKey();
    //на строне отправителя вырабатываются случайные вектор инициализации
    //и синхропосылка
    sv = generateNewSyncro();
    iv = generateNewSyncro();
}

/**
 * Зашифрование секретного ключа и текста
 *
 * @throws NoSuchAlgorithmException /
 * @throws NoSuchPaddingException /
 * @throws InvalidAlgorithmParameterException /
 * @throws InvalidKeyException /
 * @throws IllegalBlockSizeException /
 * @throws IOException /
 * @throws Asn1Exception /
 * @throws BadPaddingException /
 */
private static void wrapAndEncrypt()
        throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidAlgorithmParameterException, InvalidKeyException,
        IllegalBlockSizeException, IOException, Asn1Exception,
        BadPaddingException {

    //случайный ключ
    final KeyGenerator kg = KeyGenerator.getInstance("GOST28147");
    final SecretKey key = kg.generateKey();

    //выработка ключа согласования для зашифрования ключа key
    final KeyAgreement keyAgree = KeyAgreement.getInstance("GOST3410DH");
    keyAgree.init(senderPrivateKey, sv, null);
    keyAgree.doPhase(responderPublicKey, true);
    final SecretKey secretKey = keyAgree.generateSecret("GOST28147");

    //создание шифратора
    Cipher cipher = Cipher.getInstance("GOST28147/PRO_EXPORT/NoPadding");
    //инициализация шифратора
    cipher.init(Cipher.WRAP_MODE, secretKey, sv);
    final byte[] wrap = cipher.wrap(key);

    final Asn1BerDecodeBuffer buf = new Asn1BerDecodeBuffer(wrap);
    final Gost28147_89_EncryptedKey ek = new Gost28147_89_EncryptedKey();
    ek.decode(buf);
    //key
    final Gost28147_89_Key enk = ek.encryptedKey;
    //mac
    final Gost28147_89_MAC mac = ek.macKey;

    //зашифрование данных на ключе key
    cipher = Cipher.getInstance("GOST28147");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    final byte[] encr = cipher.doFinal(TEXT);

    Array.writeFile(W_PATH + F_SEP + "encrypt.bin", encr);
    Array.writeFile(W_PATH + F_SEP + "session_EncryptedKey.bin", enk.value);
    Array.writeFile(W_PATH + F_SEP + "session_MacKey.bin", mac.value);
    Array.writeFile(W_PATH + F_SEP + "source.txt", TEXT);
    Array.writeFile(W_PATH + F_SEP + "session_SV.bin", sv.getIV());
    Array.writeFile(W_PATH + F_SEP + "vector.bin", iv.getIV());

    //ПРОВЕРКА
    //расшифрование ключа key=key_
    cipher.init(Cipher.UNWRAP_MODE, secretKey, sv);
    final SecretKey key_ =
            (SecretKey) cipher.unwrap(wrap, null, Cipher.SECRET_KEY);

    //расшифрование данных на ключе key_
    cipher.init(Cipher.DECRYPT_MODE, key_, iv);
    final byte[] decr_ = cipher.doFinal(encr);

    if (Arrays.equals(TEXT, decr_)) System.out.println("OK");
}

}
</java>
<java name="Crypt_samples/GenKeys.java">/**
 * $RCSfile$
 * version $Revision: 36464 $
 * created 16.02.2009 13:18:24 by kunina
 * last modified $Date: 2012-07-24 15:08:34 +0400 (Tue, 24 Jul 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package Crypt_samples;

import ru.CryptoPro.JCP.tools.Array;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;

/**
 * создание контейнеров для примеров Encrypt.java и Decrypt.java
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class GenKeys {
/**
 * имя отправителя (контейнер, сертификат)
 */
public static final String SENDER = "Sender";
/**
 * имя получателя (контейнер, сертификат)
 */
public static final String RESPONDER = "Responder";
/**
 * рабочая директория
 */
public static String W_PATH = "C:\\TESTS";
/**
 * расширение файла сертификата
 */
public static final String CERT_EXT = ".cer";

/**
 * @param args *
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //создание контейнеров для примеров Encrypt и Decrypt
    createContainer(SENDER);
    createContainer(RESPONDER);
    //экспорт сертификатов
    expCert(SENDER, W_PATH);
    expCert(RESPONDER, W_PATH);
}

/**
 * @param name имя
 * @param pathh рабочая директория
 * @throws KeyStoreException /
 * @throws NoSuchAlgorithmException /
 * @throws IOException /
 * @throws CertificateException /
 */
private static void expCert(String name, String pathh) throws KeyStoreException,
        NoSuchAlgorithmException, IOException, CertificateException {
    final KeyStore ks = KeyStore.getInstance("HDImageStore");
    ks.load(null, null);
    final Certificate cert = ks.getCertificate(name);
    Array.writeFile(pathh + File.separator + name + CERT_EXT,
            cert.getEncoded());
}

/**
 * @param name имя контейнера
 * @throws NoSuchAlgorithmException /
 * @throws IOException /
 * @throws SignatureException /
 * @throws InvalidKeyException /
 * @throws CertificateException /
 * @throws KeyStoreException /
 */
private static void createContainer(String name)
        throws NoSuchAlgorithmException, IOException, SignatureException,
        InvalidKeyException, CertificateException, KeyStoreException, NoSuchProviderException {
    final KeyPairGenerator kg = KeyPairGenerator.getInstance("GOST3410DH");
    final KeyPair keyPair = kg.generateKeyPair();
    //генерирование самоподписанного сертификата(клиент)
    final GostCertificateRequest req = new GostCertificateRequest();
    req.init("GOST3410DH", false);
    final byte[] encodedCert = req.getEncodedSelfCert(keyPair, "CN=" + name);

    //генерирование самоподписанного сертификата
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    final Certificate[] certs;
    certs = new Certificate[1];
    certs[0] = cf.generateCertificate(new ByteArrayInputStream(encodedCert));

    //запись в хранилище ключевой пары с самоподписанным сертификатом
    final KeyStore ks = KeyStore.getInstance("HDImageStore");
    ks.load(null, null);
    ks.setKeyEntry(name, keyPair.getPrivate(), null, certs);
}
}
</java>
<java name="Crypt_samples/SessionKeyByPasswordExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package Crypt_samples;

import ru.CryptoPro.Crypto.Key.GostSecretKey;
import ru.CryptoPro.JCP.Key.SecretKeySpec;
import ru.CryptoPro.JCP.params.CryptParamsSpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.MessageDigest;

/**
 * Created with IntelliJ IDEA.
 * Date: 24.08.12
 * Time: 19:33
 * To change this template use File | Settings | File Templates.
 */

/**
 * Небезопасная схема, нерекомендуемая к использованию.
 */
public class SessionKeyByPasswordExample {

    public static void main(String[] args) throws Exception {

        // Вектор инициализации и данные.
        final byte[] iv = {1, 1, 1, 1, 1, 1, 1, 1};
        final byte[] data = "Simple Text!".getBytes();

        // Пароль клиента хешируем и получаем 32 байта.
        byte[] clientPassword = "password".getBytes();
        byte[] hashedPassword = MessageDigest.getInstance("GOST3411").digest(clientPassword);

        // Создаем сессионный ключ.
        CryptParamsSpec params = CryptParamsSpec.getInstance();
        SecretKeySpec spec = new SecretKeySpec(hashedPassword, params);
        SecretKey skey = new GostSecretKey(spec);

        /*
        KeyStore store = KeyStore.getInstance("HDImageStore");
        store.load(null, null);

        Certificate cert = store.getCertificate("gost_exch");

        KeyFactory skf = KeyFactory.getInstance("GOST28147");
        SecretKey skey = (SecretKey) skf.translateKey(cert.getPublicKey());
        */

        // Шифруем.
        Cipher cipher = Cipher.getInstance("GOST28147");
        cipher.init(Cipher.ENCRYPT_MODE, skey, new IvParameterSpec(iv));
        final byte[] encryptedtext = cipher.doFinal(data, 0, data.length);

        // Расшифруем.
        cipher = Cipher.getInstance("GOST28147");
        cipher.init(Cipher.DECRYPT_MODE, skey, new IvParameterSpec(iv));
        final byte[] decryptedtext = cipher
                .doFinal(encryptedtext, 0, encryptedtext.length);

        // проверка результата.
        if (decryptedtext.length != data.length)
            throw new Exception("Error in crypting");
        for (int i = 0; i &lt; decryptedtext.length; i++)
            if (data[i] != decryptedtext[i])
                throw new Exception("Error in crypting");

        System.out.println("OK");
    }
}
</java>
<java name="HtmlSign/HtmlSign.java">/**
 * $RCSfile$
 * version $Revision: 36383 $
 * created 13.10.2004 16:58:55 by iva
 * last modified $Date: 2012-05-31 16:29:48 +0400 (Thu, 31 May 2012) $ by $Author: cross $
 *
 * Copyright 2004-2005 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package HtmlSign;

import ru.CryptoPro.JCP.tools.ExpandException;
import ru.CryptoPro.JCP.tools.PropertyExpander;

import javax.swing.*;
import java.applet.Applet;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.Security;
import java.security.Signature;
import java.util.Enumeration;

/**
 * Простой Applet подписи информации.
 * &lt;p/&gt;
 * Если у Вас нет ключа, то для генерации ключа подписи по DSA можно
 * воспользоваться командной строкой: &lt;code&gt; keytool -genkey  -alias dsa -dname
 * CN=test,O=CryptPro,C=RU -keypass 123456 -storepass 123456 -storetype JKS
 * -provider sun.security.provider.Sun &lt;/code&gt; Для проверки наличия ключа в
 * store при подписи по DSA, можно воспользоваться командной строкой: &lt;code&gt;
 * keytool.exe -list -v -alias dsa -storepass 123456 -storetype JKS -provider
 * sun.security.provider.Sun &lt;/code&gt;
 *
 * @author Copyright 2004-2005 Crypto-Pro. All rights reserved.
 * @.Version
 */
public final class HtmlSign extends Applet implements
        ActionListener, ItemListener {
/**
 * Текст для подписи.
 */
private TextArea textToBeSigned;
/**
 * Alias ключа.
 */
private TextField keyAlias;
/**
 * Кнопка выбора alias.
 */
private Button buttonAlias;
/**
 * Пароль на ключ.
 */
private TextField keyPassword;
/**
 * Кнопка подписи.
 */
private Button buttonToSign;
/**
 * Подпись, часть 1.
 */
private Label signatureOne;
/**
 * Подпись, часть 2.
 */
private Label signatureTwo;
/**
 * Имя store.
 */
private Choice storeType;
/**
 * Имя провайдера.
 */
private Choice providerType;
/**
 * Алгоритм подписи.
 */
private Choice signatureType;
/**
 * Имя файла store.
 */
private TextField storeFile;
/**
 * Пароль на store.
 */
private TextField storePassword;
/**
 * Кнопка выбора имени файла со store.
 */
private Button buttonFile;

/**
 * Пустой кончтруктор.
 */
public HtmlSign() {
    mainArgs = new String[0];
}

/**
 * Кончтруктор с доп. параметрами.
 *
 * @param args Параметры командной строки. Задаются в виде &amp;lt;имя параметра&amp;gt;
 * &amp;lt;Значение параметра&amp;gt;
 */
public HtmlSign(String[] args) {
    mainArgs = args;
}

/**
 * Дополнительные параметры, могут быть заданы при старте не через applet.
 */
private final String[] mainArgs;

public String getParameter(String name) {
    String ret = null;
    for (int i = 0; i &lt; mainArgs.length; i += 2) {
        if (name == mainArgs[i] &amp;&amp; i + 1 &lt; mainArgs.length)
            ret = mainArgs[i];
    }
    if (ret == null)
        ret = super.getParameter(name);
    return ret;
}

/**
 * Запуск без Applet.
 *
 * @param args параметры командной строки
 */
public static void main(String[] args) {
    final Frame frame = new Frame("HtmlSign");
    final Applet htmlSign = new HtmlSign(args);
    htmlSign.init();
    frame.add("Center", htmlSign);
    frame.pack();
    frame.setVisible(true);
    frame.addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
            super.windowClosing(e);
            htmlSign.stop();
            htmlSign.destroy();
            frame.setVisible(false);
            frame.dispose();
        }
    });
    htmlSign.start();
}

/**
 * Инициализация Applet.
 */
public void init() {
    super.init();
    setLayout(new BorderLayout());
    final Panel north = new Panel(new GridLayout(4, 1));

    final Panel northProvider = new Panel(new GridLayout(1, 4));
    northProvider.add(new Label("Provider:"));
    providerType = new Choice();
    final Provider[] providers = Security.getProviders();
    for (int i = 0; i &lt; providers.length; i++) {
        providerType.add(providers[i].getName());
    }
    final String defProviderType = getParameter("defProviderType");
    if (defProviderType != null)
        providerType.select(defProviderType);
    providerType.addItemListener(this);
    northProvider.add(providerType);
    northProvider.add(new Label("Signature:"));
    signatureType = new Choice();
    fillByPrefix(providerType.getSelectedItem(), STR_SIGNATURE, signatureType);
    final String defSignatureType = getParameter("defSignatureType");
    if (defSignatureType != null)
        signatureType.select(defSignatureType);
    northProvider.add(signatureType);
    north.add(northProvider);

    final Panel northStore = new Panel(new GridLayout(1, 4));
    northStore.add(new Label("Store:"));
    storeType = new Choice();
    for (int i = 0; i &lt; providers.length; i++) {
        fillByPrefix(providers[i].getName(), STR_KEYSTORE, storeType);
    }
    final String defStoreType = getParameter("defStoreType");
    if (defStoreType != null)
        storeType.select(defStoreType);
    northStore.add(storeType);
    northStore.add(new Label("Store keyPassword"));
    storePassword = new TextField();
    storePassword.setEchoChar('*');
    final String defStorePassword = getParameter("defStorePassword");
    if (defStorePassword != null)
        storePassword.setText(defStorePassword);
    northStore.add(storePassword);
    north.add(northStore);

    final Panel northStoreFile = new Panel(new GridLayout(1, 3));
    northStoreFile.add(new Label("Store file:"));
    storeFile = new TextField();
    String defStoreFile = getParameter("defStoreFile");
    if (defStoreFile != null) {
        try {
            defStoreFile = PropertyExpander.expand(defStoreFile);
        } catch (ExpandException e) {
            // ignore exception;
        }
    }
    if (defStoreFile != null)
        storeFile.setText(defStoreFile);
    northStoreFile.add(storeFile);
    buttonFile = new Button("Select");
    buttonFile.addActionListener(this);
    northStoreFile.add(buttonFile, BorderLayout.SOUTH);
    north.add(northStoreFile);

    final Panel northKey = new Panel(new GridLayout(1, 5));
    northKey.add(new Label("Key keyAlias:"));
    keyAlias = new TextField();
    final String defAlias = getParameter("defAlias");
    if (defAlias != null)
        keyAlias.setText(defAlias);
    northKey.add(keyAlias);
    buttonAlias = new Button("Select");
    buttonAlias.addActionListener(this);
    northKey.add(buttonAlias);
    northKey.add(new Label("Password:"));
    keyPassword = new TextField();
    keyPassword.setEchoChar('*');
    final String defKeyPassword = getParameter("defKeyPassword");
    if (defKeyPassword != null)
        keyPassword.setText(defKeyPassword);
    northKey.add(keyPassword);
    north.add(northKey);

    add(north, BorderLayout.NORTH);

    final Panel center = new Panel(new BorderLayout());
    textToBeSigned = new TextArea("Text to be signed");
    final String defTextToBeSigned = getParameter("defTextToBeSigned");
    if (defTextToBeSigned != null)
        textToBeSigned.setText(defTextToBeSigned);
    center.add(textToBeSigned, BorderLayout.CENTER);
    buttonToSign = new Button("Sign textToBeSigned");
    center.add(buttonToSign, BorderLayout.SOUTH);
    add(center, BorderLayout.CENTER);

    final Panel sourth = new Panel(new GridLayout(3, 1));
    sourth.add(new Label("Signature:"));
    signatureOne = new Label();
    sourth.add(signatureOne);
    signatureTwo = new Label();
    sourth.add(signatureTwo);
    add(sourth, BorderLayout.SOUTH);
    buttonToSign.addActionListener(this);
}

/**
 * Уничтожение Applet.
 */
public void destroy() {
    remove(textToBeSigned);
    remove(keyAlias);
    remove(keyPassword);
    remove(buttonToSign);
    remove(signatureOne);
    remove(signatureTwo);
    remove(storeType);
    remove(storeFile);
    remove(storePassword);
    remove(buttonFile);
    super.destroy();
}

/**
 * Информация об Applet.
 *
 * @return Название Applet
 */
public String getAppletInfo() {
    return "Simple html sign.";
}

private KeyStore load() throws GeneralSecurityException, IOException {
    final String file = storeFile.getText();
    FileInputStream storeStream = null;
    try {
        if (file != null &amp;&amp; file.length() != 0)
            storeStream = new FileInputStream(file);
    } catch (FileNotFoundException e) {
//        showStatus( e.toString() );
    }

    final String type = storeType.getSelectedItem();
    final KeyStore store = KeyStore.getInstance(type);

    final String sPwd = storePassword.getText();
    final char[] sPassword = sPwd.toCharArray();
    store.load(storeStream, sPassword);
    return store;
}

/**
 * Собственно функция подписи.
 *
 * @return подпись
 * @throws GeneralSecurityException Ошибки подписи
 * @throws IOException Ошибки открытия store
 */
private byte[] sign()
        throws GeneralSecurityException, IOException {
    final KeyStore store = load();

    final String pwd = keyPassword.getText();
    final char[] password = pwd.toCharArray();
    final String alias = keyAlias.getText();
    final Key key = store.getKey(alias, password);

    final String provName = providerType.getSelectedItem();
    final Signature signature = Signature.getInstance(
            signatureType.getSelectedItem(),
            provName);
    signature.initSign((PrivateKey) key);
    final String txt = textToBeSigned.getText();
    final byte[] info = txt.getBytes();
    signature.update(info);
    return signature.sign();
}

/**
 * Показ диалога о возникновении exception.
 *
 * @param e exception
 */
private void showExceptionDialog(Exception e) {
    final ByteArrayOutputStream os = new ByteArrayOutputStream();
    final PrintStream ps = new PrintStream(os);
    e.printStackTrace(ps);
    final String msg = os.toString();
    JOptionPane.showMessageDialog(this, msg,
            GeneralSecurityException.class.toString(),
            JOptionPane.ERROR_MESSAGE);
}

/**
 * Таблица перекодировки в 16-ричное представление. Не используем классы из
 * JCP.
 */
private static final char[] hex_digits = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

/**
 * Функция перевода массива байт в строковое 16-ричное представление.
 *
 * @param array массив
 * @return строковое 16-ричное представление
 */
private static String toHexSequence(byte[] array) {
    int i;
    String s = "";
    for (i = 0; i &lt; array.length; i++) {
        s += hex_digits[(array[i] &gt;&gt;&gt; 4) &amp; 0xf];
        s += hex_digits[array[i] &amp; 0xf];
    }
    return s;
}

/**
 * Реакция на нажатие кнопки. Выдача диалогового окна для выбора файла store и
 * подпись текста
 *
 * @param event сообщение
 */
public void actionPerformed(ActionEvent event) {
    final Object source = event.getSource();
    if (source == buttonToSign) {
        try {
            final byte[] res = sign();
            final String sign = toHexSequence(res);
            final int l = sign.length() / 2;
            signatureOne.setText(sign.substring(0, l));
            signatureTwo.setText(sign.substring(l));
            Font dfont = signatureOne.getFont();
            Font f = new Font("Monospaced", Font.PLAIN, dfont.getSize());
            signatureOne.setFont(f);
            signatureTwo.setFont(f);
        } catch (GeneralSecurityException e) {
            showExceptionDialog(e);
        } catch (IOException e) {
            showExceptionDialog(e);
        } catch (SecurityException e) {
            showExceptionDialog(e);
        }
    }
    if (source == buttonFile) {
        try {
            final JFileChooser chooser = new JFileChooser();
            chooser.setSelectedFile(new File(storeFile.getText()));
            final int retval = chooser.showDialog(this, null);
            if (retval == JFileChooser.APPROVE_OPTION) {
                final File theFile = chooser.getSelectedFile();
                storeFile.setText(theFile.getAbsolutePath());
            }
        } catch (SecurityException e) {
            showExceptionDialog(e);
        }
    }
    if (source == buttonAlias) {
        Enumeration en;
        int size;
        try {
            final KeyStore store = load();
            en = store.aliases();
            size = store.size();
        } catch (SecurityException e) {
            showExceptionDialog(e);
            return;
        } catch (GeneralSecurityException e) {
            showExceptionDialog(e);
            return;
        } catch (IOException e) {
            showExceptionDialog(e);
            return;
        }
        Object[] possibilities = new String[size];
        int i = 0;
        while (en.hasMoreElements())
            possibilities[i++] = en.nextElement();
        String s = (String) JOptionPane.showInputDialog(this,
                "Select avaiable aliase:",
                "Alias Chooser",
                JOptionPane.PLAIN_MESSAGE,
                null,
                possibilities,
                keyAlias.getText());
        if (s != null &amp;&amp; s.length() &gt; 0)
            keyAlias.setText(s);
    }
}

/**
 * Префикс для KeyStore в Property Provider.
 */
private static final String STR_KEYSTORE = "KeyStore.";

/**
 * Префикс для алгоритма подписи в Property Provider.
 */
private static final String STR_SIGNATURE = "Signature.";

/**
 * Заполнение Choice из Provider Properties по prefix.
 *
 * @param provider Имя провайдера
 * @param prefix префикс для заполнения
 * @param choice заполняемый choice
 */
private static void fillByPrefix(String provider, String prefix, Choice choice) {
    final Provider p = Security.getProvider(provider);
    final Enumeration en = p.keys();
    final int sl = prefix.length();
    while (en.hasMoreElements()) {
        final String prop = (String) en.nextElement();
        final String start = prop.substring(0, sl);
        if (start.equalsIgnoreCase(prefix) &amp;&amp;
                prop.indexOf(" ") &lt; 0)
            choice.add(prop.substring(sl));
    }
}

/**
 * Реакция на изменение элемента choice. Перечитывание списка алгоритмов.
 *
 * @param event событие
 */
public void itemStateChanged(ItemEvent event) {
    final Object source = event.getSource();
    if (source == providerType) {
        signatureType.removeAll();
        fillByPrefix(providerType.getSelectedItem(), STR_SIGNATURE,
                signatureType);
    }
}
}
</java>
<java name="JCPxml/dsig/internal/utility/SpecUtility.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package JCPxml.dsig.internal.utility;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.Properties;
import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;

/**
 * Class with auxiliary functions.
 */
public class SpecUtility {
	
	// All properties
	private static Properties props = new Properties();
	// Default properties. Alternative configuration is wss40 (+ our own variables related to
	// WSS4J files in /keys directory: 'wss40' is valid, 'wss40rev' is revoked)
	public static final String DEFAULT_CRYPTO_PROPERTIES =  System.getProperty("user.dir") +
            "/resources/crypto.properties";

	public static String DEFAULT_STORETYPE = "HDImageStore";
	public static String DEFAULT_KEYSTORE = null;
	public static String DEFAULT_ALIAS = null;
	public static char[] DEFAULT_PASSWORD = null;
	public static String DEFAULT_CERT_FILE = null;
	public static String DEFAULT_CA_FILE = null;
	public static String DEFAULT_CRL_FILE = null;
	
	// Load all settings from crypto.properties
	static {
		
		try {
			
			props.load(new FileInputStream(DEFAULT_CRYPTO_PROPERTIES));
			
			// Standard WSS4J variables
			DEFAULT_STORETYPE = props.getProperty("org.apache.ws.security.crypto.merlin.keystore.type");
			DEFAULT_KEYSTORE = props.getProperty("org.apache.ws.security.crypto.merlin.file");
			DEFAULT_ALIAS = props.getProperty("org.apache.ws.security.crypto.merlin.keystore.alias");
			
			String password = props.getProperty("org.apache.ws.security.crypto.merlin.keystore.password");
			if (password != null) {
				DEFAULT_PASSWORD = password.toCharArray();
			}
			
			// Our own variables
			DEFAULT_CERT_FILE = props.getProperty("cert.file");
			DEFAULT_CA_FILE = props.getProperty("ca.file");
			DEFAULT_CRL_FILE = props.getProperty("crl.file");

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
		
	/**
	 * Functions initializes XML JCP.
	 */
	public static void initJCP() {
		
		if(!JCPXMLDSigInit.isInitialized())
    		JCPXMLDSigInit.init();
		
		System.setProperty("com.ibm.security.enableCRLDP", "false");
	}

	/**
	 * Function loads store information from key store.
	 * @param storeType - type of key store (HDImageStore, JKS, PKCS12).
	 * @param store - store file.
	 * @param storePassword - password to store.
	 * @return loaded key store.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public static KeyStore loadKeyStore( String storeType, File store, char[] storePassword ) 
	throws KeyStoreException, NoSuchAlgorithmException, CertificateException, 
		FileNotFoundException, IOException {

		KeyStore keyStore = KeyStore.getInstance(storeType);
		FileInputStream inputStream = null;

		if (store != null)
			inputStream = new FileInputStream(store);

		keyStore.load( keyStore == null ? null : inputStream, storePassword );
		return keyStore;		 
	}
}
</java>
<java name="JCPxml/dsig/internal/xmldsigri/tests/GenDetached.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package JCPxml.dsig.internal.xmldsigri.tests;

import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.*;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.security.*;
import java.util.Collections;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;

/**
 * This is a simple example of generating a Detached XML 
 * Signature using the JSR 105 API. The resulting signature will look 
 * like (key and signature values will be different):
 *
 * &lt;pre&gt;&lt;code&gt;
 * &lt;Signature xmlns="http://www.w3.org/2000/09/xmldsig#"&gt;
 *   &lt;SignedInfo&gt;
 *     &lt;CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments" /&gt;
 *     &lt;SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411" /&gt;
 *     &lt;Reference URI="http://www.w3.org/TR/xml-stylesheet"&gt;
 *       &lt;DigestMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#gostr3411" /&gt;
 *       &lt;DigestValue&gt;0Eys/LMpFXPyKVArIbEtLbKVhG4M4+t10J12it8vFl8=&lt;/DigestValue&gt;
 *     &lt;/Reference&gt;
 *   &lt;/SignedInfo&gt;
 *   &lt;SignatureValue&gt;
 *     AnJqyBwAqq7cVO5kVB2/V39OtcQEBPDOrS0814bFApbe5kWurC1wscuRoPqoW3LynSzJrRq4Idon
 *     lQkYvDclLw==
 *   &lt;/SignatureValue&gt;
 *   &lt;KeyInfo&gt;
 *     &lt;KeyValue&gt;
 *       &lt;GOSTKeyValue&gt;
 *         MGMwHAYGKoUDAgITMBIGByqFAwICIwEGByqFAwICHgEDQwAEQOHLeJqnkLtl9JYeyfbStAwFVci5
 *         TUMy40Uucx1+ce+7UFr2p53t9onUeCLp/zixauWlIaU5TBHXPNcKYNbdoxI=
 *       &lt;/GOSTKeyValue&gt;
 *     &lt;/KeyValue&gt;
 *   &lt;/KeyInfo&gt;
 * &lt;/Signature&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 */
public class GenDetached {
	 
    //
    // Synopsis: java GenDetached [output]
    //
    // where output is the name of the file that will contain the detached
    // signature. If not specified, standard output is used.
    //
    public static void main(String[] args) throws Exception {

    	System.out.println("###### Test GenDetached is begun ######");
    	
    	com.sun.org.apache.xml.internal.security.Init.init();
    
    	// Loading of CryptoPro XMLDSigRI service provider
    	Provider pxml = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();
    	
    	// First, create a DOM XMLSignatureFactory that will be used to 
    	// generate the XMLSignature and marshal it to DOM.
    	XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", pxml);
	
    	// Create a Reference to an external URI that will be digested
    	// using the GOST3411 digest algorithm
    	Reference ref = fac.newReference("http://www.w3.org/TR/xml-stylesheet", 
    			fac.newDigestMethod(ru.CryptoPro.JCPxml.Consts.URI_GOST_DIGEST, null));

    	// Create the SignedInfo
    	SignedInfo si = fac.newSignedInfo(fac.newCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS, 
    			(C14NMethodParameterSpec) null), fac.newSignatureMethod(ru.CryptoPro.JCPxml.Consts.URI_GOST_SIGN, null),
    						Collections.singletonList(ref));

		// Create a GOST KeyPair
		KeyPairGenerator kpg = KeyPairGenerator.getInstance("GOST3410EPH");
		KeyPair kp = kpg.generateKeyPair();
	
		// Create a KeyValue containing the GOST PublicKey that was generated
		KeyInfoFactory kif = fac.getKeyInfoFactory();
		KeyValue kv = kif.newKeyValue(kp.getPublic());
	
    	// Create a KeyInfo and add the KeyValue to it
    	KeyInfo ki = kif.newKeyInfo(Collections.singletonList(kv));

    	// Create the XMLSignature (but don't sign it yet)
    	XMLSignature signature = fac.newXMLSignature(si, ki);

    	// Create the Document that will hold the resulting XMLSignature
    	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    	dbf.setNamespaceAware(true); // must be set
    	Document doc = dbf.newDocumentBuilder().newDocument();

    	/* 
    	// May be used as root element. Look to URI of element 'ref'. Second parameter of DOMSignContext
    	// is rootElement. 
		Element rootElement = doc.createElement("SANTA");
		rootElement.setTextContent("Ho-ho-ho");
		doc.appendChild(rootElement);
    	 */
	
    	// Create a DOMSignContext and set the signing Key to the GOST 
    	// PrivateKey and specify where the XMLSignature should be inserted 
    	// in the target document (in this case, the document root)
    	DOMSignContext signContext = new DOMSignContext(kp.getPrivate(), doc);
	
    	// Marshal, generate (and sign) the detached XMLSignature. The DOM 
    	// Document will contain the XML Signature if this method returns 
    	// successfully.
    	signature.sign(signContext);

    	// output the resulting document
    	OutputStream os;
    	//if (args.length &gt; 0) {
    		os = new FileOutputStream(/*args[0]*/"C:\\signed.xml");
    	//} else { 
    	//	os = System.out;
    	//}
	
    	TransformerFactory tf = TransformerFactory.newInstance();
    	Transformer trans = tf.newTransformer();
    	trans.transform(new DOMSource(doc), new StreamResult(os));
    	
    	System.out.println("###### Test GenDetached is finished ######");
    }
}
</java>
<java name="JCPxml/dsig/internal/xmldsigri/tests/GenDetachedByCert.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package JCPxml.dsig.internal.xmldsigri.tests;

import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.*;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.*;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Collections;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import JCPxml.dsig.internal.utility.SpecUtility;

/**
 * This is a simple example of generating a Detached XML 
 * Signature using the JSR 105 API. The resulting signature will look 
 * like (key and signature values will be different):
 *
 * &lt;pre&gt;&lt;code&gt;
 * &lt;Signature xmlns="http://www.w3.org/2000/09/xmldsig#"&gt;
 *   &lt;SignedInfo&gt;
 *     &lt;CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments" /&gt;
 *     &lt;SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411" /&gt;
 *     &lt;Reference URI="http://www.w3.org/TR/xml-stylesheet"&gt;
 *       &lt;DigestMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#gostr3411" /&gt;
 *       &lt;DigestValue&gt;0Eys/LMpFXPyKVArIbEtLbKVhG4M4+t10J12it8vFl8=&lt;/DigestValue&gt;
 *     &lt;/Reference&gt;
 *   &lt;/SignedInfo&gt;
 *   &lt;SignatureValue&gt;
 *     azKP+ZHtjuH3uTrjqNfYUy9h4ebrzSSE0q6XI7mhB3j1NgNFVfJMpzmIqByDymd/j9qAzfmn5vj4
 *     0yyBrXtLqw==
 *   &lt;/SignatureValue&gt;
 *   &lt;KeyInfo&gt;
 *     &lt;X509Data&gt;
 *       &lt;X509Certificate&gt;
 *	        MIIC4zCCApKgAwIBAgIKFVWsWwACAAGNCjAIBgYqhQMCAgMwZTEgMB4GCSqGSIb3DQEJARYRaW5m
 *			b0BjcnlwdG9wcm8ucnUxCzAJBgNVBAYTAlJVMRMwEQYDVQQKEwpDUllQVE8tUFJPMR8wHQYDVQQD
 *			ExZUZXN0IENlbnRlciBDUllQVE8tUFJPMB4XDTExMTAyODE2NDM1NFoXDTE0MTAwNDA3MDk0MVow
 *			NzELMAkGA1UEBhMCUlUxEjAQBgNVBAoTCUNyeXB0b1BybzEUMBIGA1UEAwwLYWZldm1hX2dvc3Qw
 *			YzAcBgYqhQMCAhMwEgYHKoUDAgIjAQYHKoUDAgIeAQNDAARArdmGxyoSVperAUc6d0TiGnC9ilgi
 *			C+EPxul3htCFdQ/zQ7z7vPX9/3Xt/Lfb+lzVhlRU4W00B5CTKrseoziFaaOCAU4wggFKMA4GA1Ud
 *			DwEB/wQEAwIGwDAdBgNVHQ4EFgQULv5fF45Y2vgOHFnY60i0UFWrW8UwHwYDVR0jBBgwFoAUbY9e
 *			BdlfrJEXlB6VmgUwODd6ECowVQYDVR0fBE4wTDBKoEigRoZEaHR0cDovL3d3dy5jcnlwdG9wcm8u
 *			cnUvQ2VydEVucm9sbC9UZXN0JTIwQ2VudGVyJTIwQ1JZUFRPLVBSTygyKS5jcmwwgaAGCCsGAQUF
 *			BwEBBIGTMIGQMDMGCCsGAQUFBzABhidodHRwOi8vd3d3LmNyeXB0b3Byby5ydS9vY3NwbmMvb2Nz
 *			cC5zcmYwWQYIKwYBBQUHMAKGTWh0dHA6Ly93d3cuY3J5cHRvcHJvLnJ1L0NlcnRFbnJvbGwvcGtp
 *			LXNpdGVfVGVzdCUyMENlbnRlciUyMENSWVBUTy1QUk8oMikuY3J0MAgGBiqFAwICAwNBAAtCRkEv
 *			I9yqSy4xWNO3+ektITt0kPNCbc9b76j5qy44hO694/OJBBsP1cjr7eRfFemzhVkAuKm1NiCWWmUt
 *			sgk=
 *       &lt;/X509Certificate&gt;
 *     &lt;/X509Data&gt;
 *   &lt;/KeyInfo&gt;
 * &lt;/Signature&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 */
public class GenDetachedByCert {
	
    //
    // Synopsis: java GenDetachedByCert [output]
    //
    // where output is the name of the file that will contain the detached
    // signature. If not specified, standard output is used.
    //
    public static void main(String[] args) throws Exception {

    	System.out.println("###### Test GenDetachedByCert is begun ######");
    	
    	com.sun.org.apache.xml.internal.security.Init.init();
    
    	// Loading of CryptoPro XMLDSigRI service provider
    	Provider pxml = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();
    	
    	// First, create a DOM XMLSignatureFactory that will be used to 
    	// generate the XMLSignature and marshal it to DOM.
    	XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", pxml);
	
    	// Create a Reference to an external URI that will be digested
    	// using the GOST3411 digest algorithm
    	Reference ref = fac.newReference("http://www.w3.org/TR/xml-stylesheet"/*"#Buu"*/, 
    			fac.newDigestMethod(ru.CryptoPro.JCPxml.Consts.URI_GOST_DIGEST, null));

    	// Create the SignedInfo
    	SignedInfo si = fac.newSignedInfo(fac.newCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS, 
    		(C14NMethodParameterSpec) null), fac.newSignatureMethod(ru.CryptoPro.JCPxml.Consts.URI_GOST_SIGN, null),
    					Collections.singletonList(ref));

    	// Loading certificate from file
    	FileInputStream certStream = null;
		if (SpecUtility.DEFAULT_CERT_FILE != null) {
			certStream = new FileInputStream( new File(SpecUtility.DEFAULT_CERT_FILE) );
		}
		else {
			throw new IOException("Default certificate file is not found.");
		}
		
    	CertificateFactory factory = CertificateFactory.getInstance("X509");
    	X509Certificate clientCertificate = (X509Certificate)factory.generateCertificate( certStream );
	
    	// Preparing X509Data element 
    	KeyInfoFactory kif = fac.getKeyInfoFactory();
    	X509Data x509d = kif.newX509Data(Collections.singletonList(clientCertificate));
	
    	// Loading private key from store
    	KeyStore keyStore = SpecUtility.loadKeyStore(SpecUtility.DEFAULT_STORETYPE, null, 
    			SpecUtility.DEFAULT_PASSWORD);
    	PrivateKey privateKey = (PrivateKey) keyStore.getKey(SpecUtility.DEFAULT_ALIAS, 
    			SpecUtility.DEFAULT_PASSWORD);
	
    	// Create a KeyInfo and add the KeyValue to it
    	KeyInfo ki = kif.newKeyInfo(Collections.singletonList(x509d));

    	// Create the XMLSignature (but don't sign it yet)
    	XMLSignature signature = fac.newXMLSignature(si, ki);

    	// Create the Document that will hold the resulting XMLSignature
    	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    	dbf.setNamespaceAware(true); // must be set
    	Document doc = dbf.newDocumentBuilder()./*parse("C:\\doc.xml");*/newDocument();

    	/* 
    	// May be used as root element. Look to URI of element 'ref'. Second parameter of DOMSignContext
    	// is rootElement.
		Element rootElement = doc.createElement("SANTA");
		rootElement.setTextContent("Ho-ho-ho");
		doc.appendChild(rootElement);
    	*/
    	Element rootElement = doc.getDocumentElement();
	
    	// Create a DOMSignContext and set the signing Key to the DSA/GOST 
    	// PrivateKey and specify where the XMLSignature should be inserted 
    	// in the target document (in this case, the document root)
    	DOMSignContext signContext = new DOMSignContext(privateKey, rootElement);
	
    	// Marshal, generate (and sign) the detached XMLSignature. The DOM 
    	// Document will contain the XML Signature if this method returns 
    	// successfully.
    	signature.sign(signContext);

    	// output the resulting document
    	OutputStream os;
    	//if (args.length &gt; 0) {
    		os = new FileOutputStream(/*args[0]*/"C:\\signed_cert.xml");
    	//} else { 
    	//	os = System.out;
    	//}
	
    	TransformerFactory tf = TransformerFactory.newInstance();
    	Transformer trans = tf.newTransformer();
    	trans.transform(new DOMSource(doc), new StreamResult(os));
    	
    	System.out.println("###### Test GenDetachedByCert is finished ######");
    }
}
</java>
<java name="JCPxml/dsig/internal/xmldsigri/tests/Validate.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package JCPxml.dsig.internal.xmldsigri.tests;

import javax.xml.crypto.*;
import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.*;
import java.io.FileInputStream;
import java.security.*;
import java.util.Iterator;
import java.util.List;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;


/**
 * This is a simple example of validating an XML 
 * Signature using the JSR 105 API. It assumes the key needed to
 * validate the signature is contained in a KeyValue KeyInfo. 
 */
public class Validate {

    //
    // Synopsis: java Validate [document]
    //
    //	  where "document" is the name of a file containing the XML document
    //	  to be validated.
    //
    public static void main(String[] args) throws Exception {

    System.out.println("###### Test Validate is begun ######");
    	
	// Instantiate the document to be validated
	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
	dbf.setNamespaceAware(true);
	Document doc =
            dbf.newDocumentBuilder().parse(new FileInputStream(/*args[0]*/"C:\\signed.xml"));

	// Find Signature element
	NodeList nl = 
	    doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");
	if (nl.getLength() == 0) {
	    throw new Exception("Cannot find Signature element");
	}
	
	com.sun.org.apache.xml.internal.security.Init.init();
	
    Provider pxml = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();

	// Create a DOM XMLSignatureFactory that will be used to unmarshal the 
	// document containing the XMLSignature 
	XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", pxml);

	// Create a DOMValidateContext and specify a KeyValue KeySelector
        // and document context
	DOMValidateContext valContext = new DOMValidateContext
	    (new KeyValueKeySelector(), nl.item(0));
	
	// unmarshal the XMLSignature
	XMLSignature signature = fac.unmarshalXMLSignature(valContext);

	// Validate the XMLSignature (generated above)
	boolean coreValidity = signature.validate(valContext); 

	// Check core validation status
	if (coreValidity == false) {
    	    System.err.println("Signature failed core validation"); 
	    boolean sv = signature.getSignatureValue().validate(valContext);
	    System.out.println("signature validation status: " + sv);
	    // check the validation status of each Reference
	    Iterator i = signature.getSignedInfo().getReferences().iterator();
	    for (int j = 0; i.hasNext(); j++) {
		boolean refValid = 
		    ((Reference) i.next()).validate(valContext);
		System.out.println("ref[" + j + "] validity status: " + refValid);
	    }
	} else {
    	    System.out.println("Signature passed core validation");
	}
	
	System.out.println("###### Test Validate is finished ######");
	
    }
    
    /**
     * KeySelector which retrieves the public key out of the
     * KeyValue element and returns it.
     * NOTE: If the key algorithm doesn't match signature algorithm,
     * then the public key will be ignored.
     */
    private static class KeyValueKeySelector extends KeySelector {
	public KeySelectorResult select(KeyInfo keyInfo,
                                        KeySelector.Purpose purpose,
                                        AlgorithmMethod method,
                                        XMLCryptoContext context)
            throws KeySelectorException {
            if (keyInfo == null) {
		throw new KeySelectorException("Null KeyInfo object!");
            }
            SignatureMethod sm = (SignatureMethod) method;
            List list = keyInfo.getContent();

            for (int i = 0; i &lt; list.size(); i++) {
            	XMLStructure xmlStructure = (XMLStructure) list.get(i);
            	if (xmlStructure instanceof KeyValue) {
                    PublicKey pk = null;
                    try {
                        pk = ((KeyValue)xmlStructure).getPublicKey();
                    } catch (KeyException ke) {
                        throw new KeySelectorException(ke);
                    }
                    // make sure algorithm is compatible with method
                    if (algEquals(sm.getAlgorithm(), pk.getAlgorithm())) {
                        return new SimpleKeySelectorResult(pk);
                    }
            	}
            }
            throw new KeySelectorException("No KeyValue element found!");
	}

        //@@@FIXME: this should also work for key types other than GOST3410
	static boolean algEquals(String algURI, String algName) {
            if (algName.equalsIgnoreCase("DSA") &amp;&amp;
            		algURI.equalsIgnoreCase(SignatureMethod.DSA_SHA1)) {
            	return true;
            } else if (algName.equalsIgnoreCase("RSA") &amp;&amp;
                       algURI.equalsIgnoreCase(SignatureMethod.RSA_SHA1)) {
            	return true;
            } 
            else if (algName.equalsIgnoreCase("GOST3410") &amp;&amp;
                    algURI.equalsIgnoreCase(ru.CryptoPro.JCPxml.Consts.URI_GOST_SIGN)) {
            	return true;
            }
            else {
            	return false;
            }
		}
    }

    private static class SimpleKeySelectorResult implements KeySelectorResult {
    	private PublicKey pk;
    	
    	SimpleKeySelectorResult(PublicKey pk) {
    		this.pk = pk;
    	}

    	public Key getKey() { 
    		return pk; 
    	}
    }
}
</java>
<java name="JCPxml/dsig/internal/xmldsigri/tests/ValidateByCert.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package JCPxml.dsig.internal.xmldsigri.tests;

import javax.xml.crypto.*;
import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.*;

import java.io.FileInputStream;
import java.security.*;
import java.security.cert.X509Certificate;
import java.util.Iterator;
import java.util.List;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import ru.CryptoPro.JCPxml.Consts;

/**
 * This is a simple example of validating an XML 
 * Signature using the JSR 105 API. It assumes the key needed to
 * validate the signature is contained in a KeyValue KeyInfo. 
 */
public class ValidateByCert {

    //
    // Synopsis: java ValidateByCert [document]
    //
    //	  where "document" is the name of a file containing the XML document
    //	  to be validated.
    //
    public static void main(String[] args) throws Exception {

    System.out.println("###### Test ValidateByCert is begun ######");
    	
	// Instantiate the document to be validated
	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
	dbf.setNamespaceAware(true);
	Document doc =
            dbf.newDocumentBuilder().parse(new FileInputStream(/*args[0]*/"" +
                    /*"C:\\signed_cert.xml"*/
            "c:\\TESTS\\User\\gerasimenko\\singed-4481167995637542322.xml"));

	// Find Signature element
	NodeList nl = 
	    doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");
	if (nl.getLength() == 0) {
	    throw new Exception("Cannot find Signature element");
	}
	
	com.sun.org.apache.xml.internal.security.Init.init();
	
    Provider pxml = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();

	// Create a DOM XMLSignatureFactory that will be used to unmarshal the 
	// document containing the XMLSignature 
	XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", pxml);

	// Create a DOMValidateContext and specify a KeyValue KeySelector
        // and document context
	DOMValidateContext valContext = new DOMValidateContext
	    (new X509CertificateSelector(), nl.item(0));
	
	// unmarshal the XMLSignature
	XMLSignature signature = fac.unmarshalXMLSignature(valContext);

	// Validate the XMLSignature (generated above)
	boolean coreValidity = signature.validate(valContext); 

	// Check core validation status
	if (coreValidity == false) {
    	    System.err.println("Signature failed core validation"); 
	    boolean sv = signature.getSignatureValue().validate(valContext);
	    System.out.println("signature validation status: " + sv);
	    // check the validation status of each Reference
	    Iterator i = signature.getSignedInfo().getReferences().iterator();
	    for (int j = 0; i.hasNext(); j++) {
		boolean refValid = 
		    ((Reference) i.next()).validate(valContext);
		System.out.println("ref[" + j + "] validity status: " + refValid);
	    }
	} else {
    	    System.out.println("Signature passed core validation");
	}
	
	System.out.println("###### Test ValidateByCert is finished ######");
	
    }
    
    /**
     * X509CertificateSelector which retrieves the public key out of the
     * X509Certificate(X509Data) element and returns it.
     * NOTE: If the key algorithm doesn't match signature algorithm,
     * then the public key will be ignored.
     */
    private static class X509CertificateSelector extends KeySelector {
	public KeySelectorResult select(KeyInfo keyInfo,
                                        KeySelector.Purpose purpose,
                                        AlgorithmMethod method,
                                        XMLCryptoContext context)
            throws KeySelectorException {
            if (keyInfo == null) {
		throw new KeySelectorException("Null KeyInfo object!");
            }
            SignatureMethod sm = (SignatureMethod) method;
            List list = keyInfo.getContent();

            for (int i = 0; i &lt; list.size(); i++) {
            	XMLStructure xmlStructure = (XMLStructure) list.get(i);
            	if (xmlStructure instanceof X509Data) {
                    X509Data data = (X509Data)xmlStructure;
                    X509Certificate cert = (X509Certificate) data.getContent().get(0);
            		PublicKey pk = cert.getPublicKey();
                    // make sure algorithm is compatible with method
                    if (algEquals(sm.getAlgorithm(), pk.getAlgorithm())) {
                        System.out.println("Verify by certificate #" + cert.getSerialNumber().toString(16)
                            + " " + cert.getSubjectDN());
                        return new SimpleKeySelectorResult(pk);
                    }
            	}
            }
            throw new KeySelectorException("No KeyValue element found!");
	}

        //@@@FIXME: this should also work for key types other than GOST3410
	static boolean algEquals(String algURI, String algName) {
            if (algName.equalsIgnoreCase("DSA") &amp;&amp;
            		algURI.equalsIgnoreCase(SignatureMethod.DSA_SHA1)) {
            	return true;
            } else if (algName.equalsIgnoreCase("RSA") &amp;&amp;
                       algURI.equalsIgnoreCase(SignatureMethod.RSA_SHA1)) {
            	return true;
            } 
            else if (algName.equalsIgnoreCase("GOST3410") &amp;&amp;
                    (algURI.equalsIgnoreCase(ru.CryptoPro.JCPxml.Consts.URI_GOST_SIGN) ||
                     algURI.equalsIgnoreCase(ru.CryptoPro.JCPxml.Consts.URN_GOST_SIGN)
                    )) {
            	return true;
            }
            else {
            	return false;
            }
		}
    }

    private static class SimpleKeySelectorResult implements KeySelectorResult {
    	private PublicKey pk;
    	
    	SimpleKeySelectorResult(PublicKey pk) {
    		this.pk = pk;
    	}

    	public Key getKey() { 
    		return pk; 
    	}
    }
}
</java>
<java name="JTLS_samples/ApacheHttpClient4XExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package JTLS_samples;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import java.io.*;
import java.security.KeyStore;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 17.08.12
 * Time: 20:44
 * To change this template use File | Settings | File Templates.
 */

/**
 * Пример использования apache http client 4.x и JTLS.
 * Если вы используете соединение с двухсторонней аутентификацией, то ключ клиента
 * должен(!) находиться в папке контейнеров JCP (иначе ошибка 403).
 */
public class ApacheHttpClient4XExample {

    /**
     * Адрес для подключения.
     */
    private String connectionAddress = null;
    /**
     * Защищенный контекст соединения.
     */
    private  SSLContext sslContext = null;
    /**
     * Хранилище с доверенным корнем сертификатом. Требуется при обоих видах соединений (двухстороннем
     * и одностороннем).
     */
    private static final String TRUST_STORE = System.getProperty("user.dir") + "/data/external_ca/CATrustStore";
    /**
     * Пароль для доступа к хранилищу с доверенным корневым сертификатом. Требуется при обоих видах
     * соединений (двухстороннем и одностороннем).
     */
    private static final char[] TRUST_STORE_PASSWORD = "1".toCharArray();
    /**
     * Пароль для доступа к контейнеру с ключом для клиента при двухсторонней аутентификации.
     */
    private static final char[] KEY_STORE_PASSWORD = "1".toCharArray();
    /**
     * Порт соединения.
     */
    private int sslPort = 443;
    /**
     * Нужно проверить соответствие CN сертификата адресу хоста.
     */
    private boolean allowAllHostnameVerifier = false;
    /**
     * Фабрика.
     */
    private SSLSocketFactory socketFactory = null;
    /**
     * Таймаут ожидания чтения/записи.
     */
    private int readWriteTimeout = 60 * 10 * 1000;

    /**
     * Конструктор. Выполняет создание SSL контекста.
     *
     * @param url - Адрес для соединения.
     * @param port - Номер порта.
     * @param clientAuth - True, если требуется двухсторонная аутентификация.
     */
    public ApacheHttpClient4XExample(String url, int port, boolean clientAuth) {
        this(url, port, clientAuth, false);
    }

    /**
     * Конструктор. Выполняет создание SSL контекста.
     *
     * @param url - Адрес для соединения.
     * @param port - Номер порта.
     * @param clientAuth - True, если требуется двухсторонная аутентификация.
     * @param allowAllHostnameVerifier - True, если нужно проверить соответствие
     * CN сертификата адресу хоста.
     */
    public ApacheHttpClient4XExample(String url, int port, boolean clientAuth,
        boolean allowAllHostnameVerifier) {

        connectionAddress = url;
        sslPort = port;
        this.allowAllHostnameVerifier = allowAllHostnameVerifier;

        try {

            KeyStore ts = KeyStore.getInstance("HDImageStore");
            ts.load(new FileInputStream(TRUST_STORE), TRUST_STORE_PASSWORD);

            KeyManagerFactory kmf = KeyManagerFactory.getInstance("GostX509");

            if (clientAuth) {

                KeyStore ks = KeyStore.getInstance("HDImageStore");
                ks.load(null, null);

                kmf.init(ks, KEY_STORE_PASSWORD);
            }

            TrustManagerFactory tmf = TrustManagerFactory.getInstance("GostX509");
            tmf.init(ts);

            sslContext = SSLContext.getInstance("GostTLS");
            sslContext.init( clientAuth ? kmf.getKeyManagers() : null, tmf.getTrustManagers(), null );

            init();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Конструктор.
     *
     * @param url - Адрес для соединения.
     * @param port - Номер порта.
     * @param context - SSL контекст соединения.
     * @param allowAllHostnameVerifier - True, если нужно проверить соответствие
     * CN сертификата адресу хоста.
     */
    public ApacheHttpClient4XExample(String url, int port, SSLContext context,
        boolean allowAllHostnameVerifier) {

        connectionAddress = url;
        sslPort = port;
        sslContext = context;
        this.allowAllHostnameVerifier = allowAllHostnameVerifier;

        init();

    }

    /**
     * Инициализация фабрики сокетов.
     */
    private void init() {

        socketFactory = allowAllHostnameVerifier
            ? new SSLSocketFactory(sslContext, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)
            : new SSLSocketFactory(sslContext);
    }

    /**
     * Задание таймаута ожидания чтения/записи.
     *
     * @param timeout Время в мсек.
     */
    public void setTimeout(int timeout) {
        readWriteTimeout = timeout;
    }

    /**
     * Запуск примера.
     *
     * @param outputStream - Поток для сохранения вывода. Если null, то сохранять не надо.
     * @throws Exception
     */
    public void execute(OutputStream outputStream) throws Exception {

        // Регистрируем HTTPS схему.
        Scheme httpsScheme = new Scheme("https", sslPort, socketFactory);
        SchemeRegistry schemeRegistry = new SchemeRegistry();
        schemeRegistry.register(httpsScheme);

        // Параметры соединения.
        HttpParams params = new BasicHttpParams();
        HttpConnectionParams.setSoTimeout(params, readWriteTimeout);
        ClientConnectionManager cm = new SingleClientConnManager(params, schemeRegistry);
        HttpClient httpClient = new DefaultHttpClient(cm, params);

        // GET-запрос.
        HttpGet httpget = new HttpGet(connectionAddress);
        HttpResponse response = httpClient.execute(httpget);
        HttpEntity entity = response.getEntity();

        System.out.println("----------------------------------------");
        System.out.println(response.getStatusLine());

        int status = response.getStatusLine().getStatusCode();
        if (status  != 200) {
            throw new Exception("Bad http response status " + status);
        }

        if (entity != null &amp;&amp; outputStream != null) {

            // Получаем размер заголовка.
            InputStream is = entity.getContent();

            BufferedReader in = new BufferedReader(new InputStreamReader(is));
            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outputStream));

            // Выводим ответ.
            String line;
            while((line = in.readLine()) != null) {
                out.write(line);
            }

            out.flush();
        }

        EntityUtils.consume(entity);
        httpClient.getConnectionManager().shutdown();
    }

    public static void main(String[] args) throws Exception {

        FileOutputStream fOutFile = new FileOutputStream(System.getProperty("user.dir") + "/temp/index.html.en");

        // Пример подключения без аутентификации клиента (односторонняя аутентификация)
        ApacheHttpClient4XExample example =
            new ApacheHttpClient4XExample("https://ref-x86-xp/index.html.en", 443, false);
        example.execute(fOutFile);

        fOutFile.close();

        fOutFile = new FileOutputStream(System.getProperty("user.dir") + "/temp/auth.htm");

        // Пример подключения с аутентификацией клиента (двухсторонняя аутентификация)
        ApacheHttpClient4XExample exampleClientAuth =
                new ApacheHttpClient4XExample("https://ref-x86-xp/auth.htm", 443, true);
        exampleClientAuth.execute(fOutFile);

        fOutFile.close();
    }

}
</java>
<java name="JTLS_samples/Client.java">/**
 * $RCSfile$
 * version $Revision: 36565 $
 * created 03.07.2007 10:07:20 by kunina
 * last modified $Date: 2012-10-03 18:28:03 +0400 (Wed, 03 Oct 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package JTLS_samples;

import ru.CryptoPro.ssl.SSLSocketFactoryImpl;

import javax.net.ssl.SSLSocket;
import java.io.*;
import java.net.Socket;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * Пример клиента. Переделан на явное получение контекста, т.к. есть глюки при
 * а) использовании ключей с одинаковым паролем для сервера и клиента (может
 * быть выбран серверный ключ для клиента и для сервера, даже если рядом лежит
 * клиентский с таким же паролем)
 * б) т.к. при создании контекста используется getDefault(), то есть вероятность
 * получить ранее созданный контекст, не имеющий контейнеров с доверенными сертификатами).
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Client {

 /**/
public static final String hhtp_header_separator = "\r\n\r\n";
 /**/
public static final int DEFAULT_TIMEOUT = 1000;
 /**/
private int timeout = DEFAULT_TIMEOUT;
 /**/
private String host;
 /**/
private int port;
 /**/
private static String TEST_DIR = null;
 /**/
private static Logger log = Logger.getLogger("LOG");


/**
 * Создание сокета по заданному порту и хосту.
 *
 * @param hostname хост
 * @param p порт
 */
public Client(String hostname, int p) {
    host = hostname;
    port = p;
}

/**
 * Функция устанавливает timeout на чтение.
 *
 * @param t timeout
 */
public void setTimeout(int t) {
    timeout = t;
}

/**
 * Основная функция работы клинета.
 *
 * @param fileName имя файла
 * @throws IOException ошибки ввода-вывода
 */
public void get(String fileName, String outFileName, String testDir)
        throws Exception {
    TEST_DIR = testDir;
    SSLSocket soc = null;
    try {
//        //вариант 1
//        final SSLSocketFactory sslFact =
//                (SSLSocketFactory) SSLSocketFactory.getDefault();
        //вариант 2
        final SSLSocketFactoryImpl sslFact = new SSLSocketFactoryImpl();

        soc = (SSLSocket) sslFact.createSocket(host, port);
        soc.setSoTimeout(timeout);

        proc(soc, fileName, outFileName);

    } finally {
        if (soc != null)
            soc.close();
    }
}

/**
 * Выполнение обмена данными с сервером.
 *
 * @param soc сокет
 * @param file имя файла
 * @param outfile файл для записи
 * @throws IOException ошибки ввода-вывода
 */
public static void proc(Socket soc, String file, String outfile)
        throws IOException {
    final InputStream in = soc.getInputStream();
    final OutputStream out = soc.getOutputStream();
    //отправка запроса
    final String req = "GET /" + file + " HTTP/1.0\r\n\r\n";
    log.log(Level.INFO, " Client request: " + req);
    out.write(req.getBytes());
    out.flush();
    //разбор ответа
    log.log(Level.INFO, " Client: parse answer");
    final String answer =
            new String(readHeader(in, hhtp_header_separator.getBytes()));
    //System.out.println("---------------");
    System.out.println(answer);
    int fileLength = 0;
    try {
        fileLength = parseAnswer(answer);
    } catch (IOException e) {
        //ignore
    }
    //чтение
    final byte[] body = readBody(in, fileLength);
//    final FileOutputStream fost =
//            new FileOutputStream(outfile + new File(file).getName() + "body");
//    fost.write(body);
//    fost.close();
    //проверка
    boolean isread = true;
    byte[] buffer = body;
    if (TEST_DIR != null)
        try {
            buffer = readFile(TEST_DIR + File.separator + file);
            if (fileLength != body.length)
                throw new IOException("Invalid length in HTTP:" + file);
            if (buffer.length != fileLength)
                throw new IOException("Invalid file length:" + file);
            for (int i = 0; i &lt; buffer.length; i++)
                if (buffer[i] != body[i])
                    throw new IOException("Invalid file:" + file);
        } catch (IOException e) {
            isread = false;
            log.log(Level.INFO, " ClientVerify: " + e.toString());
            //log.log(Level.INFO, "Client:" + e.toString());
        }
    if (isread) {
        final String outPath = outfile + new File(file).getName();
        final FileOutputStream fos = new FileOutputStream(outPath);
        fos.write(buffer);
        fos.close();
        log.log(Level.INFO, "answer was writing to: " + outPath);
    } else {
        final String outPath = outfile + ".html";
        final FileOutputStream fos = new FileOutputStream(outPath);
        String s = "&lt;p align=\"left\"&gt;" +
                "&lt;font color=\"#FF9909\" size=\"5\" face=\"Times New Roman\"&gt;" +
                "&lt;u&gt;ANSWER:&lt;/u&gt;" +
                "&lt;/font&gt;&lt;/p&gt;";
        fos.write(s.getBytes());
        fos.write(answer.getBytes());
        s = "&lt;p align=\"left\"&gt;" +
                "&lt;font color=\"#FF9909\" size=\"5\" face=\"Times New Roman\"&gt;" +
                "&lt;u&gt;PAGE:&lt;/u&gt;" +
                "&lt;/font&gt;&lt;/p&gt;";
        fos.write(s.getBytes());
        fos.write(buffer);
        fos.close();
        log.log(Level.INFO, "answer was writing to: " + outPath);
    }
}

/**
 * Чтение потока до конца заголовка.Может быть вызвано с new byte[] {(byte)' '}
 *
 * @param in входной поток
 * @param end конец заголовка
 * @return буфер (байтовый массив)
 * @throws IOException ошибки ввода-вывода
 */
public static byte[] readHeader(InputStream in, byte[] end) throws IOException {
    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int conformity = 0;
    int next;
    log.log(Level.FINE, " Try reading (Client.readHeader)");
    do {
        next = in.read();
        if (next == -1)
            throw new IOException(" Client: Error reading HTTP header");
        baos.write(next);
        if (next == end[conformity])
            conformity++;
        else
            conformity = 0;
    } while (conformity != end.length);
    return baos.toByteArray();
}

/**
 * Чтение известного количества байтов.
 *
 * @param in InputStream
 * @param len length
 * @return буфер
 * @throws IOException ошибки ввода-вывода
 */
public static byte[] readBody(InputStream in, int len) throws IOException {
    final byte[] buf = new byte[len];
    int next;
    int pos = 0;
    while (pos != len) {
        next = in.read();
        if (next == -1)
            throw new IOException(" Error reading HTTP body");
        buf[pos++] = (byte) next;
    }
//    while (true) {
//        next = in.read();
//        if (next == -1)
//            break;
//        buf[pos++] = (byte) next;
//    }
//    if (pos &lt; len)
//        throw new IOException("Error reading HTTP body");
    return buf;
}

/**
 * Чтение файла
 *
 * @param name имя
 * @return буфер
 * @throws IOException ошибки ввода-вывода
 */
public static byte[] readFile(String name) throws IOException {
    byte[] buffer;
    FileInputStream is = null;
    try {
        final File file = new File(name);
        is = new FileInputStream(file);
        buffer = new byte[(int) file.length()];

        int len;
        int total = 0;
        do {
            len = is.read(buffer, total, buffer.length - total);
            if (len == -1)
                throw new IOException(" Client: Error reading file:" + name);
            total += len;
        } while (total != buffer.length);
    } finally {
        if (is != null) is.close();
    }
    return buffer;
}

/**
 * Разбор ответа сервера и извлечение длины файла
 *
 * @param str строка ответа
 * @return длина файла
 * @throws IOException ошибки ввода-вывода
 */
public static int parseAnswer(String str) throws IOException {
    final String[] split = str.split("\r\n");
    if (!split[0].equals("HTTP/1.0 200 OK") &amp;&amp;
            !split[0].equals("HTTP/1.1 200 OK"))
        throw new IOException(split[0]);
    //throw new IOException("Unknown answer");
    int len = -1;
    for (int i = 1; i &lt; split.length; i++)
        if (split[i].startsWith("Content-Length:")) {
            final String ss =
                    split[i].substring("Content-Length:".length()).trim();
            len = Integer.parseInt(ss);
            break;
        }
    return len;
}
}
</java>
<java name="JTLS_samples/SampleTLS.java">/**
 * $RCSfile$
 * version $Revision: 36515 $
 * created 03.07.2007 13:36:23 by kunina
 * last modified $Date: 2012-08-17 20:37:02 +0400 (Fri, 17 Aug 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package JTLS_samples;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Простейший пример использования TLS.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class SampleTLS {
/**
 *
 */
private SampleTLS() {
}

/**
 * @param args /
 * @throws IOException ошибки ввода-вывода
 */
public static void main(String[] args) throws IOException {

    final int sslPort = 8443;
    Server server = null;
    try {
        // System.setProperty("javax.net.ssl.supportGVO","true");
        // Настройки для клиента или сервера (смотря в какой роли выступает приложение), если
        // необходима двухсторонняя аутентификация.
        // При двусторонней аутентификации эти настройки обязательны: тип хранилища и пароль к ключу, по
        // которому будет загружен первый подходящий ключ.
        // Если используется односторонняя аутентификация, то задавать тип ключа и пароль к ключу для
        // клиента или сервера необязательно.
        System.setProperty("javax.net.ssl.keyStoreType", "HDImageStore");
        System.setProperty("javax.net.ssl.keyStorePassword", "1");
        // Обязательные настройки при односторонней и двухсторонней аутентификации: указание, какое хранилище
        // содержит доверенный корневой сертификат, и пароль к хранилищу.
        System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
        System.setProperty("javax.net.ssl.trustStore",
                "C:\\test\\empty.store");
        System.setProperty("javax.net.ssl.trustStorePassword", "1");

        server = new Server(sslPort, false, "C:\\test\\serverDir");
        server.setTimeout(100000);
        server.start();

        final Client client = new Client("localhost", sslPort);
        client.setTimeout(100000);
        client.get("myDoc.txt", "out.html", null);

        if (!server.isAlive())
            throw new IOException();
    } catch (Exception e) {
        Logger.getLogger("LOGGER").log(Level.SEVERE, e.toString());
        //e.printStackTrace();
    } finally {
        if (server != null)
            server.stop();
    }


}
}
</java>
<java name="JTLS_samples/Server.java">/**
 * $RCSfile$
 * version $Revision: 36483 $
 * created 03.07.2007 12:17:39 by kunina
 * last modified $Date: 2012-08-07 21:18:54 +0400 (Tue, 07 Aug 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package JTLS_samples;


import ru.CryptoPro.ssl.SSLServerSocketFactoryImpl;

import javax.net.ssl.*;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.security.KeyStore;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Пример сервера.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Server implements Runnable {

 /**/
private ServerSocket serverSocket = null;
 /**/
private boolean alive = false;
 /**/
private int timeout = 1000;
 /**/
private Thread thread = null;
 /**/
public static final String http_header_separator = "\r\n\r\n";
 /**/
public String workingDir;

/**
 * Создание сервера с параметром аутентификация клиента (auth).
 *
 * @param port порт
 * @param auth setNeedClientAuth(auth)
 * @throws IOException ошибки ввода-вывода
 */
public Server(int port, boolean auth,
    String workDir) throws Exception {

    //    //вариант 1
    //    final SSLServerSocketFactory sslSrvFact =
    //            (SSLServerSocketFactory) SSLServerSocketFactory
    //                    .getDefault();
    //вариант 2
    final SSLServerSocketFactoryImpl sslSrvFact = new SSLServerSocketFactoryImpl();

    serverSocket = sslSrvFact.createServerSocket(port);
    ((SSLServerSocket) serverSocket).setNeedClientAuth(auth);

    workingDir = workDir;
}

/**
 * @throws Throwable
 */
protected void finalize() throws Throwable {
    if (serverSocket != null)
        serverSocket.close();
    super.finalize();
}

/**
 * Работает ли сервер.
 *
 * @return работает ли сервер
 */
public boolean isAlive() {
    return alive;
}

/**
 * Функция устанавливает timeout на чтение.
 *
 * @param t timeout
 */
public void setTimeout(int t) {
    timeout = t;
}

/**
 * Открытие соединения.
 *
 * @throws IOException ошибки ввода-вывода
 */
public void start() throws IOException {
    serverSocket.setSoTimeout(timeout);
    thread = new Thread(this);
    thread.setPriority(Thread.MIN_PRIORITY);
    thread.start();
    alive = true;
}

/**
 * Остановка сервера.
 *
 * @throws IOException ошибки ввода-вывода
 */
public void stop() throws IOException {
    if (serverSocket != null) {
        serverSocket.close();
        serverSocket = null;
    }
    while (alive) {
        try {
            alive = false;
            thread.join();
        } catch (InterruptedException ex) {
            // ignore ex
            alive = true;
        }
    }
}

/**
 * Основная функция работы сервера.
 */
public void run() {
    Socket soc = null;
    while (alive) {
        try {
            try {
                soc = serverSocket.accept();
                soc.setSoTimeout(timeout);
                if (alive)
                    proc(soc);
            } catch (SocketTimeoutException e) {
                // ignore e, check alive only
            } finally {
                if (soc != null)
                    soc.close();
            }

        } catch (IOException ex) {
            Logger.getLogger("LOGGER")
                    .log(Level.SEVERE, "Server error:" + ex.toString());
            //ex.printStackTrace();
            //alive = false;
        }
    }
}

/**
 * Обмен данными с клиентом.
 *
 * @param soc сокет
 * @throws IOException ошибки ввода-вывода
 */
private void proc(Socket soc) throws IOException {
    final InputStream in = soc.getInputStream();
    final OutputStream out = soc.getOutputStream();
    // чтение запроса
    Logger.getLogger("LOGGER").log(Level.INFO, "Server: read request");
    final String req = new String(
            readHeader(in, http_header_separator.getBytes()));
    Logger.getLogger("LOGGER").log(Level.INFO, "Server: parse request");
    final String fName = parseRequest(req);
    final String filename = workingDir + File.separator + fName;
    //при запросе "shutdown" прекращение работы сервера
    if ("shutdown".equals(fName)) {
        alive = false;
        //soc.close();
    }
    Logger.getLogger("LOGGER").log(Level.INFO, "Server: read file");
    String info;
    final String s = "&lt;html&gt;\n" +
            "\n" +
            "&lt;head&gt;\n" +
            "&lt;meta http-equiv=\"Content-Language\" content=\"en-us\"&gt;\n" +
            "&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\"&gt;\n" +
            "&lt;title&gt;Server&lt;/title&gt;\n" +
            "&lt;/head&gt;\n" +
            "\n" +
            "&lt;body&gt;\n" +
            "\n" +
            "&lt;p align=\"center\"&gt;&lt;font color=\"#FF9999\" size=\"5\" face=\"Times New Roman\"&gt;&lt;u&gt;&lt;i&gt;\n" +
            "&lt;b&gt;Sample page&lt;/b&gt;&lt;/i&gt;&lt;/u&gt;&lt;/font&gt;&lt;/p&gt;\n" +
            "\n" +
            "&lt;/body&gt;\n" +
            "\n" +
            "&lt;/html&gt;";
    final String ss = "&lt;html&gt;\n" +
            "\n" +
            "&lt;head&gt;\n" +
            "&lt;meta http-equiv=\"Content-Language\" content=\"en-us\"&gt;\n" +
            "&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\"&gt;\n" +
            "&lt;title&gt;Server&lt;/title&gt;\n" +
            "&lt;/head&gt;\n" +
            "\n" +
            "&lt;body&gt;\n" +
            "\n" +
            "&lt;p align=\"center\"&gt;&lt;font color=\"#FF5050\" size=\"5\" face=\"Times New Roman\"&gt;&lt;i&gt;\n" +
            "&lt;b&gt;SERVER WILL SHUTDOWN AFTER THIS SESSION&lt;/b&gt;&lt;/i&gt;&lt;/font&gt;&lt;/p&gt;\n" +
            "\n" +
            "&lt;/body&gt;\n" +
            "\n" +
            "&lt;/html&gt;";
    byte[] full = s.getBytes();
    if (!alive) full = ss.getBytes();
    try {
        full = readFile(filename);
        info = "HTTP/1.0 200 OK\r\nContent-Length: " + full.length +
                "\r\n\r\n";
    } catch (Exception e) {
        //info = "HTTP/1.0 404 not found\r\n \r\n\r\n";
        info = "HTTP/1.0 200 OK\r\nContent-Length: " + full.length +
                "\r\n\r\n";
        //info = "HTTP/1.1 404 Not Found\r\nContent-Length: "+ full.length + "\r\n\r\n"+s;
    }
    // отправка
    Logger.getLogger("LOGGER").log(Level.INFO, "Server: answer");
    out.write(info.getBytes());
    out.write(full);
}

/**
 * Чтение потока до конца заголовка.Может быть вызвано с new byte[] {(byte)' '}
 *
 * @param in входной поток
 * @param end конец заголовка
 * @return буфер (байтовый массив)
 * @throws IOException ошибки ввода-вывода
 */
public static byte[] readHeader(InputStream in, byte[] end) throws IOException {
    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int conformity = 0;
    int next;
    Logger.getLogger("LOGGER")
            .log(Level.FINE, "Try reading (Server.readHeader)");
    do {
        next = in.read();
        if (next == -1)
            throw new IOException("Server: Error reading HTTP header");
        baos.write(next);
        if (next == end[conformity])
            conformity++;
        else
            conformity = 0;
    } while (conformity != end.length);
    return baos.toByteArray();
}

/**
 * Разбор запроса, проверка и извлечение имени файла.
 *
 * @param r запрос
 * @return имя файла
 * @throws IOException ошибки ввода-вывода
 */
public static String parseRequest(String r) throws IOException {
    String filename = null;
    final String[] newStr = r.split(" ");
    if (!newStr[0].equals("GET"))
        throw new IOException("Server: Unknown request");
    if (newStr[1].length() &gt; 0 &amp;&amp; newStr[1].charAt(0) == '/')
        filename = newStr[1].substring(1);
    return filename;
}

/**
 * Чтение файла
 *
 * @param name имя
 * @return буфер
 * @throws IOException ошибки ввода-вывода
 */
public static byte[] readFile(String name) throws IOException {
    byte[] buffer;
    FileInputStream is = null;
    try {
        final File file = new File(name);
        is = new FileInputStream(file);
        buffer = new byte[(int) file.length()];

        int len;
        int total = 0;
        do {
            len = is.read(buffer, total, buffer.length - total);
            if (len == -1)
                throw new IOException("Server: Error reading file:" + name);
            total += len;
        } while (total != buffer.length);
    } finally {
        if (is != null) is.close();
    }
    return buffer;
}
}
</java>
<java name="JTLS_samples/TestHttpsConnection.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package JTLS_samples;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.jar.JarFile;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

import ru.CryptoPro.JCP.tools.JarChecker;
import sun.security.util.HostnameChecker;


public class TestHttpsConnection {

	// Just add these two functions in your program 
    public static class miTM implements javax.net.ssl.TrustManager,
            javax.net.ssl.X509TrustManager
    {
        public java.security.cert.X509Certificate[] getAcceptedIssuers()
        {
            return null;
        }
 
        public boolean isServerTrusted(
                java.security.cert.X509Certificate[] certs)
        {
            return true;
        }
 
        public boolean isClientTrusted(
                java.security.cert.X509Certificate[] certs)
        {
            return true;
        }
 
        public void checkServerTrusted(
                java.security.cert.X509Certificate[] certs, String authType)
                throws java.security.cert.CertificateException
        {
            return;
        }
 
        public void checkClientTrusted(
                java.security.cert.X509Certificate[] certs, String authType)
                throws java.security.cert.CertificateException
        {
            return;
        }
    }
    
    private static void trustAllHttpsCertificates() throws Exception
    {
 
        //  Create a trust manager that does not validate certificate chains:
 
        javax.net.ssl.TrustManager[] trustAllCerts =
 
        new javax.net.ssl.TrustManager[1];
 
        javax.net.ssl.TrustManager tm = new miTM();
 
        trustAllCerts[0] = tm;
 
        javax.net.ssl.SSLContext sc =
 
        javax.net.ssl.SSLContext.getInstance("SSL");
 
        sc.init(null, trustAllCerts, null);
 
        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(
 
        sc.getSocketFactory());
 
    }
	
	private static void print_content(HttpsURLConnection con){
		
		
		if(con != null) {
	 
			try {
	 
				System.out.println("****** Content of the URL ********");			
				
				BufferedReader br = new BufferedReader( new InputStreamReader(con.getInputStream()) );
	 
				String input;
	 
				while ((input = br.readLine()) != null) {
					System.out.println(input);
				}
				
				br.close();
				
				System.out.println("****** Content of the URL ********");
	 
			} catch (IOException e) {
				e.printStackTrace();
			}
	 
		}
	}
	
	/**
	 * @param args
	 * @throws Exception 
	 */
	public static void main(String[] args) throws Exception {

		//System.setProperty("javax.net.debug", "ssl,handshake,data,trustmanager");

		//System.setProperty("javax.net.ssl.keyStoreType", "HDImageStore");
        //System.setProperty("javax.net.ssl.keyStore",
        //        "client_exch");
        //System.setProperty("javax.net.ssl.keyStorePassword", "Pass1234");

		System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
		System.setProperty("javax.net.ssl.trustStore",
	                "C:\\Keys\\server\\test_ca.store");
	    System.setProperty("javax.net.ssl.trustStorePassword", "Pass1234");
		
		/*
		System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
		System.setProperty("javax.net.ssl.trustStore",
	                "C:\\server.store");
	    System.setProperty("javax.net.ssl.trustStorePassword", "Pass1234");
		*/
		/*
		System.setProperty("javax.net.ssl.supportGVO","true");
		
		System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
		System.setProperty("javax.net.ssl.trustStore",
	                "C:\\Users\\Yevgeniy\\Downloads\\app\\store\\icrsStore");
	    System.setProperty("javax.net.ssl.trustStorePassword", "123456");
		*/
		
		//System.setProperty("javax.net.ssl.supportGVO","true");
		/*
		System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
		System.setProperty("javax.net.ssl.trustStore",
	                "C:\\Users\\Yevgeniy\\Downloads\\app\\store\\CATrustStore");
	    System.setProperty("javax.net.ssl.trustStorePassword", "Pass1234");
		*/

        /*"https://gost1.stonesoft.com/wa/Hello.html"*/
        /*"https://cpca.cryptopro.ru/tls/tls-cli.asp"*/
        /*"https://cpca.cryptopro.ru/"*/
        /*"https://icrs.nbki.ru"*/
        /*"https://localhost:8443/index.jsp"*/
        /*"HTTPS", "192.168.214.5", 8443, "index.jsp"*/
        //tls/tls-cli.asp
        URL url = new URL("https://cpca.cryptopro.ru/");

		/*
		// Now you are telling the JRE to ignore the hostname
        HostnameVerifier hv = new HostnameVerifier()
        {

        	public boolean verify(String arg0, SSLSession arg1) {
        		
        		 try {
					
        			 Certificate[] peer = arg1.getPeerCertificates();
				
        			 HostnameChecker checker = HostnameChecker.getInstance(
        					 HostnameChecker.TYPE_TLS);
        			 
        			 checker.match(arg0, (X509Certificate) peer[0]);
        		 
        		 } catch (SSLPeerUnverifiedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (CertificateException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
        		
        		System.out.println("Warning: URL Host: " + arg0 + " vs. "
        	             + arg1.getPeerHost());
        	    return true;
        	}
        };
		*/
        //System.setProperty("sun.security.ssl.allowUnsafeRenegotiation", "true");

		//trustAllHttpsCertificates();
		//HttpsURLConnection.setDefaultHostnameVerifier(hv);

        System.out.println(url);

		HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
    	
		connection.connect();
		
		/*
    	System.out.println("cipher suit: " + connection.getCipherSuite());
    	
    	Certificate[] serverCerts = connection.getServerCertificates();
    	Certificate[] sentCerts = connection.getLocalCertificates();
    	
    	for ( Certificate s : serverCerts ) {
    		System.out.println("#################################################");
    		System.out.println("server cert: " + s);
    		System.out.println("#################################################");
        }
    	
    	if (sentCerts != null) {
    		for ( Certificate s : sentCerts ) {
    			System.out.println("#################################################");
    			System.out.println("sent cert: " + s);
    			System.out.println("#################################################");
    		}
    	}
    	*/
		
    	print_content(connection);
    	
    	connection.disconnect();
	}

}
</java>
<java name="JTLS_samples/URLClient.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 10.07.2007 10:01:02 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 *
 * Copyright 2004-2005 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package JTLS_samples;

import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;

/**
 * INSERT BRIEF DESCRIPTION HERE!.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class URLClient {
/**
 *
 */
private URLClient() {
}

public static void main(String[] args) {
    try {
        //final String urlName = "http://www.cryptopro.ru";
        final String urlName = "https://www.cryptopro.ru:9443";
        final URL url = new URL(urlName);
        final URLConnection connection = url.openConnection();

        connection.setDoInput(true);
        connection.setDoOutput(true);

        connection.connect();

        //вывод полей заголовка
        int n = 1;
        String key;
        while ((key = connection.getHeaderFieldKey(n)) != null) {
            String value = connection.getHeaderField(n);
            System.out.println(key + ": " + value);
            n++;
        }
        //вывод данных вместе с названием функции
        System.out.println("-----------------");
        System.out.println("getContentType: " + connection.getContentType());
        System.out
                .println("getContentLength: " + connection.getContentLength());
        System.out.println(
                "getContentEncoding: " + connection.getContentEncoding());
        System.out.println("getDate: " + connection.getDate());
        System.out.println("getExpiration: " + connection.getExpiration());
        System.out.println("getLastModified: " + connection.getLastModified());
        System.out.println("------------------");
        System.out.println("getHeaderFields:\n" + connection.getHeaderFields());
        System.out.println("------------------");

        final BufferedReader in = new BufferedReader(
                new InputStreamReader(connection.getInputStream()));
        //вывод полученных данных в файл
        String line;
        String text = "";
        n = 1;
        while ((line = in.readLine()) != null) {
            text = text + line;
            n++;
        }

        final byte[] data = text.getBytes();/**/

        final FileOutputStream fout =
                new FileOutputStream("D:\\Job\\test\\myData\\url.html");
        try {
            fout.write(data);
        } finally {
            if (fout != null)
                fout.close();
        }

    } catch (Exception e) {
        e.printStackTrace();
    }
}
}
</java>
<java name="JTLS_samples/servkey.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 05.07.2007 10:24:37 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package JTLS_samples;

import ru.CryptoPro.JCP.tools.JCPLogger;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;

/**
 * ключ (сервер).
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class servkey {
/**
 *
 */
private servkey() {
}

public static void main(String[] args) throws Exception {
    final KeyPairGenerator kg = KeyPairGenerator.getInstance("GOST3410DH");
    final KeyPair pair = kg.generateKeyPair();
    // закрытый ключ обмена
    final PrivateKey privKey = pair.getPrivate();
    // соответствующий ему открытый ключ
    final PublicKey pubKey = pair.getPublic();

    final String keyAlg = "GOST3410DH";
    final boolean isServer = true;
    final String httpAddress = "http://www.cryptopro.ru/certsrv/";
    final String certName = "CN=serv, O=CryptoPro, C=RU";
    final String keystorePass = "null";
    final String keystorePath = "null";
    final String keypass = "pass";
    final String alias = "serKey";
    final String keystoreName = "HDImageStore";

    // создание запроса на сертификат аутентификации сервера
    final GostCertificateRequest req = new GostCertificateRequest();
    req.init(keyAlg, isServer);
    req.setPublicKeyInfo(pubKey);
    //Определение имени субъекта
    req.setSubjectInfo(certName);
    req.encodeAndSign(privKey);

    // отправка запроса центру сертификации и получение от центра
    // сертификата в DER-кодировке
    byte[] encoded = req.getEncodedCert(httpAddress);

    // генерирование X509-сертификата из закодированного представления сертификата
    CertificateFactory cf = CertificateFactory.getInstance("X509");
    Certificate cert =
            cf.generateCertificate(new ByteArrayInputStream(encoded));

    // забираем корневой сертификат УЦ с того же адреса
    final Certificate certRoot = cf.generateCertificate(
            new ByteArrayInputStream(
                    GostCertificateRequest.getEncodedRootCert(httpAddress)));

    final Certificate[] certs = new Certificate[1];
    certs[0] = cert;

    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);/**/
    char[] Keypass = null;
    if (!"null".equalsIgnoreCase(keypass)) {
        Keypass = keypass.toCharArray();
    }
    ks.setKeyEntry(alias, privKey, Keypass, certs);
    ks.setCertificateEntry("CPTrootCert", certRoot);
    OutputStream os = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        os = new FileOutputStream(keystorePath);
    }
    ks.store(os, KeyStorePass);
    JCPLogger.trace("Recording of a private key named \"" + alias + "\" to " +
            keystoreName + " is completed.");

}
}
</java>
<java name="JTLS_samples/trustStore.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 09.07.2007 12:30:08 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package JTLS_samples;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.logging.Logger;

/**
 * trust store.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class trustStore {
/**
 *
 */
private trustStore() {
}

/**
 * Функции записи сертификата из файла в хранилище и удаления сертификата из
 * хранилища.
 *
 * @param args -
 * @throws Exception e
 */
public static void main(String[] args) throws Exception {

    final String keystoreName = "HDImageStore";
    final String keystorePass = "1";
    final String keystorePath = "C:\\trust.store";
    final String certPath = "C:\\Cert.cer";
    final String alias = "Cert";

    //Запись сертификата в хранилище
    addCert(certPath, keystoreName, keystorePass, keystorePath, alias);
    //Удаление сертификата из хранилища
    delCert(keystoreName, keystorePass, keystorePath, alias);
}

/**
 * Запись сертификата в хранилище
 *
 * @param certPath Путь к файлу сертификата
 * @param keystoreName тип хранилища
 * @param keystorePass пароль на хранилище
 * @param keystorePath путь к хранилищу
 * @param alias имя
 * @throws Exception е
 */
public static void addCert(String certPath, String keystoreName,
                           String keystorePass,
                           String keystorePath, String alias) throws Exception {
    final CertificateFactory cf = CertificateFactory.getInstance("X509");

    final Certificate rootCert = cf.generateCertificate(
            new BufferedInputStream(new FileInputStream(certPath)));

    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);

    ks.setCertificateEntry(alias, rootCert);

    OutputStream os = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        os = new FileOutputStream(keystorePath);
    }
    ks.store(os, KeyStorePass);
    Logger.getLogger("LOGGER").info(
            "Recording of a Certificate named \"" + alias + "\" to " +
                    keystoreName + " is completed.");

}

/**
 * Удаление сертификата из хранилища
 *
 * @param keystoreName тип хранилища
 * @param keystorePass пароль на хранилище
 * @param keystorePath путь к хранилищу
 * @param alias имя
 * @throws Exception е
 */
public static void delCert(String keystoreName,
                           String keystorePass,
                           String keystorePath, String alias) throws Exception {

    final KeyStore ks = KeyStore.getInstance(keystoreName);
    char[] KeyStorePass = null;
    if (!"null".equalsIgnoreCase(keystorePass)) {
        KeyStorePass = keystorePass.toCharArray();
    }
    InputStream is = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        is = new FileInputStream(keystorePath);
    }
    ks.load(is, KeyStorePass);

    if (ks.isCertificateEntry(alias)) ks.deleteEntry(alias);

    OutputStream os = null;
    if (!"null".equalsIgnoreCase(keystorePath)) {
        os = new FileOutputStream(keystorePath);
    }
    ks.store(os, KeyStorePass);
    Logger.getLogger("LOGGER").info(
            "Deleting of a Certificate named \"" + alias + "\" to " +
                    keystoreName + " is completed.");

}
}
</java>
<java name="JavaAgent.java">import lotus.domino.*;
import services.zapret_info.*;
public class JavaAgent extends AgentBase {

    public void NotesMain() {

      try {
          Session session = getSession();
          AgentContext agentContext = session.getAgentContext();

          // (Your code goes here)
          ZapretInfoExample.main(new String[]{});
      } catch(Exception e) {
          e.printStackTrace();
       }
   }
}</java>
<java name="oldSamples/CertReq.java">package oldSamples;

import sun.security.pkcs.PKCS10;
import sun.security.x509.X500Name;
import sun.security.x509.X500Signer;

import java.io.FileOutputStream;
import java.io.PrintStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;

public class CertReq {
  public static void main(String[] args) {
      long startTime = General.printTestName("CertReq");
	try {
        String alias = "mykey";
	    String password = "password";
	    String sigAlgName = "SHA1WithDSA";
        String filename = "request";
	    PrintStream out =  new  PrintStream(new FileOutputStream(filename));
        KeyStore keyStore = General.LoadKeyStore(password);
        PrivateKey privKey = General.GetPrivateFromStore(keyStore, alias, password);
	    Certificate cert = keyStore.getCertificate(alias);
        PKCS10 request = new PKCS10(cert.getPublicKey());
        Signature signature = Signature.getInstance(sigAlgName);
	    signature.initSign(privKey);
	    X500Name subject =
	    new X500Name(((X509Certificate)cert).getSubjectDN().toString());
        X500Signer signer = new X500Signer(signature, subject);
        request.encodeAndSign(signer);
	    request.print(out);
        General.printOK(startTime);
	}
	
	catch( Exception ex )
	{
		General.printEx(ex, startTime);
	}
    }	
}
</java>
<java name="oldSamples/Digest.java">package oldSamples;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.DigestInputStream;
import java.security.MessageDigest;

public class Digest {
public static final String text = "Generating message digest example.";

    public static void main(String[] args) throws IOException {
	long startTime = General.printTestName("Digest");
        String AlgDigest =  "GOST3411";
        ByteArrayInputStream stream = new ByteArrayInputStream(text.getBytes());
        int size = stream.available();
        try {
            MessageDigest sha = MessageDigest.getInstance(AlgDigest);
            DigestInputStream digest  = new DigestInputStream(stream, sha);
            digest.setMessageDigest(sha);
            int count;
            byte temp[] = new byte[256];
            do
            count = digest.read(temp, 0, 256);
            while (count == 256);
            sha = digest.getMessageDigest();
            byte[] res = sha.digest();
            System.out.println( General.toHexString( res ) );
            General.printOK(startTime, size);
	}
	catch( Exception ex )
	{
	    General.printEx(ex, startTime, size);
    }
    }	
}</java>
<java name="oldSamples/Digest32bytes.java">package oldSamples;
import ru.CryptoPro.JCP.Digest.GostDigest;
import ru.CryptoPro.JCP.params.OID;

import java.security.*;
import java.io.*;
import java.lang.*;

public class Digest32bytes {

    public static void main(String[] args) {
        long startTime = General.printTestName("Digest32bytes");
        try {
            String AlgDigest =  "GOST3411";
            byte [] test_text ={
                0x54,0x68,0x69,0x73,0x20,0x69,0x73,0x20,
                0x6d,0x65,0x73,0x73,0x61,0x67,0x65,0x2c,
                0x20,0x6c,0x65,0x6e,0x67,0x74,0x68,0x3d,
                0x33,0x32,0x20,0x62,0x79,0x74,0x65,0x73,
            };
            byte [] test_result ={
                (byte) 0xb1, (byte) 0xc4, (byte) 0x66, (byte) 0xd3, (byte) 0x75, (byte) 0x19, (byte) 0xb8, (byte) 0x2e,
                (byte) 0x83, (byte) 0x19, (byte) 0x81, (byte) 0x9f, (byte) 0xf3, (byte) 0x25, (byte) 0x95, (byte) 0xe0,
                (byte) 0x47, (byte) 0xa2, (byte) 0x8c, (byte) 0xb6, (byte) 0xf8, (byte) 0x3e, (byte) 0xff, (byte) 0x1c,
                (byte) 0x69, (byte) 0x16, (byte) 0xa8, (byte) 0x15, (byte) 0xa6, (byte) 0x37, (byte) 0xff, (byte) 0xfa,
            };
            MessageDigest sha = MessageDigest.getInstance(AlgDigest);
            ((GostDigest)sha).reset(new OID("1.2.643.2.2.30.0"));
            ByteArrayInputStream stream = new ByteArrayInputStream(test_text);
            DigestInputStream digest  = new DigestInputStream(stream, sha);
            digest.setMessageDigest(sha);
            byte temp[] = new byte[32];
            digest.read(temp, 0, 32);
            sha = digest.getMessageDigest();
            byte[] res = sha.digest();
            if (res.length != 32)
                throw new Exception("The length of digest is invalid");
            for (int i = 0; i&lt;32; i++)
            {
                if (res[i] != test_result[i])
                        throw new Exception("The digest is invalid");
            }
            System.out.println( General.toHexString( res ) );
            General.printOK(startTime);

            }
            catch( Exception ex )
            {
                General.printEx(ex, startTime);
        }
        }
}</java>
<java name="oldSamples/Digest50bytes.java">package oldSamples;

import ru.CryptoPro.JCP.Digest.GostDigest;
import ru.CryptoPro.JCP.params.OID;

import java.security.*;
import java.io.*;
import java.lang.*;

public class Digest50bytes {

    public static void main(String[] args) {
    long startTime = General.printTestName("Digest50bytes");
        try {
            String AlgDigest =  "GOST3411";
            byte [] test_text ={
                0x53,0x75,0x70,0x70,0x6F,0x73,0x65,0x20,
                0x74,0x68,0x65,0x20,0x6F,0x72,0x69,0x67,
                0x69,0x6E,0x61,0x6C,0x20,0x6D,0x65,0x73,
                0x73,0x61,0x67,0x65,0x20,0x68,0x61,0x73,
                0x20,0x6C,0x65,0x6E,0x67,0x74,0x68,0x20,
                0x3D,0x20,0x35,0x30,0x20,0x62,0x79,0x74,
                0x65,0x73
            };
            byte [] test_result ={
                    (byte) 0x47, (byte) 0x1A, (byte) 0xBA, (byte) 0x57, (byte) 0xA6, (byte) 0x0A, (byte) 0x77, (byte) 0x0D,
                    (byte) 0x3A, (byte) 0x76, (byte) 0x13, (byte) 0x06, (byte) 0x35, (byte) 0xC1, (byte) 0xFB, (byte) 0xEA,
                    (byte) 0x4E, (byte) 0xF1, (byte) 0x4D, (byte) 0xE5, (byte) 0x1F, (byte) 0x78, (byte) 0xB4, (byte) 0xAE,
                    (byte) 0x57, (byte) 0xDD, (byte) 0x89, (byte) 0x3B, (byte) 0x62, (byte) 0xF5, (byte) 0x52, (byte) 0x08,
            };
            MessageDigest sha = MessageDigest.getInstance(AlgDigest);
            ((GostDigest)sha).reset(new OID("1.2.643.2.2.30.0"));
            ByteArrayInputStream stream = new ByteArrayInputStream(test_text);
            DigestInputStream digest  = new DigestInputStream(stream, sha);
            digest.setMessageDigest(sha);
            byte temp[] = new byte[50];
            digest.read(temp, 0, 50);
            sha = digest.getMessageDigest();
            byte[] res = sha.digest();
            if (res.length != 32)
                throw new Exception("The length of digest is invalid");
            for (int i = 0; i&lt;32; i++)
            {
                if (res[i] != test_result[i])
                        throw new Exception("The digest is invalid");
            }
            System.out.println( General.toHexString( res ) );
            General.printOK(startTime);

            }
            catch( Exception ex )
            {
                General.printEx(ex, startTime);
        }
        }
}</java>
<java name="oldSamples/Encrypt.java">package oldSamples;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;


public class Encrypt{


    public static void main(String[] args)  {
	long startTime = General.printTestName("Encrypt");
        String input = "Hellow, world!!!";
            int len = input.length();
            try {
            String AlgKey = "DES";
            String AlgCipher = "DES";
            int keysize = 56;
            KeyGenerator kg = KeyGenerator.getInstance(AlgKey);
            kg.init(keysize);
	     	SecretKey key = kg.generateKey();
		    Cipher ch = Cipher.getInstance(AlgCipher);
            ch.init(ch.ENCRYPT_MODE, key);
		    byte[] in = input.getBytes();
            byte[] cipher = ch.doFinal(in);
		    System.out.println( General.toHexString( cipher ) );
            System.out.println( "Encryption succeed" );
            ch.init(ch.DECRYPT_MODE, key);
            byte[] out = ch.doFinal(cipher);
		    String output = new String(out);
		    System.out.println( output );
            int equal = output.compareTo(input);
            if (equal == 0)
            {
                System.out.println( "Decryption succeed" );
                General.printOK(startTime, len);
            }
            else
            {
                 throw new Exception("Decryption failed");
            }

	}
	catch( Exception ex )
	{
		General.printEx(ex, startTime, len);
	}
    }	
}</java>
<java name="oldSamples/General.java">package oldSamples;

import sun.security.x509.CertAndKeyGen;
import sun.security.x509.X500Name;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.security.*;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;


public class General {
    static public String toHexString( byte[] array )
    {
	int i;
	String s = "";
	char hex[] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
	for(i = 0; i &lt; array.length; i++){
	    s += " "+hex[( array[i] &gt;&gt;&gt; 4) &amp; 0xf]+hex[array[i] &amp; 0xf];
    	}
	return s;
    }

    public static byte[] fileRead(String file_name) {
        byte[] res;
        try {
            File file = new File(file_name);
            long len = file.length();
            res = new byte[(int) len];
            InputStream stream = new FileInputStream(file);
            stream.read(res);
            stream.close();
        } catch (IOException ex) {
            res = null;
        }
        return res;
    }

    public static void fileWrite(String file_name, byte[] data) {
        try {
            File file = new File(file_name);
            OutputStream stream = new FileOutputStream(file);
            stream.write(data);
            stream.close();
        } catch (IOException ex) {
        }
    }


    static public void printEx( Exception ex, long startTime)
    {
       long endTime = System.currentTimeMillis();
        try{
            long time = endTime - startTime;
            FileOutputStream stream = null;
            stream = new FileOutputStream("exception.log", true);
            PrintStream printstream = new PrintStream(stream);
            printstream.println("ERROR.");
            ex.printStackTrace(printstream);
            printstream.println();
            printstream.print("The time of execution: ");
            printstream.println(time+" milliseconds");
            printstream.close();
            System.out.println( "ERROR");
            System.out.println(ex.toString());
            System.out.print("The time of execution: ");
            System.out.println(time+" milliseconds");
        }
        catch (FileNotFoundException e)
        {
        }
     }

    static public void printEx( Exception ex, long startTime, long size)
    {
            long endTime = System.currentTimeMillis();
            try{
            long time = endTime - startTime;
            int max = (int) (size/time);
            int min = (int) (size%time);
            FileOutputStream stream = null;
            stream = new FileOutputStream("exception.log", true);
            PrintStream printstream = new PrintStream(stream);
            printstream.println("ERROR.");
            ex.printStackTrace(printstream);
            printstream.println();
            printstream.print("The speed of execution: ");
            printstream.println(max+"."+min+" kb/sec");
            printstream.close();
            System.out.println( "ERROR");
            System.out.println(ex.toString());
            System.out.print("The speed of execution: ");
            System.out.println(max+"."+min+" kb/sec");
        }
        catch (FileNotFoundException e)
        {
        }
     }


    static public long printTestName( String name)
    {
       long startTime = System.currentTimeMillis();
        try{
            FileOutputStream stream = null;
            stream = new FileOutputStream("exception.log", true);
            PrintStream printstream = new PrintStream(stream);
            printstream.print(name + ": ");
            printstream.close();
            System.out.print(name + ": ");
            return startTime;
        }
        catch (FileNotFoundException e)
        {
            return startTime;
        }
 }

     static public void printOK(long startTime)  {
        long endTime = System.currentTimeMillis();
        try{
            long time = endTime - startTime;
            FileOutputStream stream = null;
            stream = new FileOutputStream("exception.log", true);
            PrintStream printstream = new PrintStream(stream);
            printstream.println("OK.");
            printstream.println();
            printstream.print("The time of execution: ");
            printstream.println(time+" milliseconds");
            printstream.close();
            System.out.println("OK.");
            System.out.print("The time of execution: ");
            System.out.println(time+" milliseconds");

    }
        catch (FileNotFoundException e)
        {
        }
 }

   static public void printOK(long startTime, int size)  {
         long endTime = System.currentTimeMillis();
        try{
            long time = endTime - startTime;
            int max = (int) (size/time);
            int min = (int) (size%time);
            FileOutputStream stream = null;
            stream = new FileOutputStream("exception.log", true);
            PrintStream printstream = new PrintStream(stream);
            printstream.println("OK.");
            printstream.println();
            printstream.print("The speed of execution: ");
            printstream.println(max+"."+min+" kb/sec");
            printstream.close();
            System.out.println("OK.");
            System.out.print("The speed of execution: ");
            System.out.println(max+"."+min+" kb/sec");


    }
        catch (FileNotFoundException e)
        {
        }
 }

  public static KeyPair KeyPairGen (String AlgKeyPair, int keysize) throws
          NoSuchAlgorithmException{
 		    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(AlgKeyPair);
		    keyGen.initialize(keysize);
		    KeyPair pair = keyGen.generateKeyPair();
            return pair;
  }

  static public X500Name get_500_name() throws IOException {
            String commonName = "Elvira";
            String organizationalUnit = "Unknown";
            String organization = "CryptoPro";
            String city = "Moscow";
            String state = "Unknown";
            String country = "RU";
            X500Name name = new X500Name(commonName, organizationalUnit, organization, city, state, country);
            return name;
    }

public static void SetStoreEntry(String AlgKey, String AlgSign, int keysize, int validity,
                                 String alias, String password, String certfilename)
        throws NoSuchAlgorithmException, InvalidKeyException, FileNotFoundException, IOException,
        NoSuchProviderException, SignatureException, CertificateException, KeyStoreException {

 // generate
        CertAndKeyGen keypair;
        keypair = new CertAndKeyGen(AlgKey, AlgSign);
        keypair.generate(keysize);
        PrivateKey privKey = keypair.getPrivateKey();
        X509Certificate[] chain = new X509Certificate[1];
        chain[0] = keypair.getSelfCertificate(get_500_name(), validity*24*60*60);

// write certificate
        File cert_file = new File(certfilename);
        OutputStream cert_Stream;
        cert_Stream = new FileOutputStream(cert_file);
        cert_Stream.write(chain[0].getEncoded());
// store
        KeyStore keyStore = General.LoadKeyStore(password);
        keyStore.setKeyEntry(alias, privKey, password.toCharArray(), chain);
        General.SaveKeyStore(keyStore, password);
    }

public static KeyStore LoadKeyStore(String password)
        throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
        KeyStore keyStore = KeyStore.getInstance("HDImageStore");
            try{
                String ksfname = System.getProperty("user.home") + File.separator + ".keystore";
                File ksfile = new File(ksfname);
                InputStream ksStream = new FileInputStream(ksfile);
                keyStore.load(ksStream, password.toCharArray());
                ksStream.close();
                return keyStore;
            }
            catch (FileNotFoundException e) {
                keyStore.load(null, null);
                return keyStore;
            }
}


    public static void SaveKeyStore(KeyStore keyStore, String password)
            throws NoSuchAlgorithmException, IOException, CertificateException, KeyStoreException {
            String ksfname = System.getProperty("user.home") + File.separator + ".keystore";
            File ksfile = new File(ksfname);
            OutputStream ksStream = new FileOutputStream(ksfile);
            keyStore.store(ksStream, password.toCharArray());
            ksStream.close();
     }


public static PublicKey GetPublicFromStore(KeyStore keyStore, String alias)
        throws KeyStoreException {
        java.security.cert.Certificate cert = keyStore.getCertificate(alias);
        PublicKey pubKey = cert.getPublicKey();
        return pubKey;
  }

public static PrivateKey GetPrivateFromStore(KeyStore keyStore, String alias, String password)
        throws NoSuchAlgorithmException, KeyStoreException,
        UnrecoverableKeyException {
        Key key = keyStore.getKey(alias, password.toCharArray());
        PrivateKey privKey = (PrivateKey)key;
        return privKey;
 }


}</java>
<java name="oldSamples/ImportCert.java">package oldSamples;

import java.io.*;
import java.security.KeyStore;
import java.security.PublicKey;
import java.security.PrivateKey;
import java.security.Principal;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.*;


public class ImportCert {
	public static void main(String[] args) {
        long startTime = General.printTestName("ImportCert");
        try {
 	    String keyAlias = "mykey";
	    String password = "password";
            String typeCert = "X509";
            String filename = "certnew.p7b";
            KeyStore keyStore = General.LoadKeyStore(password);
            CertificateFactory cf = CertificateFactory.getInstance(typeCert);

	    InputStream inStream = System.in;
	    inStream = new FileInputStream(filename);

	    PrivateKey privKey = General.GetPrivateFromStore(keyStore, keyAlias, password);
            Certificate userCert = keyStore.getCertificate(keyAlias);
	    if (userCert == null) {
	        throw new Exception("alias has no public key (certificate)");
	    }

	    Collection c = cf.generateCertificates(inStream);
	    if (c.isEmpty()) {
	        throw new Exception("Reply has no certificates");
	    }
	    Certificate[] replyCerts =
	    (Certificate[]) c.toArray (new Certificate[c.size()]);
	    Certificate[] newChain;
	    if (replyCerts.length == 1) {
 		    newChain = establishCertChain(userCert, replyCerts[0], keyStore);
	    }
	    else {
	        newChain = validateReply(userCert, replyCerts);
	    }

	    if (newChain != null) {
	        keyStore.setKeyEntry(keyAlias, privKey, password.toCharArray(), newChain);
	        General.SaveKeyStore(keyStore, password);
            System.out.println("Certificate reply was installed in keystore");
	        General.printOK(startTime);
            }
        else {
	        throw new Exception("Certificate reply was not installed in keystore");
	    }
    }
	catch( Exception ex )
	{
		General.printEx(ex, startTime);
	}
 }	

	public static Certificate[] validateReply(Certificate userCert,
					Certificate[] replyCerts)
	throws Exception
    {
	// order the certs in the reply (bottom-up).
	// we know that all certs in the reply are of type X.509, because
	// we parsed them using an X.509 certificate factory
	int i;
	PublicKey userPubKey = userCert.getPublicKey();
	for (i=0; i&lt;replyCerts.length; i++) {
	    if (userPubKey.equals(replyCerts[i].getPublicKey()))
		break;
	}
	if (i == replyCerts.length) {
	    throw new Exception("Certificate reply does not contain public key for &lt;alias&gt;");
	}

	Certificate tmpCert = replyCerts[0];
	replyCerts[0] = replyCerts[i];
	replyCerts[i] = tmpCert;
	Principal issuer = ((X509Certificate)replyCerts[0]).getIssuerDN();

	for (i=1; i &lt; replyCerts.length-1; i++) {
	    // find a cert in the reply whose "subject" is the same as the
	    // given "issuer"
	    int j;
	    for (j=i; j&lt;replyCerts.length; j++) {
		Principal subject;
		subject = ((X509Certificate)replyCerts[j]).getSubjectDN();
		if (subject.equals(issuer)) {
		    tmpCert = replyCerts[i];
		    replyCerts[i] = replyCerts[j];
		    replyCerts[j] = tmpCert;
		    issuer = ((X509Certificate)replyCerts[i]).getIssuerDN();
		    break;
		}		
	    }
	    if (j == replyCerts.length) {
		throw new Exception ("Incomplete certificate chain in reply");
	    }
	}
	
	// now verify each cert in the ordered chain
	for (i=0; i&lt;replyCerts.length-1; i++) {
	    PublicKey pubKey = replyCerts[i+1].getPublicKey();
	    try {
		replyCerts[i].verify(pubKey);
	    } catch (Exception e) {
		throw new Exception("Certificate chain in reply does not verify: " +
			e.getMessage());
	    }
	}
	return replyCerts;
    }


 public static Certificate[] establishCertChain(Certificate userCert,
					     Certificate certToVerify, KeyStore keyStore)
	throws Exception
    {
	if (userCert != null) {
	    // Make sure that the public key of the certificate reply matches
	    // the original public key in the keystore
	    PublicKey origPubKey = userCert.getPublicKey();
	    PublicKey replyPubKey = certToVerify.getPublicKey();
	    if (!origPubKey.equals(replyPubKey)) {
		throw new Exception("Public keys in reply and keystore don't match");
	    }

	    // If the two certs are identical, we're done: no need to import
	    // anything
	    if (certToVerify.equals(userCert)) {
		throw new Exception("Certificate reply and certificate in keystore are identical");
	    }
	}

	// Build a hash table of all certificates in the keystore.
	// Use the subject distinguished name as the key into the hash table.
	// All certificates associated with the same subject distinguished
	// name are stored in the same hash table entry as a vector.
	Hashtable certs = null;
	if (keyStore.size() &gt; 0) {
	    certs = new Hashtable(11);
	    keystorecerts2Hashtable(keyStore, certs);
	}

	// start building chain
	Vector chain = new Vector(2);
	if (buildChain((X509Certificate)certToVerify, chain, certs)) {
	    Certificate[] newChain = new Certificate[chain.size()];
	    // buildChain() returns chain with self-signed root-cert first and
	    // user-cert last, so we need to invert the chain before we store
	    // it
	    int j=0;
	    for (int i=chain.size()-1; i&gt;=0; i--) {
		newChain[j] = (Certificate)chain.elementAt(i);
		j++;
	    }
	    return newChain;
	} else {
	    throw new Exception("Failed to establish chain from reply");
	}
    }


 static public boolean buildChain(X509Certificate certToVerify, Vector chain,
			       Hashtable certs) {
	Principal subject = certToVerify.getSubjectDN();
	Principal issuer = certToVerify.getIssuerDN();	
	if (subject.equals(issuer)) {
	    // reached self-signed root cert;
	    // no verification needed because it's trusted.
	    chain.addElement(certToVerify);
	    return true;
	}

	// Get the issuer's certificate(s)
	Vector vec = (Vector)certs.get(issuer);
	if (vec == null)
	    return false;
	
	// Try out each certificate in the vector, until we find one
	// whose public key verifies the signature of the certificate
	// in question.
	for (Enumeration issuerCerts = vec.elements();
	     issuerCerts.hasMoreElements(); ) {
	    X509Certificate issuerCert
		= (X509Certificate)issuerCerts.nextElement();
	    PublicKey issuerPubKey = issuerCert.getPublicKey();
	    try {
		certToVerify.verify(issuerPubKey);
	    } catch(Exception e) {
		continue;
	    }
	    if (buildChain(issuerCert, chain, certs)) {
		chain.addElement(certToVerify);
		return true;
	    }
	}
	return false;
    }

 static public void keystorecerts2Hashtable(KeyStore ks, Hashtable hash)
	throws Exception
    {
	for (Enumeration aliases = ks.aliases(); aliases.hasMoreElements(); ) {
	    String alias = (String)aliases.nextElement();
	    Certificate cert = ks.getCertificate(alias);
	    if (cert != null) {
		Principal subjectDN = ((X509Certificate)cert).getSubjectDN();
		Vector vec = (Vector)hash.get(subjectDN);
		if (vec == null) {
		    vec = new Vector();
		    vec.addElement(cert);
		} else {
		    if (!vec.contains(cert))
			vec.addElement(cert);
		}
		hash.put(subjectDN, vec);
	    }
	}
    }

}</java>
<java name="oldSamples/KeyGen.java">package oldSamples;

public class KeyGen {
    public static void main(String[] args) {
    long startTime = General.printTestName("KeyGen");
	try {
            String alias = "mykey";
            String sigAlgName = "SHA1WithDSA";
            String keyAlgName = "DSA";
            int keysize = 1024;
            int validity = 90;
            String password = "password";
            String certfilename = "cert_dsa.cer";
            General.SetStoreEntry(keyAlgName, sigAlgName, keysize, validity, alias, password, certfilename);
            General.printOK(startTime);
	}
	
	catch( Exception ex )
	{
		General.printEx(ex, startTime);
	}
    }	
}
</java>
<java name="oldSamples/KeyPairGen.java">package oldSamples;

import ru.CryptoPro.JCP.JCP;


import java.security.KeyPair;
import java.security.PublicKey;
import java.security.PrivateKey;

public class KeyPairGen {
    public static void main(String[] args)  {
       long startTime = General.printTestName("KeyPairGen");
	   try {
       String AlgKeyPair = JCP.GOST_DEGREE_NAME;
        int keysize = 512;
        KeyPair pair = General.KeyPairGen(AlgKeyPair, keysize);
        PublicKey pub = pair.getPublic();
        PrivateKey priv = pair.getPrivate();
        General.printOK(startTime);
	}
	catch( Exception ex )
	{
		  General.printEx(ex, startTime);
	}
    }	
}</java>
<java name="oldSamples/Random.java">package oldSamples;

import java.security.*;
public class Random {

    public static void main(String[] args) {
        long startTime = General.printTestName("Random");
        try {
        String AlgRandom = "CPRandom";
        int seedLen = 20;
		SecureRandom random = SecureRandom.getInstance(AlgRandom);
		byte seed[] = random.generateSeed(seedLen);
		System.out.println( General.toHexString( seed ) );
        General.printOK(startTime);
	}
	catch( Exception ex )
	{
		General.printEx(ex, startTime);
	}
    }	
}</java>
<java name="oldSamples/Sign.java">package oldSamples;

import ru.CryptoPro.JCP.JCP;

import java.security.*;
import java.io.*;
import java.lang.*;

public class Sign{
public static final String text = "Example of generating and verifing signature.";
      public static void main(String[] args) {
          long startTime = General.printTestName("Sign");
          try {
              String AlgKeyPair = JCP.GOST_DEGREE_NAME;
              String AlgSign = JCP.CRYPTOPRO_SIGN_NAME;
              String fileparam = "pubKeyParam.bin";
              String filesign = "signature.txt";
              int keysize = 512;
              KeyPair pair = General.KeyPairGen(AlgKeyPair, keysize);
              Signature sig = Signature.getInstance(AlgSign);
              PrivateKey priv = pair.getPrivate();
              PublicKey pub = pair.getPublic();
              byte[] param = pub.getEncoded();
              FileOutputStream pubKeyParam = new FileOutputStream(fileparam);
              DataOutputStream data_stream = new DataOutputStream( pubKeyParam );
              data_stream.writeInt(param.length);
              data_stream.write(param);
              sig.initSign(priv);
              byte src[]  = text.getBytes();
              sig.update(src);
              byte[] signature = sig.sign();
              System.out.println( General.toHexString( signature ) );
              General.fileWrite(filesign, signature);
              General.printOK(startTime);
          }
          catch( Exception ex )
          {
                   General.printEx(ex, startTime);
          }
      }
}</java>
<java name="oldSamples/SignWithCert.java">package oldSamples;

import java.security.*;
import java.io.*;
import java.lang.*;

public class SignWithCert{
public static final String text = "Example of generating and verifing signature.";
    public static void main(String[] args) {
        long startTime = General.printTestName("SignWithCert");
        try {
            int keysize = 512;
            int validity = 90;
            String password = "password";
            String alias = "elvira_key";
            String AlgSign = "GOST3411withGOST3410EL";
            String AlgKey = "GOST3410";
            String certfilename = "cert.cer";
            String filesign = "signatureCert.txt";
            General.SetStoreEntry(AlgKey, AlgSign, keysize, validity, alias, password, certfilename);
            KeyStore keyStore = General.LoadKeyStore(password);
            PrivateKey priv = General.GetPrivateFromStore(keyStore, alias, password);
            Signature test = Signature.getInstance(AlgSign);
            test.initSign(priv);
            test.update(text.getBytes());
            byte[] sig = test.sign();
            System.out.println( General.toHexString( sig ) );
            FileOutputStream file = new FileOutputStream(filesign);
            file.write(sig);
            General.printOK(startTime);
        }
	catch( Exception ex )
	{
		General.printEx(ex, startTime);
	}
    }	
}</java>
<java name="oldSamples/Test_debug.java">package oldSamples;

public class Test_debug {

    public static void main(String[] args) {
        long startTime = General.printTestName("Test_digest");
      	try {
    //     int result = ru.CryptoPro.JCP.Digest.GostDigest.test_digest();
        /*String filename = "test_50.txt";
         int[] hash = ru.CryptoPro.JCP.Digest.GostDigest.test_digest_random(filename);
        byte[] dst = new byte [ru.CryptoPro.JCP.Digest.GostDigest.HASH_STEP];
        ru.CryptoPro.JCP.Digest.GostDigest.hash_cpy(dst, hash);
        System.out.println( General.toHexString(dst ) );*/
     /*   if (result!=0)
        {
             throw new Exception("Error in test_digest()");
        }*/
        General.printOK(startTime);
    }
catch(Exception ex )
    {
       General.printEx(ex, startTime);
    }
   }

}</java>
<java name="oldSamples/Verify.java">package oldSamples;
import ru.CryptoPro.JCP.JCP;

import java.security.*;
import java.io.*;
import java.lang.*;
import java.security.spec.*;

public class Verify{
public static final String text = "Example of generating and verifing signature.";
    public static void main(String[] args) {
        long startTime = General.printTestName("Verify");
        try {
        String AlgSign = JCP.CRYPTOPRO_SIGN_NAME;
        String AlgKey = JCP.GOST_DEGREE_NAME;
        String fileparam = "pubKeyParam.bin";
        String filesign = "signature.txt";
		Signature sig = Signature.getInstance(AlgSign);
        byte signature[] = General.fileRead(filesign);
		FileInputStream pubKeyParam = new FileInputStream(fileparam);
		DataInputStream data_stream = new DataInputStream( pubKeyParam );
		int len = data_stream.readInt();
        byte param[] = new byte[len];
		data_stream.read(param);
		X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(param);
    	KeyFactory keyFactory = KeyFactory.getInstance(AlgKey);
   	 	PublicKey pub = keyFactory.generatePublic(pubKeySpec);
		sig.initVerify(pub);
        byte src[] = text.getBytes();
		sig.update(src);
		boolean verifies = sig.verify(signature);
		System.out.println("signature verifies: " + verifies);
        if (verifies == false)
        {
             throw new Exception("Signature was not verified");
        }
        General.printOK(startTime);
	}
	catch( Exception ex )
	{
        General.printEx(ex, startTime);
	}
    }	
}</java>
<java name="oldSamples/VerifyWithCert.java">package oldSamples;
import java.security.*;
import java.io.*;
import java.lang.*;


public class VerifyWithCert{
public static final String text = "Example of generating and verifing signature.";
    public static void main(String[] args) {
        long startTime = General.printTestName("VerifyWithCert");
        try {
            String password = "password";
            String alias = "elvira_key";
            String AlgSign = "GOST3411withGOST3410EL";
            String filesign = "signatureCert.txt";
            KeyStore keyStore = General.LoadKeyStore(password);
            PublicKey pub = General.GetPublicFromStore(keyStore, alias);
            Signature test = Signature.getInstance(AlgSign);
            FileInputStream file = new FileInputStream(filesign);
            byte sig[] = new byte[256];
            file.read(sig);
            test.initVerify(pub);
            test.update(text.getBytes());
            boolean verifies = test.verify(sig);
            System.out.println("signature verifies: " + verifies);
            if (!verifies)
            {
                 throw new Exception("Signature was not verified");
            }
            General.printOK(startTime);
        }
	catch( Exception ex )
	{
		 General.printEx(ex, startTime);
	}
    }	
}</java>
<java name="oldSamples/sequence.java">package oldSamples;

public class sequence {
    public static void main(String[] args) {
	try {
           Random.main(null);
           KeyPairGen.main(null);
           Digest.main(null);
           Sign.main(null);
           Verify.main(null);
           SignWithCert.main(null);
           VerifyWithCert.main(null);
         //  Encrypt.main(null);
      //     KeyGen.main(null);
       //    CertReq.main(null);
       //    ImportCert.main(null);
   	}
	catch( Exception ex )
	{
		System.out.println( ex );
	}
    }	

}</java>
<java name="services/zapret_info/ZapretInfoExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package services.zapret_info;

import CMS_samples.CMStools;
import com.objsys.asn1j.runtime.*;
import ru.CryptoPro.JCP.ASN.CryptographicMessageSyntax.*;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.CertificateSerialNumber;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Name;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.tools.Array;

import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Arrays;

/**
 * Пример формирования запроса для выгрузки из реестра
 * http://zapret-info.gov.ru.
 * Инструкция находится по адресу http://zapret-info.gov.ru/docs/
 * description_for_operators_2012-11-09v1.4.pdf
 *
 * Класс ZapretInfoExample подписывает запрос {@link #REQUEST}
 * электронной цифровой подписью формата PKCS7.
 */
public class ZapretInfoExample {

    /**
     * Папка для сохранения файлов.
     */
    private static final String PATH_TO_SAVE = "C:\\";
    /**
     * Алиас ключа в ключевом контейнере.
     */
    private static final String ALIAS = "gost_exch1";
    /**
     * Пароль для доступа к ключу в ключевом контейнере.
     */
    private static final char[] PASSWORD = "Pass1234".toCharArray();
    /**
     * Простейший запрос на получение выгрузки, взятый из инструкции.
     */
    private static final String REQUEST =
            "&lt;?xml version=\"1.0\" encoding=\"windows-1251\"?&gt;\n" +
            "&lt;request&gt;\n" +
            "&lt;requestTime&gt;2012-01-01T01:01:01.000+04:00&lt;/requestTime&gt;\n" +
            "&lt;operatorName&gt;Наименование оператора&lt;/operatorName&gt;\n" +
            "&lt;inn&gt;1234567890&lt;/inn&gt;\n" +
            "&lt;ogrn&gt;1234567890123&lt;/ogrn&gt;\n" +
            "&lt;email&gt;email@email.ru&lt;/email&gt;\n" +
            "&lt;/request&gt;";

    /**
     * Функция формирования простой отсоединенной подписи формата PKCS#7
     * по хешу сообщения.
     * Пример подписи взят из {@link CMS_samples.CMS#CMSSign(byte[],
     * PrivateKey, Certificate, boolean)}.
     *
     * @param data Данные для подписи.
     * @param privateKey Закрытый ключ для создания ЭЦП.
     * @param certificate Сертификат подписи.
     * @return ЭЦП.
     * @throws Exception
     */
    public static byte[] createPKCS7(byte[] data, PrivateKey privateKey,
        X509Certificate certificate) throws Exception {

        // Получаем бинарную подпись длиной 64 байта.

        final Signature signature = Signature.getInstance(JCP.GOST_DHEL_SIGN_NAME);
        signature.initSign(privateKey);
        signature.update(data);

        final byte[] sign = signature.sign();

        // Формируем контекст подписи формата PKCS7.

        final ContentInfo all = new ContentInfo();
        all.contentType = new Asn1ObjectIdentifier(
            new OID(CMStools.STR_CMS_OID_SIGNED).value);

        final SignedData cms = new SignedData();
        all.content = cms;
        cms.version = new CMSVersion(1);

        // Идентификатор алгоритма хеширования.

        cms.digestAlgorithms = new DigestAlgorithmIdentifiers(1);
        final DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);
        a.parameters = new Asn1Null();
        cms.digestAlgorithms.elements[0] = a;

        // Т.к. подпись отсоединенная, то содержимое отсутствует.

        cms.encapContentInfo = new EncapsulatedContentInfo(
            new Asn1ObjectIdentifier(new OID(CMStools.STR_CMS_OID_DATA).value), null);

        // Добавляем сертификат подписи.

        cms.certificates = new CertificateSet(1);
        final ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate asnCertificate =
            new ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Certificate();

        final Asn1BerDecodeBuffer decodeBuffer =
            new Asn1BerDecodeBuffer(certificate.getEncoded());
        asnCertificate.decode(decodeBuffer);

        cms.certificates.elements = new CertificateChoices[1];
        cms.certificates.elements[0] = new CertificateChoices();
        cms.certificates.elements[0].set_certificate(asnCertificate);

        // Добавялем информацию о подписанте.

        cms.signerInfos = new SignerInfos(1);
        cms.signerInfos.elements[0] = new SignerInfo();
        cms.signerInfos.elements[0].version = new CMSVersion(1);
        cms.signerInfos.elements[0].sid = new SignerIdentifier();

        final byte[] encodedName = certificate.getIssuerX500Principal().getEncoded();
        final Asn1BerDecodeBuffer nameBuf = new Asn1BerDecodeBuffer(encodedName);
        final Name name = new Name();
        name.decode(nameBuf);

        final CertificateSerialNumber num = new CertificateSerialNumber(
            certificate.getSerialNumber());

        cms.signerInfos.elements[0].sid.set_issuerAndSerialNumber(
            new IssuerAndSerialNumber(name, num));
        cms.signerInfos.elements[0].digestAlgorithm =
            new DigestAlgorithmIdentifier(new OID(CMStools.DIGEST_OID).value);
        cms.signerInfos.elements[0].digestAlgorithm.parameters = new Asn1Null();
        cms.signerInfos.elements[0].signatureAlgorithm =
            new SignatureAlgorithmIdentifier(new OID(CMStools.SIGN_OID).value);
        cms.signerInfos.elements[0].signatureAlgorithm.parameters = new Asn1Null();
        cms.signerInfos.elements[0].signature = new SignatureValue(sign);

        // Получаем закодированную подпись.

        final Asn1BerEncodeBuffer asnBuf = new Asn1BerEncodeBuffer();
        all.encode(asnBuf, true);

        return asnBuf.getMsgCopy();
    }

    /**
     * Функция декодирования подписи формата PKCS7.
     * Пример подписи взят из {@link CMS_samples.CMS#CMSVerify(byte[],
     * Certificate, byte[])}.
     *
     * @param pkcs7Signature ЭЦП формата PKCS7.
     * @param data Подписанные данные.
     * @param certificate Сертификат для проверки подписи.
     * @return True, если подпись корректна.
     * @throws Exception
     */
    public static boolean verifyPKCS7(byte[] pkcs7Signature, byte[] data,
        X509Certificate certificate) throws Exception {

        // Декодирование подписи формата PKCS7.

        int i = -1;
        final Asn1BerDecodeBuffer asnBuf = new Asn1BerDecodeBuffer(pkcs7Signature);
        final ContentInfo all = new ContentInfo();
        all.decode(asnBuf);

        // Проверка формата подписи.

        boolean supportedType =
            new OID(CMStools.STR_CMS_OID_SIGNED).eq(all.contentType.value);
        if (!supportedType) {
            throw new Exception("Not supported");
        }

        final SignedData cms = (SignedData) all.content;
        if (cms.version.value != 1) {
            throw new Exception("Incorrect version");
        }

        boolean supportedData = new OID(CMStools.STR_CMS_OID_DATA).eq(
            cms.encapContentInfo.eContentType.value);
        if (!supportedData) {
            throw new Exception("Nested not supported");
        }

        byte[] text = null;
        if (data != null) {
            text = data;
        } else if (cms.encapContentInfo.eContent != null) {
            text = cms.encapContentInfo.eContent.value;
        }

        if (text == null) {
            throw new Exception("No content");
        }

        // Получение идентификатора алгоритма хеширования.

        OID digestOid = null;
        DigestAlgorithmIdentifier a = new DigestAlgorithmIdentifier(
            new OID(CMStools.DIGEST_OID).value);

        for (i = 0; i &lt; cms.digestAlgorithms.elements.length; i++) {

            if (cms.digestAlgorithms.elements[i].algorithm.equals(a.algorithm)) {
                digestOid = new OID(cms.digestAlgorithms.elements[i].algorithm.value);
                break;
            } // if

        } // for

        if (digestOid == null) {
            throw new Exception("Unknown digest");
        }

        // Поиск сертификат подписи.

        int pos = -1;
        for (i = 0; i &lt; cms.certificates.elements.length; i++) {

            final Asn1BerEncodeBuffer encBuf = new Asn1BerEncodeBuffer();
            cms.certificates.elements[i].encode(encBuf);

            final byte[] in = encBuf.getMsgCopy();
            if (Arrays.equals(in, certificate.getEncoded())) {
                System.out.println("Selected certificate: " + certificate.getSubjectDN());
                pos = i;
                break;
            } // if

        } // for

        if (pos == -1) {
            throw new Exception("Not signed on certificate");
        }

        // Декодирование подписанта.

        final SignerInfo info = cms.signerInfos.elements[pos];
        if (info.version.value != 1) {
            throw new Exception("Incorrect version");
        }

        if (!digestOid.equals(new OID(info.digestAlgorithm.algorithm.value))) {
            throw new Exception("Not signed on certificate");
        }

        final byte[] sign = info.signature.value;

        // Проверка подписи.

        final Signature signature = Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
        signature.initVerify(certificate);
        signature.update(text);

        return signature.verify(sign);
    }

    public static void main(String[] args) throws Exception {

        // Инициализация ключевого контейнера, получение закрытого
        // ключа и сертификата.

        KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
        keyStore.load(null, null);

        PrivateKey privateKey = (PrivateKey)keyStore.getKey(ALIAS, PASSWORD);
        X509Certificate certificate = (X509Certificate) keyStore.getCertificate(ALIAS);

        // Формирование подписи PKCS7.

        byte[] pkcs7Sign = createPKCS7(REQUEST.getBytes(), privateKey, certificate);

        // Локальная проверка подписи PKCS7.

        boolean checkResult = verifyPKCS7(pkcs7Sign, REQUEST.getBytes(), certificate);

        if (checkResult) {
            System.out.println("Valid signature");
        } else {
            System.err.println("Invalid signature");
            return;
        }

        // Сохранение данных и подписи в файлы.
        System.out.println("Сохранение данных и подписи в файлы...");
        
        Array.writeFile(PATH_TO_SAVE + "request.xml", REQUEST.getBytes());
        Array.writeFile(PATH_TO_SAVE + "pkcs7.p7s", pkcs7Sign);


    }
}
</java>
<java name="userSamples/CertFingerPrint.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 07.07.2008 15:20:54 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateFactory;

/**
 * Отпечаток сертификата.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CertFingerPrint {
 /**/
private CertFingerPrint() {
}

/**
 * Пример получения отпечатка сертификата (сначала он генерируется)
 *
 * @param args /
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //генерирование сертификата для примера
    final KeyPairGenerator kg =
            KeyPairGenerator.getInstance(Constants.SIGN_KEY_PAIR_ALG);
    final GostCertificateRequest gr = new GostCertificateRequest();
    final CertificateFactory cf =
            CertificateFactory.getInstance(Constants.CF_ALG);
    final KeyPair kp = kg.generateKeyPair();
    final String name = "CN=cert";
    final byte[] enc = gr.getEncodedSelfCert(kp, name);
    final Certificate cert =
            cf.generateCertificate(new ByteArrayInputStream(enc));
    //получение отпечатка сертификата
    final String fp = fingerPrintCert(cert, "SHA1");
    System.out.println(fp);
}

/**
 * Получение отпечатка сертификата
 *
 * @param cert сертификат
 * @param alg алгоритм (SHA1)
 * @return hex-string
 * @throws CertificateEncodingException /
 * @throws NoSuchAlgorithmException /
 */
private static String fingerPrintCert(Certificate cert, String alg)
        throws CertificateEncodingException, NoSuchAlgorithmException {
    final byte[] encCertInfo = cert.getEncoded();
    final MessageDigest md = MessageDigest.getInstance(alg);
    final byte[] digest = md.digest(encCertInfo);
    return Constants.toHexString(digest);
}
}
</java>
<java name="userSamples/Certificates.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 27.05.2009 18:45:02 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import com.objsys.asn1j.runtime.Asn1Boolean;
import com.objsys.asn1j.runtime.Asn1ObjectIdentifier;
import com.objsys.asn1j.runtime.Asn1OctetString;
import ru.CryptoPro.JCP.ASN.PKIX1Explicit88.Extension;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.cert.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Примеры работы с сертификатами.
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Certificates {
/**
 * уникальное имя записываемого сертификата
 */
private static final String ALIAS = "newCert";
/**
 * имя субъекта для генерирования запроса на сертификат
 */
private static final String DNAME = "CN=newCert, O=CryptoPro, C=RU";
/**
 * http-адрес центра центра сертификации
 */
private static final String HTTP_ADDRESS = "http://www.cryptopro.ru/certsrv/";
/**
 * имя ключевого носителя для инициализации хранилища
 */
private static final String STORE_TYPE = Constants.KEYSTORE_TYPE;
/**
 * алгоритм ключа
 */
private static final String KEY_ALG = Constants.SIGN_KEY_PAIR_ALG;
/**
 * устанавливаемый пароль на хранилище сертификатов
 */
private static final char[] STORE_PASS = "password".toCharArray();
/**
 * путь к файлу хранилища сертификатов
 */
private static final String STORE_PATH =
        System.getProperty("user.home") + File.separator + "new.keystore";
/**
 * путь для записи сертификата
 */
private static final String CERT_PATH =
        System.getProperty("user.home") + File.separator + "newCertificate.cer";


/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //получение сертификата и запись его в хранилище
    writeCertSample();
    //чтение сертификата из хранилища и запись его в файл
    readCertSample();
    //построение цепочки сертификатов
    // (требуется наличие сертификатов в хранилище/носителе)
    //certificateChain();
}

/**
 * Пример генерирования запроса, отправки запроса центру сертификации и записи
 * полученного от центра сертификата в хранилище доверенных сертификатов
 *
 * @throws Exception /
 */
public static void writeCertSample() throws Exception {
    /* Генерирование ключевой пары в соответствии с которой будет создан запрос
    на сертификат*/
    KeyPair keypair = KeyPairGen.genKey(KEY_ALG);
    // отправка запроса центру сертификации и получение от центра
    // сертификата в DER-кодировке
    byte[] encoded = createRequestAndGetCert(keypair);

    // инициализация генератора X509-сертификатов
    CertificateFactory cf = CertificateFactory.getInstance("X509");
    // генерирование X509-сертификата из закодированного представления сертификата
    Certificate cert =
            cf.generateCertificate(new ByteArrayInputStream(encoded));

    /* Запись полученного от центра сертификата*/
    // инициализация хранилища доверенных сертификатов именем ключевого носителя
    // (жесткий диск)
    KeyStore keyStore = KeyStore.getInstance(STORE_TYPE);
    // загрузка содержимого хранилища (предполагается, что инициализация
    // хранилища именем CertStoreName производится впервые, т.е. хранилища
    // с таким именем пока не существует)
    keyStore.load(null, null);

    // запись сертификата в хранилище доверенных сертификатов
    // (предполагается, что на носителе с именем CertStoreName не существует
    // ключа с тем же именем alias)
    keyStore.setCertificateEntry(ALIAS, cert);

    // определение пути к файлу для сохранения в него содержимого хранилища
    File file = new File(STORE_PATH);
    // сохранение содержимого хранилища в файл
    keyStore.store(new FileOutputStream(file), STORE_PASS);
}

/**
 * Пример чтения сертификата из хранилища и записи его в файл
 *
 * @throws Exception /
 */
public static void readCertSample() throws Exception {
    /* Чтение сертификата их хранилища доверенных сертификатов */
    // инициализация хранилища доверенных сертификатов именем ключевого носителя
    // (жесткий диск)
    final KeyStore keyStore = KeyStore.getInstance(STORE_TYPE);
    // определение пути к файлу для чтения содержимого хранилища
    // и последующего его сохранения
    final File file = new File(STORE_PATH);
    // загрузка содержимого хранилища (предполагается, что хранилище,
    // проинициализированное именем CertStoreName существует)
    keyStore.load(new FileInputStream(file), STORE_PASS);

    // чтение сертификата из хранилища доверенных сертификатов
    // (предполагается, что на носителе с именем CertStoreName не существует
    // ключа с тем же именем alias)
    final Certificate cert = keyStore.getCertificate(ALIAS);

    // сохранение содержимого хранилища в файл с тем же паролем
    keyStore.store(new FileOutputStream(file), STORE_PASS);

    /* Запись прочитанного сертификата в файл */
    // определение пути к файлу для записи в него сертификата
    final File cert_file = new File(CERT_PATH);
    // кодирование сертификата в DER-кодировку
    final byte[] encoded = cert.getEncoded();
    // запись закодированного сертификата в файл
    final FileOutputStream outStream = new FileOutputStream(cert_file);
    outStream.write(encoded);
}

/**
 * Чтение корневого, промежуточного сертификатов из хранилища доверенных
 * сертификатов, сертификата открытого ключа - с носителя. Предполагается что
 * все читаемые сертификаты ранее были записаны на носитель и в хранилище.
 *
 * @throws Exception /
 */
public static void certificateChain() throws Exception {
    // уникальное имя корневого сертификата
    final String aliasRootCert = "rootCert";
    // уникальное имя промежуточного сертификата
    final String aliasInterCert = "intermediateCert";
    // уникальное имя сертификата открытого ключа
    final String aliasEndCert = "endCert";

    // инициализация хранилища доверенных сертификатов и ключевого носителя
    final KeyStore keyStore = KeyStore.getInstance(STORE_TYPE);

    // загрузка содержимого хранилища (предполагается, что хранилище,
    // проинициализированное именем STORE_TYPE существует) и содержимого
    // ключевого носителя
    keyStore.load(new FileInputStream(STORE_PATH), STORE_PASS);

    // чтение корневого сертификата из хранилища доверенных сертификатов
    // (предполагается, что такой сертификат существует в хранилище)
    final Certificate certRoot = keyStore.getCertificate(aliasRootCert);

    // чтение промежуточного сертификата из хранилища доверенных сертификатов
    // (предполагается, что такой сертификат существует в хранилище)
    final Certificate certInter = keyStore.getCertificate(aliasInterCert);

    // чтение конечного сертификата (сертификата открытого ключа) с носителя
    // (предполагается, что сертификат такой сертификат существует на носителе)
    final Certificate certEnd = keyStore.getCertificate(aliasEndCert);

    // сохранение содержимого хранилища в файл с тем же паролем
    keyStore.store(new FileOutputStream(STORE_PATH), STORE_PASS);

    //Построение цепочки из прочитанных сертификатов, начиная с корневого сертификата
    //(с именем aliasRootCert) и заканчивая сертификатом открытого ключа (c именем aliasEndCert)

    // определение списка сертификатов, из которых
    // осуществляется построение цепочки
    final List certs = new ArrayList(3);
    certs.add(certRoot);
    certs.add(certInter);
    certs.add(certEnd);

    // определение корневого сертификата (с которого начинается построение
    // цепочки)
    final TrustAnchor anchor =
            new TrustAnchor((X509Certificate) certRoot, null);

    // определение параметров специального хранилища
    // сертификатов, в которое записываются все используемые
    // в построении цепочки сертификаты
    final CollectionCertStoreParameters par =
            new CollectionCertStoreParameters(certs);

    // создание специального хранилища сертификатов на основе
    // параметров, определенных списком сертификатов
    final CertStore store = CertStore.getInstance("Collection", par);

    // инициализация объекта построения цепочки сертификатов
    final CertPathBuilder cpb = CertPathBuilder.getInstance("PKIX");
    //или для совместимости с КриптоПро УЦ
    //CertPathBuilder cpb = CertPathBuilder.getInstance("CPPKIX");

    // инициализация параметров построения цепочки сертификатов
    final PKIXBuilderParameters params = new PKIXBuilderParameters(
            Collections.singleton(anchor), new X509CertSelector());

    // добавление к параметрам сертификатов, из которых
    // будет строиться цепочка
    params.addCertStore(store);

    // инициализация объекта выборки сертификата, которым
    // заканчивается построение цепочки
    final X509CertSelector selector = new X509CertSelector();

    // определение сертификата, которым
    // заканчивается построение цепочки
    selector.setCertificate((X509Certificate) certEnd);

    params.setTargetCertConstraints(selector);

    // построение цепочки сертификатов
    final PKIXCertPathBuilderResult res =
            (PKIXCertPathBuilderResult) cpb.build(params);

    /* Проверка построенной цепочки сертификатов */

    // инициализация объекта проверки цепочки сертификатов
    final CertPathValidator validator = CertPathValidator.getInstance("PKIX");
    //или для совместимости с КриптоПро УЦ
    //CertPathValidator validator = CertPathValidator.getInstance("CPPKIX");

    // проверка цепочки сертификатов
    final CertPathValidatorResult val_res =
            validator.validate(res.getCertPath(), params);

    // вывод результата проверки в строком виде
    System.out.println(val_res.toString());
}

/**
 * Функция формирует запрос на сертификат, отправляет запрос центру сертификации
 * и получает от центра сертификат.
 *
 * @param pair ключевая пара. Открытый ключ попадает в запрос на сертификат,
 * секретный ключ для подписи запроса.
 * @return сертификат в DER-кодировке
 * @throws Exception errors
 */
public static byte[] createRequestAndGetCert(KeyPair pair) throws Exception {
    /* Генерирование запроса на сертификат в соответствии с открытым ключом*/
    // создание генератора запроса на сертификат
    GostCertificateRequest request = new GostCertificateRequest();
    // инициализация генератора
    // @deprecated с версии 1.0.48
    // вместо init() лучше использовать setKeyUsage() и addExtKeyUsage()
    // request.init(KEY_ALG);

    /*
     Установить keyUsage способ использования ключа можно функцией
     setKeyUsage. По умолчанию для ключа подписи, т.е. для указанного в первом
     параметре функции init() алгоритма "GOST3410" используется комбинация
     DIGITAL_SIGNATURE | NON_REPUDIATION. Для ключа шифрования, т.е. для
     алгоритма "GOST3410DH" добавляется KEY_ENCIPHERMENT | KEY_AGREEMENT.
     */
    int keyUsage = GostCertificateRequest.DIGITAL_SIGNATURE |
            GostCertificateRequest.NON_REPUDIATION |
            GostCertificateRequest.KEY_ENCIPHERMENT |
            GostCertificateRequest.KEY_AGREEMENT;
    request.setKeyUsage(keyUsage);
    /*
     Добавить ExtendedKeyUsage можно так. По умолчанию для ключа подписи,
     т.е. для алгоритма "GOST3410" список будет пустым. Для ключа
     шифрования, т.е. для алгоритма "GOST3410DH" добавляется OID
     INTS_PKIX_CLIENT_AUTH "1.3.6.1.5.5.7.3.2", а при установленном в true
     втором параметре функции init() еще добавляется INTS_PKIX_SERVER_AUTH
     "1.3.6.1.5.5.7.3.1"
     */
    request.addExtKeyUsage(GostCertificateRequest.INTS_PKIX_EMAIL_PROTECTION);
    /**
     * ExtendedKeyUsage можно указывать строкой "1.3.6.1.5.5.7.3.3", или можно
     * массивом int[]{1, 3, 6, 1, 5, 5, 7, 3, 4} или объектом типа
     * ru.CryptoPro.JCP.params.OID
     */
    request.addExtKeyUsage("1.3.6.1.5.5.7.3.3");
    /**
     * пример добавления в запрос собственного расширения Basic Constraints
     */
    Extension ext = new Extension();
    int[] extOid = {2, 5, 29, 19};
    ext.extnID = new Asn1ObjectIdentifier(extOid);
    ext.critical = new Asn1Boolean(true);
    byte[] extValue = {48, 6, 1, 1, -1, 2, 1, 5};
    ext.extnValue = new Asn1OctetString(extValue);
    request.addExtension(ext);

    // определение параметров и значения открытого ключа
    request.setPublicKeyInfo(pair.getPublic());
    // определение имени субъекта для создания запроса
    request.setSubjectInfo(DNAME);
    // подпись сертификата на закрытом ключе и кодирование запроса
    request.encodeAndSign(pair.getPrivate());

    // отправка запроса центру сертификации и получение от центра
    // сертификата в DER-кодировке
    return request.getEncodedCert(HTTP_ADDRESS);
}
}
</java>
<java name="userSamples/CheckImita.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 27.09.2005 20:51:25 by elvira
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */

package userSamples;

import javax.crypto.KeyAgreement;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.KeyPair;
import java.security.SecureRandom;
import java.security.cert.Certificate;

/**
 * В данном примере осуществляется имитопреобразование в соответствии с
 * алгоритмом ГОСТ Р 28147-89 на ключах согласования сторон.
 */
public class CheckImita {
/**
 * текст
 */
private static final String SAMPLE_TEXT = "Example text";
/**
 * длина вектора
 */
private static final int RND_LENGTH = 8;


/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    final byte[] data = SAMPLE_TEXT.getBytes();
    /**На каждой стороне должны присутствовать:
     * - свой закрытый ключ
     * - открытый ключ второй стороны (сертификат)**/

    /* Генерирование закрытых ключей сторон */
    final KeyPair alisaPair = KeyPairGen.genKey(Constants.EXCH_KEY_PAIR_ALG);
    final KeyPair bobPair = KeyPairGen.genKey(Constants.EXCH_KEY_PAIR_ALG);

    /* Генерирование самоподписанных сертификатов сторон */
    final Certificate alisaCert = KeyPairGen
            .genSelfCert(alisaPair, "CN=ALISA_CERTIFICATE, O=CryptoPro, C=RU");
    final Certificate bobCert = KeyPairGen
            .genSelfCert(bobPair, "CN=BOB_CERTIFICATE, O=CryptoPro, C=RU");

    /* Генерирование начальной синхропосылки для выработки ключа согласования*/
    final byte[] sv = new byte[RND_LENGTH];
    final SecureRandom random = SecureRandom.getInstance(Constants.RANDOM_ALG);
    random.nextBytes(sv);
    final IvParameterSpec ivspec = new IvParameterSpec(sv);

    /* Выработка ключа согласования алисы c SV*/
    final KeyAgreement alisaKeyAgree =
            KeyAgreement.getInstance(Constants.EXCH_KEY_PAIR_ALG);
    alisaKeyAgree.init(alisaPair.getPrivate(), ivspec, null);
    alisaKeyAgree.doPhase(bobCert.getPublicKey(), true);
    final SecretKey alisaAgree =
            alisaKeyAgree.generateSecret(Constants.CHIPHER_ALG);

    /* Подсчет имиты на ключе согласования алисы */
    Mac mac = Mac.getInstance(Constants.CHIPHER_ALG);
    mac.init(alisaAgree);
    mac.update(data);
    final byte[] alisaImita = mac.doFinal();

    /* Выработка ключа согласования боба с тем же SV. */
    final KeyAgreement bobKeyAgree =
            KeyAgreement.getInstance(Constants.EXCH_KEY_PAIR_ALG);
    bobKeyAgree.init(bobPair.getPrivate(), ivspec, null);
    bobKeyAgree.doPhase(alisaCert.getPublicKey(), true);
    final SecretKey bobAgree = bobKeyAgree.generateSecret(Constants.CHIPHER_ALG);

    /* Подсчет имиты на ключе согласования боба */
    mac = Mac.getInstance(Constants.CHIPHER_ALG);
    mac.init(bobAgree);
    mac.update(data);
    final byte[] bobImita = mac.doFinal();

    // проверка результатов.
    if (alisaImita.length != bobImita.length)
        throw new Exception("Error in computing imita");

    for (int i = 0; i &lt; alisaImita.length; i++)
        if (alisaImita[i] != bobImita[i])
            throw new Exception("Error in computing imita");

    System.out.println("OK");
}
}
</java>
<java name="userSamples/ClassicEncrypt.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 23.09.2005 20:05:23 by elvira
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2005.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.KeyPair;
import java.security.SecureRandom;
import java.security.cert.Certificate;

/**
 * В данном примере осуществляется зашифрование и расшифрование данных по
 * классической схеме (на симметричных ключах согласования).
 */
public class ClassicEncrypt {
/**
 * текст
 */
private static final String SAMPLE_TEXT = "Classic encryption/decryption";
/**
 * длина вектора
 */
private static final int RND_LENGTH = 8;
/**
 * Алгоритм шифрования
 */
private static final String CIPHER_ALG = "GOST28147/CFB/NoPadding";

/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    final byte[] data = SAMPLE_TEXT.getBytes();
    /**На каждой стороне должны присутствовать:
     * - свой закрытый ключ
     * - открытый ключ второй стороны (сертификат)**/

    /* Генерирование закрытых ключей сторон */
    final KeyPair alisaPair = KeyPairGen.genKey(Constants.EXCH_KEY_PAIR_ALG);
    final KeyPair bobPair = KeyPairGen.genKey(Constants.EXCH_KEY_PAIR_ALG);

    /* Генерирование самоподписанных сертификатов сторон */
    final Certificate alisaCert = KeyPairGen
            .genSelfCert(alisaPair, "CN=ALISA_CERTIFICATE, O=CryptoPro, C=RU");
    final Certificate bobCert = KeyPairGen
            .genSelfCert(bobPair, "CN=BOB_CERTIFICATE, O=CryptoPro, C=RU");

    /* Генерирование начальной синхропосылки для выработки ключа согласования*/
    final byte[] sv = new byte[RND_LENGTH];
    final SecureRandom random = SecureRandom.getInstance(Constants.RANDOM_ALG);
    random.nextBytes(sv);
    final IvParameterSpec ivspec = new IvParameterSpec(sv);

    /* Выработка ключа согласования алисы c SV*/
    final KeyAgreement alisaKeyAgree =
            KeyAgreement.getInstance(Constants.EXCH_KEY_PAIR_ALG);
    alisaKeyAgree.init(alisaPair.getPrivate(), ivspec, null);
    alisaKeyAgree.doPhase(bobCert.getPublicKey(), true);
    final SecretKey alisaAgree =
            alisaKeyAgree.generateSecret(Constants.CHIPHER_ALG);

    /*Зашифрование текста на ключе согласования алисы*/
    Cipher cipher = Cipher.getInstance(CIPHER_ALG);
    cipher.init(Cipher.ENCRYPT_MODE, alisaAgree);
    // передача вектора инициализации бобу
    final byte[] iv = cipher.getIV();
    final byte[] encryptedtext = cipher.doFinal(data, 0, data.length);

    /* Выработка ключа согласования боба с тем же SV. */
    final KeyAgreement bobKeyAgree =
            KeyAgreement.getInstance(Constants.EXCH_KEY_PAIR_ALG);
    bobKeyAgree.init(bobPair.getPrivate(), ivspec, null);
    bobKeyAgree.doPhase(alisaCert.getPublicKey(), true);
    final SecretKey bobAgree =
            bobKeyAgree.generateSecret(Constants.CHIPHER_ALG);

    /*Расшифрование текста на ключе согласования боба. IV передан от алисы*/
    cipher = Cipher.getInstance(CIPHER_ALG);
    cipher.init(Cipher.DECRYPT_MODE, bobAgree, new IvParameterSpec(iv), null);
    final byte[] decryptedtext = cipher
            .doFinal(encryptedtext, 0, encryptedtext.length);

    // проверка результата.
    if (decryptedtext.length != data.length)
        throw new Exception("Error in crypting");
    for (int i = 0; i &lt; decryptedtext.length; i++)
        if (data[i] != decryptedtext[i])
            throw new Exception("Error in crypting");

    System.out.println("OK");
}
//передача открытого ключа вне сертификата не рекомендуется
//final PublicKey pubKey;
//final KeyFactory keyFactory = KeyFactory.getInstance(pubKey.getAlgorithm());
//final X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(pubKey.getEncoded());
//final PublicKey publicKey = keyFactory.generatePublic(pubKeySpec);
}
</java>
<java name="userSamples/CloneImita.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 27.09.2005 20:17:49 by elvira
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;

/**
 * В данном примере осуществляется имитопреобразование в соответствии с
 * алгоритмом ГОСТ Р 28147-89 на симметричном ключе шифрования различными
 * способами: подсчет имиты на все данные, имитопреобразование частями и
 * имитопреобразование с использованием клонирования.
 */
public class CloneImita {
/**
 * текст
 */
private static final String SAMPLE_TEXT = "computing imita with cloning";

/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    final byte[] data = SAMPLE_TEXT.getBytes();
    /* Генерирование симметричного ключа пользователя с параметрами
    шифрования из контрольной панели.*/
    final KeyGenerator keyGen = KeyGenerator.getInstance(Constants.CHIPHER_ALG);
    final SecretKey simm = keyGen.generateKey();

    /* Подсчет имиты на данный текст целиком */
    final Mac mac = Mac.getInstance(Constants.CHIPHER_ALG);
    mac.init(simm);
    mac.update(data);
    final byte[] imitaAll = mac.doFinal();

    /* Подсчет имиты на данный текст частями с импользование клонирования */
    final byte[] first = new byte[data.length / 2];
    final byte[] second = new byte[data.length - data.length / 2];
    System.arraycopy(data, 0, first, 0, first.length);
    System.arraycopy(data, first.length, second, 0, second.length);

    //подсчет первой части
    mac.reset();
    mac.update(first);

    //клонирование
    final Mac dupMac = (Mac) mac.clone();

    //подсчет второй части исходным объектом имитопреобразования
    mac.update(second);
    final byte[] imitaFirst = mac.doFinal();

    //подсчет второй части клонированным объектом имитопреобразования
    dupMac.update(second);
    final byte[] imitaSecond = dupMac.doFinal();

    // проверка результатов.
    if (imitaAll.length != imitaFirst.length ||
            imitaAll.length != imitaSecond.length)
        throw new Exception("Error in computing imita");

    for (int i = 0; i &lt; imitaAll.length; i++)
        if (imitaAll[i] != imitaFirst[i] || imitaAll[i] != imitaSecond[i])
            throw new Exception("Error in computing imita");

    System.out.println("OK");
}
}
</java>
<java name="userSamples/Constants.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 26.05.2009 15:07:10 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

/**
 * Константы для примеров.
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class Constants {
/** Алгоритмы **/
/**
 * алгоритм ключа подписи: "GOST3410" или JCP.GOST_DEGREE_NAME
 */
public static final String SIGN_KEY_PAIR_ALG = "GOST3410";
/**
 * алгоритм ключа обмена: "GOST3410DH" или JCP.GOST_DH_NAME
 */
public static final String EXCH_KEY_PAIR_ALG = "GOST3410DH";
/**
 * стандарт сертификата "X509" или JCP.CERTIFICATE_FACTORY_NAME
 */
public static final String CF_ALG = "X509";
/**
 * алгоритм шифрования ГОСТ 28147-89: "GOST28147" или CryptoProvider.GOST_CIPHER_NAME
 */
public static final String CHIPHER_ALG = "GOST28147";
/**
 * алгоритм хеширования ГОСТ Р 34.11-94: "GOST3411" или JCP.GOST_DIGEST_NAME
 */
public static final String DIGEST_ALG = "GOST3411";
/**
 * алгоритм подписи ГОСТ Р 34.10-2001: "GOST3411withGOST3410EL" или
 * JCP.GOST_EL_SIGN_NAME
 */
public static final String SIGN_EL_ALG = "GOST3411withGOST3410EL";
/**
 * алгоритм подписи ГОСТ Р 34.10-2001 (используется для совеместимости с
 * криптопровайдером CryptoPro CSP): "CryptoProSignature" или
 * JCP.CRYPTOPRO_SIGN_NAME
 */
public static final String SIGN_CP_ALG = "CryptoProSignature";

/**
 * датчик случайных чисел: "CPRandom" или JCP.CP_RANDOM
 */
public static final String RANDOM_ALG = "CPRandom";

/** Параметры для работы с ключами и сертификатами **/
/**
 * тип хранилища:
 * &lt;p/&gt;
 * "HDImageStore" - жесткий диск
 * &lt;p/&gt;
 * "FloppyStore" - дискета, флешка
 * &lt;p/&gt;
 * "OCFStore" или "J6CFStore" - карточка
 */
public static final String KEYSTORE_TYPE = "HDImageStore";

/** Вспомогательные функции и параметры **/
/**
 * hex-string
 *
 * @param array массив данных
 * @return hex-string
 */
public static String toHexString(byte[] array) {
    final char[] hex = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
            'B', 'C', 'D', 'E', 'F'};
    StringBuffer ss = new StringBuffer(array.length * 3);
    for (int i = 0; i &lt; array.length; i++) {
        ss.append(' ');
        ss.append(hex[(array[i] &gt;&gt;&gt; 4) &amp; 0xf]);
        ss.append(hex[array[i] &amp; 0xf]);
    }
    return ss.toString();
}
}
</java>
<java name="userSamples/Digest.java">/**
 * $RCSfile$
 * version $Revision: 36383 $
 * created 14.04.2005 17:49:03 by elvira
 * last modified $Date: 2012-05-31 16:29:48 +0400 (Thu, 31 May 2012) $ by $Author: cross $
 * (C) ООО Крипто-Про 2004-2005.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.JCP.Digest.GostDigest;
import ru.CryptoPro.JCP.params.OID;

import java.io.ByteArrayInputStream;
import java.security.DigestInputStream;
import java.security.MessageDigest;

/**
 * В данном примере осуществляется создание хеша данных в соответствии с
 * алгоритмом ГОСТ Р 34.11-94.
 */
public class Digest {
/**
 * текст
 */
private static final String SAMPLE_TEXT = "message digest example";

/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    System.out.println("DigestInputStream: ");
    System.out.println(Constants.toHexString(computeDigestWithStream()));
    System.out.println("MessageDigest: ");
    System.out.println(Constants.toHexString(computeDigestWithoutStream()));
    System.out.println("CloneDigest with params: ");
    computeDigestWithClone();
    System.out.println("OK");
}

/**
 * Хеширование данных с использованием класса DigestInputStream
 *
 * @return значение хеша
 * @throws Exception /
 */
public static byte[] computeDigestWithStream() throws Exception {
    // создание объекта хеширования данных
    final MessageDigest digest =
            MessageDigest.getInstance(Constants.DIGEST_ALG);

    // обработка хешируемых данных
    final ByteArrayInputStream stream =
            new ByteArrayInputStream(SAMPLE_TEXT.getBytes());
    final DigestInputStream digestStream =
            new DigestInputStream(stream, digest);
    while (digestStream.available() != 0)
        digestStream.read();

    // вычисление значения хеша
    return digest.digest();
}

/**
 * Хеширование данных только при помощи класса MessageDigest
 *
 * @return значение хеша
 * @throws Exception /
 */
public static byte[] computeDigestWithoutStream() throws Exception {
    // создание объекта хеширования данных
    final MessageDigest digest =
            MessageDigest.getInstance(Constants.DIGEST_ALG);

    // обработка хешируемых данных
    final byte[] data = SAMPLE_TEXT.getBytes();
    digest.update(data);

    // вычисление значения хеша
    return digest.digest();
}

/**
 * Хеширование данных с заданными параметрами хеширования при помощи операции
 * копирования объекта хеширования
 *
 * @throws Exception /
 */
public static void computeDigestWithClone() throws Exception {
    // ВНИМАНИЕ! для совместимости с другими продуктами КриптоПро
    // допустимо использовать только параметры по умолчанию:
    // "1.2.643.2.2.30.1"

    final OID digestOID = new OID("1.2.643.2.2.30.2");
    // создание объекта хеширования данных
    final MessageDigest digest = MessageDigest.getInstance(Constants.DIGEST_ALG);

    // изменение параметров хеширования
    final GostDigest gostDigest = (GostDigest) digest;
    gostDigest.reset(digestOID);

    final byte[] data = SAMPLE_TEXT.getBytes();
    //первая часть данных
    final byte[] firstBloc = new byte[data.length / 2];
    //вторая часть данных
    final byte[] secondBloc = new byte[data.length - firstBloc.length];

    // обработка первой части хешируемых данных
    gostDigest.update(firstBloc);

    // копирование (сохранение) объекта хеширования после обработки
    // первой части
    final MessageDigest firstDigest = (MessageDigest) gostDigest.clone();

    // обработка второй части хешируемых данных
    gostDigest.update(secondBloc);

    // вычисление значения хеша первой части данных
    final byte[] resultFirst = firstDigest.digest();
    System.out.println(Constants.toHexString(resultFirst));

    // вычисление значения хеша всего массива данных
    final byte[] resultAll = gostDigest.digest();
    System.out.println(Constants.toHexString(resultAll));
}
}
</java>
<java name="userSamples/ExampleExtKUProcessor.java">/**
 * $RCSfile$
 * version $Revision: 36383 $
 * created 19.07.2006 19:20:54 by borodin
 * last modified $Date: 2012-05-31 16:29:48 +0400 (Thu, 31 May 2012) $ by $Author: cross $
 * (C) ООО Крипто-Про 2004-2006.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.JCP.params.OIDName;
import ru.CryptoPro.JCP.tools.CertReader.Extension;
import ru.CryptoPro.JCP.tools.CertReader.ExtensionProcessor;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

/**
 * Реализация обработчика расширения "Дополнительное использование ключа".
 * Пример использования классов Extension и ExtensionProcessor.
 * &lt;p/&gt;
 * &lt;p/&gt;
 * Необходимо запустить класс для регистрации, после чего запускать контрольную
 * панель, прописывая путь к данному классу. Расширение "Дополнительное
 * использование ключа" в сертификатах будет выводиться данным обработчиком.
 */
public class ExampleExtKUProcessor extends ExtensionProcessor {

/**
 * Идентификатор расширения "дополнительное ипользование ключа".
 */
private static final String OID_EXT_KEY_USAGE = "2.5.29.37";

/**
 * public - конструктор, нужен, чтобы объект класса мог быть создан
 * автоматически.
 */
public ExampleExtKUProcessor() {
}

/**
 * Определение метода
 *
 * @return строка OID
 */
public String getOID() {
    return OID_EXT_KEY_USAGE;
}

/**
 * Возвращает подрасширение для описания одного использования
 *
 * @param oid ID объекта использования
 * @return подрасширение, представляющее собой заголовок-название OID'а, с
 *         подстрокой - OID'ом, взятым в скобки, или, если такой OID неизвестен,
 *         только заголовок - OID в скобках.
 */
static Extension getOneUsage(String oid) {
    Extension ret;
    /**
     * выясняем имя
     */
    String name = OIDName.getName(oid);
    /**
     * формируем Extension - OID в скобках
     */
    Extension down = new Extension(Extension.O_BRAKE_SPACE.concat(oid)
            .concat(Extension.C_BRAKE));
    /**
     * если не смогли найти имя объекта идентификатора,
     */
    if (name.equals(oid)) {
        /**
         * возвращаем только OID,
         */
        ret = down;
    } else {
        /**
         * иначе возвращаем подрасширение, состоящее из заголовка-имени OID'а,
         * подстроки - OID'a в скобках. Оно будет отображаться с заголовком, с
         * подстрокой с табуляцией.
         */
        ret = new Extension(name, down, Extension.STANDARD_WITH_TITLE);
    }
    return ret;
}

/**
 * реализация метода возвращения текстового представления расширения
 *
 * @param cert сертификат, расширение которого рассматривается
 * @return текстовое представление расширения
 */
public Extension getExtension(X509Certificate cert) {
    /**
     * делаем вектор подрасширений
     */
    Vector strings = new Vector(0);
    try {
        /**
         * считываем список идентификаторов дополнительных использований.
         */
        List usg = cert.getExtendedKeyUsage();
        /**
         * если список не пуст, добавляем использования в вектор подрасширений
         */
        if (usg != null) {
            for (Iterator iter = usg.iterator(); iter.hasNext();) {
                strings.add(iter.next().toString());
            }
        } else {
            /**
             * иначе сообщаем об ошибке при прочтении расширения
             */
            strings.add(new Extension(getErrorParamMessage()));
        }
    } catch (CertificateParsingException e) {
        /**
         * в случае исключения сообщаем об ошибке.
         */
        strings.add(new Extension(getErrorParamMessage()));
    }
    /**
     * возвращаем расширение, с именем getName() и спском подстрок-расширений
     * strings. getName() вернет имя объекта идентификатора, если JCP данный OID
     * известен.
     */
    return new Extension(getName(), strings);
}

/**
 * регистрирует данный обработчик как основной для расширения
 *
 * @param args не используется
 */
public static void main(String[] args) {
    new ExampleExtKUProcessor().registerNewProcessor();
}
}
</java>
<java name="userSamples/KeyPairGen.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 14.04.2005 17:40:17 by elvira
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.JCP.params.AlgIdSpec;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;

/**
 * В данном примере осуществляется генерирование ключевой пары в соответствии с
 * алгоритмом ГОСТ Р 34.10-2001, генерирование сертификата созданного открытого
 * ключа, последующее сохранение в ключевом контейнере созданного закрытого
 * ключа и соответвующего ему сертификата открытого ключа, а также чтение только
 * что записанного ключа из контейнера.
 */
public class KeyPairGen {
/**
 * имя контейнера A
 */
public static final String CONT_NAME_A = "Cont_A";
/**
 * пароль на контейнер A
 */
public static final char[] PASSWORD_A = "a".toCharArray();
/**
 * имя субъекта сертификата A
 */
public static final String DNAME_A = "CN=Container_A, O=CryptoPro, C=RU";
/**
 * имя контейнера B
 */
public static final String CONT_NAME_B = "Cont_B";
/**
 * пароль на контейнер B
 */
public static final char[] PASSWORD_B = "b".toCharArray();
/**
 * имя субъекта сертификата B
 */
public static final String DNAME_B = "CN=Container_B, O=CryptoPro, C=RU";

/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //генерирование ключевой пары ЭЦП и запись в хранилище
    saveKeyWithCert(genKey(Constants.SIGN_KEY_PAIR_ALG), CONT_NAME_A,
            PASSWORD_A, DNAME_A);

    //генерирование ключевой пары ЭЦП с параметрами и запись в хранилище
    saveKeyWithCert(genKeyWithParams(Constants.SIGN_KEY_PAIR_ALG), CONT_NAME_B,
            PASSWORD_B, DNAME_B);

    // загрузка содержимого хранилища для чтения ключа
    final KeyStore hdImageStore = KeyStore.getInstance(Constants.KEYSTORE_TYPE);
    // загрузка содержимого носителя (предполагается, что не существует
    // хранилища доверенных сертификатов)
    hdImageStore.load(null, null);

    // получение закрытого ключа из хранилища
    final PrivateKey keyA = (PrivateKey) hdImageStore
            .getKey(CONT_NAME_A, PASSWORD_A);
    final PrivateKey keyB = (PrivateKey) hdImageStore
            .getKey(CONT_NAME_B, PASSWORD_B);

    System.out.println("OK");
}

/**
 * генерирование ключевой пары
 *
 * @param algorithm алгоритм
 * @return ключевая пара
 * @throws Exception /
 */
public static KeyPair genKey(String algorithm)
        throws Exception {

    // создание генератора ключевой пары
    final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm);

    // генерирование ключевой пары
    return keyGen.generateKeyPair();
}

/**
 * генерирование ключевой пары с параметрами
 *
 * @param algorithm алгоритм
 * @return ключевая пара
 * @throws Exception /
 */
public static KeyPair genKeyWithParams(String algorithm) throws Exception {
    final OID keyOid = new OID("1.2.643.2.2.19");
    final OID signOid = new OID("1.2.643.2.2.35.2");
    final OID digestOid = new OID("1.2.643.2.2.30.1");
    final OID cryptOid = new OID("1.2.643.2.2.31.1");

    // создание генератора ключевой пары ЭЦП
    final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm);

    // определение параметров генератора ключевой пары
    final AlgIdSpec keyParams =
            new AlgIdSpec(keyOid, signOid, digestOid, cryptOid);
    keyGen.initialize(keyParams);

    // генерирование ключевой пары
    return keyGen.generateKeyPair();
}

/**
 * Сохранение в хранилище
 *
 * @param pair сгенерированная ключевая пара
 * @param contName имя контейнера
 * @param password пароль на контенер
 * @param dname имя субъекта сертификата
 * @throws Exception /
 */
public static void saveKeyWithCert(KeyPair pair, String contName,
                                   char[] password, String dname)
        throws Exception {
    //* создание цепочки сертификатов, состоящей из самоподписанного сертификата
    final Certificate[] certs = new Certificate[1];
    certs[0] = genSelfCert(pair, dname);

    //* запись закрытого ключа и цепочки сертификатов в хранилище
    // определение типа ключевого носителя, на который будет осуществлена запись ключа
    final KeyStore hdImageStore = KeyStore.getInstance(Constants.KEYSTORE_TYPE);
    // загрузка содержимого носителя (предполагается, что не существует
    // хранилища доверенных сертификатов)
    hdImageStore.load(null, null);
    // запись на носитель закрытого ключа и цепочки
    hdImageStore.setKeyEntry(contName, pair.getPrivate(), password, certs);
    // сохранение содержимого хранилища
    hdImageStore.store(null, null);
}

/**
 * Генерирование самоподписанного сертификата
 *
 * @param pair ключевая пара
 * @param dname имя субъекта сертификата
 * @return самоподписанный сертификат
 * @throws Exception /
 */
public static Certificate genSelfCert(KeyPair pair, String dname)
        throws Exception {
    // создание генератора самоподписанного сертификата
    final GostCertificateRequest gr = new GostCertificateRequest();
    // генерирование самоподписанного сертификата, возвращаемого в DER-кодировке
    final byte[] enc = gr.getEncodedSelfCert(pair, dname);
    // инициализация генератора X509-сертификатов
    final CertificateFactory cf =
            CertificateFactory.getInstance(Constants.CF_ALG);
    // генерирование X509-сертификата из закодированного представления сертификата
    return cf.generateCertificate(new ByteArrayInputStream(enc));
}
}
</java>
<java name="userSamples/NogaevPNExample.java">package userSamples;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import ru.CryptoPro.JCP.tools.JCPLogger;

import java.io.FileInputStream;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.Security;
import java.security.cert.*;
import java.util.*;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 08.07.12
 * Time: 21:32
 * To change this template use File | Settings | File Templates.
 */
// http://cryptopro.ru/forum2/Default.aspx?g=posts&amp;t=4905
public class NogaevPNExample {

    public static void main(String[] args) throws Exception {

        Security.addProvider(new BouncyCastleProvider());

        System.setProperty("com.sun.security.enableCRLDP", "true");
        System.setProperty("com.ibm.security.enableCRLDP", "true");

        // уникальное имя корневого сертификата
        final String aliasRootCert = "rootCert";
        // уникальное имя промежуточного сертификата
        final String aliasInterCert = "intermediateCert";
        // уникальное имя сертификата открытого ключа
        final String aliasEndCert = "endCert";

        //инициализация хранилища доверенных сертификатов и ключевого носителя
        final KeyStore keyStore = KeyStore.getInstance("HDImageStore");

        // загрузка содержимого хранилища (предполагается, что хранилище,
        // проинициализированное именем STORE_TYPE существует) и содержимого
        // ключевого носителя
        keyStore.load(new FileInputStream("C:/TESTS/User/NogaevPN/certstore1"), "pass123".toCharArray());

        // чтение корневого сертификата из хранилища доверенных сертификатов
        // (предполагается, что такой сертификат существует в хранилище)
        final Certificate certRoot = keyStore.getCertificate(aliasRootCert);

        // чтение промежуточного сертификата из хранилища доверенных сертификатов
        // (предполагается, что такой сертификат существует в хранилище)
        final Certificate certInter = keyStore.getCertificate(aliasInterCert);

        // чтение конечного сертификата (сертификата открытого ключа) с носителя
        // (предполагается, что сертификат такой сертификат существует на носителе)
        final Certificate certEnd = keyStore.getCertificate(aliasEndCert);

        //Построение цепочки из прочитанных сертификатов, начиная с корневого сертификата
        //(с именем aliasRootCert) и заканчивая сертификатом открытого ключа (c именем aliasEndCert)

        // определение списка сертификатов, из которых
        // осуществляется построение цепочки
        final List&lt;Certificate&gt; certs = new ArrayList&lt;Certificate&gt;(3);
        //certs.add(certRoot);
        certs.add(certInter);
        certs.add(certEnd);

        // определение корневого сертификата (с которого начинается построение
        // цепочки)
        final TrustAnchor anchor =
                new TrustAnchor((X509Certificate) certRoot, null);

        // определение параметров специального хранилища
        // сертификатов, в которое записываются все используемые
        // в построении цепочки сертификаты
        final CollectionCertStoreParameters par =
                new CollectionCertStoreParameters(certs);

        // создание специального хранилища сертификатов на основе
        // параметров, определенных списком сертификатов
        final CertStore store = CertStore.getInstance("Collection", par);

        // инициализация объекта построения цепочки сертификатов
        final CertPathBuilder cpb = CertPathBuilder.getInstance("PKIX");
        //или для совместимости с КриптоПро УЦ
        //CertPathBuilder cpb = CertPathBuilder.getInstance("CPPKIX", "RevCheck");

        // инициализация параметров построения цепочки сертификатов
        PKIXBuilderParameters params = new PKIXBuilderParameters(
                Collections.singleton(anchor), new X509CertSelector());

        params.setSigProvider("JCP");
        params.setRevocationEnabled(false);

        // добавление к параметрам сертификатов, из которых
        // будет строиться цепочка
        params.addCertStore(store);

        // инициализация объекта выборки сертификата, которым
        // заканчивается построение цепочки
        final X509CertSelector selector = new X509CertSelector();

        // определение сертификата, которым
        // заканчивается построение цепочки
        selector.setCertificate((X509Certificate) certEnd);

        params.setTargetCertConstraints(selector);

        // построение цепочки сертификатов
        final PKIXCertPathBuilderResult res =
                (PKIXCertPathBuilderResult) cpb.build(params);

        params = new PKIXBuilderParameters(
                Collections.singleton(anchor), new X509CertSelector());

        // Проверка построенной цепочки сертификатов
        params.addCertStore(store);
        params.setSigProvider("JCP");
        params.setRevocationEnabled(true);
        //Security.setProperty("ocsp.enable", "true");
        params.setTargetCertConstraints(selector);

        // инициализация объекта проверки цепочки сертификатов
        final CertPathValidator validator = CertPathValidator.getInstance("PKIX");
        //или для совместимости с КриптоПро УЦ
        //CertPathValidator validator = CertPathValidator.getInstance("CPPKIX", "RevCheck");

        // проверка цепочки сертификатов
        final CertPathValidatorResult val_res =
                validator.validate(res.getCertPath(), params);

        // вывод результата проверки в строком виде
        System.out.println(val_res.toString());

    }
}
</java>
<java name="userSamples/OCSPValidateCert.java">/**
 * $RCSfile$
 * version $Revision: 36480 $
 * created 06.10.2008 17:31:06 by kunina
 * last modified $Date: 2012-08-06 21:15:25 +0400 (Mon, 06 Aug 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import java.io.ByteArrayInputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.Security;
import java.security.cert.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Только для java 1.5 и выше.
 * &lt;p/&gt;
 * http://java.sun.com/javase/6/docs/technotes/guides/security/certpath/CertPathProgGuide.html
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class OCSPValidateCert {

public static void main(String[] args) throws Exception {

    final KeyPairGenerator kg =
            KeyPairGenerator.getInstance("GOST3410");
    final KeyPair pair = kg.generateKeyPair();

    final GostCertificateRequest req = new GostCertificateRequest();
    req.init("GOST3410", false);
    req.setPublicKeyInfo(pair.getPublic());
    req.setSubjectInfo("CN=TEST_OCSP");
    req.encodeAndSign(pair.getPrivate());

    final byte[] encodedCert =
            req.getEncodedCert("http://www.cryptopro.ru/certsrv/");
    final byte[] encodedRootCert = GostCertificateRequest
            .getEncodedRootCert("http://www.cryptopro.ru/certsrv/");
    final CertificateFactory cf = CertificateFactory.getInstance("X509");
    final Certificate crt =
            cf.generateCertificate(new ByteArrayInputStream(encodedCert));
    final Certificate tr =
            cf.generateCertificate(new ByteArrayInputStream(encodedRootCert));

    //Настройки ocsp
    Security.setProperty("ocsp.enable", "true");
    //тестовый УЦ КриптоПРО
    //корневой сертификат
    Security.setProperty("ocsp.responderCertSubjectName",
            "CN=Test Center CRYPTO-PRO,O=CRYPTO-PRO,C=RU,EMAILADDRESS=info@cryptopro.ru");
    //доступ к сведениям центра сертификации
    Security.setProperty("ocsp.responderURL",
            "http://www.cryptopro.ru/ocspnc/ocsp.srf");

    //Сертификаты (в данном случае корневой и пользователя, выданный УЦ)
    final Certificate[] certs = new Certificate[2];
    certs[0] = crt;
    certs[1] = tr;  //root

    final Set trust = new HashSet(0);
    trust.add(new TrustAnchor((X509Certificate) tr, null));

    final List cert = new ArrayList(0);
    for (int i = 0; i &lt; certs.length; i++)
        cert.add(certs[i]);

    //Параметры
    final PKIXBuilderParameters cpp = new PKIXBuilderParameters(trust, null);
    cpp.setSigProvider(null);
    final CollectionCertStoreParameters par =
            new CollectionCertStoreParameters(cert);
    final CertStore store = CertStore.getInstance("Collection", par);
    cpp.addCertStore(store);
    final X509CertSelector selector = new X509CertSelector();
    selector.setCertificate((X509Certificate) crt);
    cpp.setTargetCertConstraints(selector);

    //Сертификаты (CertPath)
    //1)просто из списка сертификатов (в правильном порядке)
    //final CertificateFactory cf = CertificateFactory.getInstance("X509");
    //final CertPath cp = cf.generateCertPath(cert);

    //2) построение цепочки
    //а) с проверкой crl
    //cpp.setRevocationEnabled(true);
    //для использования расширения сертификата CRL Distribution Points
    //установить System.setProperty("com.sun.security.enableCRLDP", "true");
    //или System.setProperty("com.ibm.security.enableCRLDP", "true");

    //б) без проверки crl
    cpp.setRevocationEnabled(false);
    final PKIXCertPathBuilderResult res =
            (PKIXCertPathBuilderResult) CertPathBuilder.
                    getInstance("PKIX").build(cpp);
    final CertPath cp = res.getCertPath();

    System.out.println(cp);

    //Проверка
    final CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
    cpp.setRevocationEnabled(true);
    cpv.validate(cp, cpp);

    System.out.println("OK");
}
}
</java>
<java name="userSamples/Random.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 14.04.2005 16:59:29 by elvira
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import java.security.SecureRandom;

/**
 * Пример использования генератора случайных чисел.
 */
public class Random {
/**
 * длина вектора
 */
private static final int RND_LENGTH = 8;

/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    final byte[] randomBytes = new byte[RND_LENGTH];
    final SecureRandom random = SecureRandom.getInstance(Constants.RANDOM_ALG);
    random.nextBytes(randomBytes);

    System.out.println("Random bytes are:");
    System.out.println(Constants.toHexString(randomBytes));
    System.out.println("OK");
}
}
</java>
<java name="userSamples/SessionEncrypt.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 26.09.2005 14:44:17 by elvira
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.KeyPair;
import java.security.SecureRandom;
import java.security.cert.Certificate;

/**
 * В данном примере производится зашифрование и расшифрование текста на
 * симметричном ключе. Для передачи этого ключа произоводится его зашифрование и
 * расшифрование на ключах согласования сторон.
 */
public class SessionEncrypt {
/**
 * текст
 */
private static final String SAMPLE_TEXT = "Classic encryption/decryption";
/**
 * длина вектора
 */
private static final int RND_LENGTH = 8;
/**
 * Алгоритм шифрования
 */
private static final String CIPHER_ALG = "GOST28147/CFB/NoPadding";

public static final int randomLength = 8;

public static void main(String[] args) throws Exception {
    final byte[] data = SAMPLE_TEXT.getBytes();
    /**На каждой стороне должны присутствовать:
     * - свой закрытый ключ
     * - открытый ключ второй стороны (сертификат)**/

    /* Генерирование закрытых ключей сторон */
    final KeyPair alisaPair = KeyPairGen.genKey(Constants.EXCH_KEY_PAIR_ALG);
    final KeyPair bobPair = KeyPairGen.genKey(Constants.EXCH_KEY_PAIR_ALG);

    /* Генерирование самоподписанных сертификатов сторон */
    final Certificate alisaCert = KeyPairGen
            .genSelfCert(alisaPair, "CN=ALISA_CERTIFICATE, O=CryptoPro, C=RU");
    final Certificate bobCert = KeyPairGen
            .genSelfCert(bobPair, "CN=BOB_CERTIFICATE, O=CryptoPro, C=RU");

    /* Генерирование начальной синхропосылки для выработки ключа согласования*/
    final byte[] sv = new byte[RND_LENGTH];
    final SecureRandom random = SecureRandom.getInstance(Constants.RANDOM_ALG);
    random.nextBytes(sv);
    final IvParameterSpec ivspec = new IvParameterSpec(sv);

    /* Выработка ключа согласования алисы c SV*/
    final KeyAgreement alisaKeyAgree =
            KeyAgreement.getInstance(Constants.EXCH_KEY_PAIR_ALG);
    alisaKeyAgree.init(alisaPair.getPrivate(), ivspec, null);
    alisaKeyAgree.doPhase(bobCert.getPublicKey(), true);
    final SecretKey alisaAgree =
            alisaKeyAgree.generateSecret(Constants.CHIPHER_ALG);

    /* Генерирование симметричного ключа алисой с параметрами шифрования из контрольной панели*/
    final KeyGenerator keyGen = KeyGenerator.getInstance(Constants.CHIPHER_ALG);
    final SecretKey simm = keyGen.generateKey();

    /* Зашифрование текста на симметричном ключе алисы*/
    Cipher cipher = Cipher.getInstance(CIPHER_ALG);
    cipher.init(Cipher.ENCRYPT_MODE, simm);
    // передача вектора инициализации бобу
    final byte[] iv = cipher.getIV();
    final byte[] encryptedtext = cipher.doFinal(data, 0, data.length);

    /*Зашифрование симметричного ключа на ключе согласования алисы*/
    cipher.init(Cipher.WRAP_MODE, alisaAgree);
    final byte[] wrappedKey = cipher.wrap(simm);

    /* Выработка ключа согласования боба с тем же SV. */
    final KeyAgreement bobKeyAgree =
            KeyAgreement.getInstance(Constants.EXCH_KEY_PAIR_ALG);
    bobKeyAgree.init(bobPair.getPrivate(), ivspec, null);
    bobKeyAgree.doPhase(alisaCert.getPublicKey(), true);
    final SecretKey bobAgree =
            bobKeyAgree.generateSecret(Constants.CHIPHER_ALG);

    /* Расшифрование бобом симметричного ключа.*/
    cipher.init(Cipher.UNWRAP_MODE, bobAgree);
    final SecretKey simmKey = (SecretKey) cipher
            .unwrap(wrappedKey, null, Cipher.SECRET_KEY);

    /* Расшифрование бобом текста на расшифрованном симметричном ключе. IV передан от алисы*/
    cipher = Cipher.getInstance(CIPHER_ALG);
    cipher.init(Cipher.DECRYPT_MODE, simmKey, new IvParameterSpec(iv), null);
    final byte[] decryptedtext = cipher
            .doFinal(encryptedtext, 0, encryptedtext.length);

    // проверка результата.
    if (decryptedtext.length != data.length)
        throw new Exception("Error in crypting");
    for (int i = 0; i &lt; decryptedtext.length; i++)
        if (data[i] != decryptedtext[i])
            throw new Exception("Error in crypting");

    System.out.println("OK");
}
}
</java>
<java name="userSamples/SignAndVerify.java">/**
 * $RCSfile$
 * version $Revision: 36497 $
 * created 14.04.2005 18:01:52 by elvira
 * last modified $Date: 2012-08-14 12:24:21 +0400 (Tue, 14 Aug 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.JCP.params.DigestParamsSpec;
import ru.CryptoPro.JCP.params.OID;
import ru.CryptoPro.JCP.params.ParamsInterface;
import ru.CryptoPro.JCP.tools.Platform;

import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;

/**
 * В данном примере осуществляется создание и проверка ЭЦП в соответствии с
 * алгоритмом ГОСТ Р 34.10-2001.
 */
public class SignAndVerify {
/**
 * текст
 */
private static final String SAMPLE_TEXT = "generating and verifing signature";

/**
 * @param args null
 * @throws Exception /
 */
public static void main(String[] args) throws Exception {
    //* Генерирование ключевой пары
    final KeyPair keyPair = KeyPairGen.genKey(Constants.SIGN_KEY_PAIR_ALG);

    //* Создание подписи "GOST3411withGOST3410EL"
    final byte[] signEL = sign(Constants.SIGN_EL_ALG, keyPair.getPrivate(),
            SAMPLE_TEXT.getBytes());
    System.out.println("Value of signature (signEL) is:");
    System.out.println(Constants.toHexString(signEL));
    // Проверка подписи
    final boolean signELver = verify(Constants.SIGN_EL_ALG, keyPair.getPublic(),
            SAMPLE_TEXT.getBytes(), signEL);
    System.out.println("Signature verifies (signEL) is: " + signELver);

    //* Создание подписи "CryptoProSignature" (совместимо с КриптоПро CSP)
    final byte[] signCP = sign(Constants.SIGN_CP_ALG, keyPair.getPrivate(),
            SAMPLE_TEXT.getBytes());
    System.out.println("Value of signature (signCP) is:");
    System.out.println(Constants.toHexString(signCP));
    // Проверка подписи
    final boolean signCPver = verify(Constants.SIGN_CP_ALG, keyPair.getPublic(),
            SAMPLE_TEXT.getBytes(), signCP);
    System.out.println("Signature verifies (signCP) is: " + signCPver);

    //* Создание подписи с изменением параметров хеширования

    // ВНИМАНИЕ! для совместимости с другими продуктами КриптоПро
    // допустимо использовать только параметры по умолчанию:
    // DigestParamsSpec.OID_HashVerbaO ("1.2.643.2.2.30.1")

    final OID digestOid = DigestParamsSpec.OID_HashVar_1; //"1.2.643.2.2.30.2";
    final ParamsInterface digestParams =
            DigestParamsSpec.getInstance(digestOid);

    //подпись
    final byte[] sign = sign(Constants.SIGN_EL_ALG, keyPair.getPrivate(),
            SAMPLE_TEXT.getBytes(), digestParams);
    System.out.println("Value of signature (sign) is:");
    System.out.println(Constants.toHexString(sign));
    // Проверка подписи с изменением параметров хеширования
    final boolean ver = verify(Constants.SIGN_EL_ALG, keyPair.getPublic(),
            SAMPLE_TEXT.getBytes(), sign, digestParams);
    System.out.println("Signature verifies (sign) is: " + ver);

    System.out.println("OK");
}

/**
 * Создание подписи
 *
 * @param alghorithmName алгоритм подписи
 * @param privateKey закрытый ключ
 * @param data подписываемые данные
 * @return подпись
 * @throws Exception /
 */
public static byte[] sign(String alghorithmName, PrivateKey privateKey,
                          byte[] data) throws Exception {
    final Signature sig = Signature.getInstance(alghorithmName);
    sig.initSign(privateKey);
    sig.update(data);
    return sig.sign();
}

/**
 * Создание подписи с изменением параметров хеширования
 *
 * @param alghorithmName алгоритм подписи
 * @param privateKey закрытый ключ
 * @param data подписываемые данные
 * @param digestParams параметры хеширования
 * @return подпись
 * @throws Exception /
 */
public static byte[] sign(String alghorithmName, PrivateKey privateKey,
                          byte[] data, ParamsInterface digestParams)
        throws Exception {
    final Signature sig = Signature.getInstance(alghorithmName);
    sig.initSign(privateKey);
    /**
     * Java производства IBM не поддерживает установку параметров.
     */
    if (!Platform.isIBM()) {
        sig.setParameter(digestParams);
    }
    sig.update(data);
    return sig.sign();
}

/**
 * Проверка подписи на открытом ключе
 *
 * @param alghorithmName алгоритм подписи
 * @param publicKey открытый ключ
 * @param data подписываемые данные
 * @param signature подпись
 * @return true - верна, false - не верна
 * @throws Exception /
 */
public static boolean verify(String alghorithmName, PublicKey publicKey,
                             byte[] data, byte[] signature) throws Exception {
    final Signature sig = Signature.getInstance(alghorithmName);
    sig.initVerify(publicKey);
    sig.update(data);
    return sig.verify(signature);
}

/**
 * Проверка подписи на открытом ключе с изменением параметров хеширования
 *
 * @param alghorithmName алгоритм подписи
 * @param publicKey открытый ключ
 * @param data подписываемые данные
 * @param signature подпись
 * @param digestParams параметры хеширования
 * @return true - верна, false - не верна
 * @throws Exception /
 */
public static boolean verify(String alghorithmName, PublicKey publicKey,
                             byte[] data, byte[] signature,
                             ParamsInterface digestParams) throws Exception {
    final Signature sig = Signature.getInstance(alghorithmName);
    sig.initVerify(publicKey);
    /**
     * Java производства IBM не поддерживает установку параметров.
     */
    if (!Platform.isIBM()) {
        sig.setParameter(digestParams);
    }

    sig.update(data);
    return sig.verify(signature);
}
}
</java>
<java name="userSamples/SpeedTest.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 13.10.2008 14:47:53 by Iva
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2008.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import ru.CryptoPro.Crypto.CryptoProvider;
import ru.CryptoPro.JCP.JCP;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.ProviderException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.util.Arrays;

/**
 * Определение скоростей JCP.
 *
 * @author Copyright 2004-2008 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class SpeedTest {
/**
 * size of byte array.
 */
public static final int BLOCK_SIZE = 16384;
/**
 * repeate amount.
 */
public static final int LOOPS_AMOUNT = 1000;

/**
 * Static class, ctor forbidden.
 */
private SpeedTest() {
}

/**
 * main.
 *
 * @param args not used.
 * @throws Exception any error
 */
public static void main(String[] args) throws Exception {

    byte[] testText = new byte[8];
    byte[] longText = new byte[BLOCK_SIZE];
    long startTime;
    long endTime;
    // create objects
    MessageDigest digest = MessageDigest.getInstance(JCP.GOST_DIGEST_NAME);
    SecureRandom random = SecureRandom.getInstance(JCP.CP_RANDOM);
    IvParameterSpec params = new IvParameterSpec(testText);
    Cipher cipher = Cipher.getInstance("GOST28147/CFB/NoPadding");
    // generate keys
    KeyGenerator kg = KeyGenerator.getInstance(CryptoProvider.GOST_CIPHER_NAME);
    SecretKey key = kg.generateKey();
    KeyPairGenerator keyGen =
            KeyPairGenerator.getInstance(CryptoProvider.GOST_EPH_DH_NAME);
    java.security.KeyPair pair = keyGen.generateKeyPair();
    PrivateKey privateKey = pair.getPrivate();
    PublicKey publicKey = pair.getPublic();
    // test create sign
    Signature signature = Signature.getInstance(JCP.GOST_EL_SIGN_NAME);
    signature.initSign(privateKey);
    signature.update(testText);
    byte[] signBytes = signature.sign();
    // test verify sign
    signature.initVerify(publicKey);
    signature.update(testText);
    if (!signature.verify(signBytes))
        throw new ProviderException();
    // test encrypt
    cipher.init(Cipher.ENCRYPT_MODE, key, params);
    byte[] encryptResult = cipher.doFinal(testText);
    cipher.init(Cipher.DECRYPT_MODE, key, params);
    byte[] decryptResult = cipher.doFinal(encryptResult);
    if (!Arrays.equals(decryptResult, testText))
        throw new ProviderException();

    // test random speed
    random.nextBytes(longText);
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; LOOPS_AMOUNT; i++) {
        random.nextBytes(longText);
    }
    endTime = System.currentTimeMillis();
    long randomSpeed =
            ((long) BLOCK_SIZE * LOOPS_AMOUNT) / (endTime - startTime);

    // test digest speed.
    digest.update(longText);
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; LOOPS_AMOUNT; i++) {
        digest.update(longText);
    }
    endTime = System.currentTimeMillis();
    long digestSpeed =
            ((long) BLOCK_SIZE * LOOPS_AMOUNT) / (endTime - startTime);

    // test encrypt speed
    cipher.init(Cipher.ENCRYPT_MODE, key, params);
    cipher.update(longText);
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; LOOPS_AMOUNT; i++) {
        cipher.update(longText);
    }
    endTime = System.currentTimeMillis();
    long cryptSpeed =
            ((long) BLOCK_SIZE * LOOPS_AMOUNT) / (endTime - startTime);

    // test sign speed
    signature.initSign(privateKey);
    signature.update(testText);
    signature.sign();
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; LOOPS_AMOUNT; i++) {
        signature.initSign(privateKey);
        signature.update(testText);
        signature.sign();
    }
    endTime = System.currentTimeMillis();
    long signTime = endTime - startTime;

    // test verify speed
    signature.initVerify(publicKey);
    signature.update(testText);
    signature.verify(signBytes);
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; LOOPS_AMOUNT; i++) {
        signature.initVerify(publicKey);
        signature.update(testText);
        signature.verify(signBytes);
    }
    endTime = System.currentTimeMillis();
    long verifyTime = endTime - startTime;

    System.out.println("Random Speed:" + randomSpeed + " KB per sec.");
    System.out.println("Digest Speed:" + digestSpeed + " KB per sec.");
    System.out.println("Crypt speed:" + cryptSpeed + " KB per sec.");
    System.out.println("Signature generation time: " +
            signTime / LOOPS_AMOUNT + "." + signTime % LOOPS_AMOUNT);
    System.out.println("Signature verify time: " +
            verifyTime / LOOPS_AMOUNT + "." + verifyTime % LOOPS_AMOUNT);
}
}
</java>
<java name="userSamples/XWSXmlDSig.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 28.02.2005 21:10:08 by avsh
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 *  (C) ООО Крипто-Про 2004-2005.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.signature.ObjectContainer;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.XMLUtils;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.TransformerException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;

/**
 * Пример XML подписи.
 */

public class XWSXmlDSig {
private String signMethod;      //метод подписи
private String digestMethod;    //метод получения хеша
private String transform;       //метод преобразования для получения хеша
private X509Certificate cert;   //сертификат открытого ключа, соответствующий закрытому (для включения в состав
// документа и обеспечения возможности проверки)
private PrivateKey privateKey;  //закрытый ключ на котором будеит осуществляться подпись

//методы для задания и получения соответствующих атрибутов

public String getSignMethod() {
    return signMethod;
}

public String getDigestMethod() {
    return signMethod;
}

public void setSignMethod(String SM) {
    signMethod = SM;
}

public void setdigestMethod(String DM) {
    digestMethod = DM;
}

public void SetCertificate(X509Certificate Cer) {
    cert = Cer;
    //смотрим содержимое сертификата и в соответствии с ним выставляем алгоритмы хеширования и подписи
    // обозначен алгоритм подписи RSA он не обязательно должен использовать хеш SHA1
    if (algEquals(cert.getPublicKey().getAlgorithm(),
            XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1)) {
        signMethod = XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1;
        digestMethod = Constants.ALGO_ID_DIGEST_SHA1;
    }
    if (algEquals(cert.getPublicKey().getAlgorithm(),
            XMLSignature.ALGO_ID_SIGNATURE_DSA)) {
        signMethod = XMLSignature.ALGO_ID_SIGNATURE_DSA;
        digestMethod = Constants.ALGO_ID_DIGEST_SHA1;
    }
}

public X509Certificate getCertificate() {
    return cert;
}

public PrivateKey getPrivateKey() {
    return privateKey;
}

public void setPrivateKey(PrivateKey pKey) {
    privateKey = pKey;
}

public XWSXmlDSig() {// по-умолчанию считается что алгоритм подписи RSA алгоритм хеширования SHA1 а метод
    // преобразования для получения хеша ENVELOPED
    signMethod = XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1;
    digestMethod = Constants.ALGO_ID_DIGEST_SHA1;
    transform = Transforms.TRANSFORM_C14N_WITH_COMMENTS;
}

static {
    ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit.init();
}

// метод подисывающий объект

public Document SignObject() throws Exception {

    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(true);
    Document doc = dbf.newDocumentBuilder().newDocument();


    XMLSignature sig = new XMLSignature(doc, "", signMethod);
    doc.appendChild(sig.getElement()); // подцепляем подпись


    ObjectContainer obj = new ObjectContainer(doc);
    Element anElement = doc.createElement(
            "InsideObject");   // создаем внутри подписи подписываемый объект

    anElement.appendChild(doc.createTextNode("A text in a box"));
    obj.appendChild(anElement);

    String Id = "TheFirstObject";

    obj.setId(Id);
    sig.appendObject(obj);


    Transforms transforms = new Transforms(doc);
    transforms.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);
    transforms.addTransform(transform);

    sig.addDocument("", transforms,
            digestMethod);  // добавление ref (пустая =&gt; на текущий д-т)


    sig.addKeyInfo(cert);

    sig.sign(privateKey);
    return doc;
}

// метод проверки подписи документа

public static boolean Validate(Document doc)
        throws TransformerException, XMLSecurityException {
    Element nscontext = XMLUtils
            .createDSctx(doc, "ds", Constants.SignatureSpecNS);

    Element sigElement = (Element) XPathAPI.selectSingleNode(doc,
            "//ds:Signature[1]", nscontext);
    XMLSignature signature = new XMLSignature(sigElement, "");

    KeyInfo ki = signature.getKeyInfo();

    if (ki != null) {
        if (ki.containsX509Data()) {
            System.out
                    .println("Could find a X509Data element in the KeyInfo");
        }

        X509Certificate cert = signature.getKeyInfo().getX509Certificate();

        if (cert != null) {

            System.out.println("The XML signature  is "
                    + (signature.checkSignatureValue(cert)
                    ? "valid (good)"
                    : "invalid !!!!! (bad)"));
        } else {
            System.out.println("Did not find a Certificate");

            PublicKey pk = signature.getKeyInfo().getPublicKey();

            if (pk != null) {

                System.out.println(
                        "I try to verify the signature using the public key: "
                                + pk);

                System.out.println("The XML signature is "
                        + (signature.checkSignatureValue(pk)
                        ? "valid (good)"
                        : "invalid !!!!! (bad)"));
            } else {
                System.out.println(
                        "Did not find a public key, so I can't check the signature");
                return false;
            }
        }
    } else {
        System.out.println("Did not find a KeyInfo");
        return false;
    }

    return true;
}


static boolean algEquals(String algURI, String algName) {
    if (algName.equalsIgnoreCase("DSA") &amp;&amp;
            algURI.equalsIgnoreCase(XMLSignature.ALGO_ID_SIGNATURE_DSA)) {
        return true;
    } else if (algName.equalsIgnoreCase("RSA") &amp;&amp;
            algURI.equalsIgnoreCase(XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1)) {
        return true;
    } else if (algName.equalsIgnoreCase("1.2.643.2.2.20") &amp;&amp;
            algURI.equalsIgnoreCase(
                    "http://www.w3.org/2001/04/xmldsig-more#gostr34101994-gostr3411")) {
        return true;
    } else {
        return false;
    }
}
}

</java>
<java name="userSamples/XmlDSigTest.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 30.12.2004 15:28:45 by avsh
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2005.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package userSamples;

import org.w3c.dom.Document;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

/**
 * В данном примере осуществляется создание подписанного XML-документа в
 * соответствии с алгоритмом ГОСТ Р 34.10-2001.
 */
public class XmlDSigTest {
public static void main(String[] args) throws Exception {
    System.out.println("Example of signing XML document:");
    String KeyPairAlgorithm = "GOST3410";
    // генерирование ключевой пары
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(KeyPairAlgorithm);
    java.security.KeyPair pair = keyGen.generateKeyPair();
    PrivateKey privKey = pair.getPrivate();
    System.out.println("Key pair is generated");
    // генерирование сертификата
    GostCertificateRequest gr = new GostCertificateRequest();
    byte[] enc = gr.getEncodedSelfCert(pair, "CN=newCert, O=CryptoPro, C=RU");
    CertificateFactory cf = CertificateFactory.getInstance("X509");
    X509Certificate cert = (X509Certificate) cf
            .generateCertificate(new ByteArrayInputStream(enc));

    System.out.println("Certificate is generated");
    //создание пустого XML документа
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(true);
    Document doc = dbf.newDocumentBuilder().newDocument();
    //создаем объект подписывающий XML документы
    XWSXmlDSig xmldsig = new XWSXmlDSig();
    //передаем закрытый ключ созданному объекту
    xmldsig.setPrivateKey(privKey);
    //передаем созданному объеку извлеченный сертификат
    xmldsig.SetCertificate(cert);
    xmldsig.setSignMethod(
            "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411");
    xmldsig.setdigestMethod("http://www.w3.org/2001/04/xmldsig-more#gostr3411");

    //подписываем созданный документ
    doc = xmldsig.SignObject();
    //печатаем подписанный документ в файл
    OutputStream os;
    os = new FileOutputStream("XmlDSigObject.xml");

    TransformerFactory tf = TransformerFactory.newInstance();
    Transformer trans = tf.newTransformer();
    trans.transform(new DOMSource(doc), new StreamResult(os));
    os.close();

    //загружаем подписанный документ из файла и проверяем его подпись
    doc = dbf.newDocumentBuilder().parse("XmlDSigObject.xml");
    boolean res = XWSXmlDSig.Validate(doc);
    if (res) {
        System.out.println(
                "Test for sign and verify object of XML document is passed");
        System.out.println();
    }
}
}



</java>
<java name="userSamples/ca15/Configuration.java">package userSamples.ca15;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 12.11.12
 * Time: 17:29
 * To change this template use File | Settings | File Templates.
 */

/**
 * Класс Configuration описывает параметры пользователя:
 * его имя (COMMON_NAME) и страну (COUNTRY_NAME), которые использовались при
 * регистрации и которые нужны при генерации запрос на сертификат;
 * его tokenID и password, полученные при регистрации и соответствующие
 * имени пользователя.
 *
 * Предполагается, что данные пользователь уже зарегистрирован, потому рекомендуется
 * запускать примеры в таком порядке:
 * 1) GetRootCertificateExample - получение списка корневых сертификатов УЦ;
 * 2) RegisterUserExample - регистрация пользователя с именем COMMON_NAME и COUNTRY_NAME
 * и получение tokenID и password, которые следует сохранить в конфигурации;
 * 3) SendRequestAndGetCertificateExample - отправка запроса на сертификат с параметрами
 * COMMON_NAME и COUNTRY_NAME от имени пользователя tokenID и password и получение сертификата;
 * 4) GetUserCertificateRequestListExample - получение списка запросов на сертификаты
 * зарегистрированного пользователя tokenID и password.
 */
public class Configuration {

    /**
     * Поле CN (CommonName).
     */
    // TODO заменить имя.
    public static final String COMMON_NAME = "afevma_011";
    /**
     * Поле C (CountryName).
     */
    public static final String COUNTRY_NAME = "RU";
    /**
     * Маркер зарегистрированного пользователя.
     */
    // TODO заменить маркер.
    public static final String TOKEN_ID = "1951";
    /**
     * Пароль зарегистрированного пользователя.
     */
    // TODO заменить пароль.
    public static final String PASSWORD = "puu233c8";
}
</java>
<java name="userSamples/ca15/GetRootCertificateExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package userSamples.ca15;

import ru.CryptoPro.JCPRequest.ca15.request.CA15GostCertificateRequest;

import java.io.IOException;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 10.11.12
 * Time: 15:47
 * To change this template use File | Settings | File Templates.
 */

/**
 * Пример получения списка корневых сертификатов УЦ (CA15).
 */
public class GetRootCertificateExample {

    public static void main(String[] args) throws IOException {

        // Получаем список сертификатов. Если не удастся получить по
        // HTTP, то следует попробовать загрузить по HTTPS (см. другие
        // примеры с SSL-инициализацией).
        Certificate[] rootCerts = CA15GostCertificateRequest
            .getRootCertList("http://www.cryptopro.ru/ui");

        if (rootCerts != null) {

            // Выводим сертификаты на экран.
            for (int i = 0; i &lt; rootCerts.length; i++) {

                X509Certificate cert = (X509Certificate) rootCerts[i];
                System.out.println("Root certificates (CA15): " +
                    "\n\tserial number: " + cert.getSerialNumber().toString(16) +
                    "\n\tsubject: " + cert.getSubjectDN() +
                    "\n\tissuer: " + cert.getIssuerDN());
            } // for
        } // if
    }
}
</java>
<java name="userSamples/ca15/GetUserCertificateRequestListExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package userSamples.ca15;

import ru.CryptoPro.JCPRequest.ca15.decoder.CA15CertificateRequestRecord;
import ru.CryptoPro.JCPRequest.ca15.request.CA15GostCertificateRequest;
import ru.CryptoPro.JCPRequest.ca15.user.CA15User;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 10.11.12
 * Time: 15:47
 * To change this template use File | Settings | File Templates.
 */

/**
 * Пример получения списка запросов на сертификаты зарегистрированного
 * пользователя по протоколу HTTPS (CA15).
 */
public class GetUserCertificateRequestListExample {

    static {

        // Настройки TLS, т.к. обращение к серверу будет выполняться
        // по протоколу HTTPS. Указываем тип хранилища с доверенным корневым
	    // сертификатом, путь к нему и пароль.
        System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
        System.setProperty("javax.net.ssl.trustStore", "C:/Keys/server/test_ca.store");
        System.setProperty("javax.net.ssl.trustStorePassword", "Pass1234");

    }

    public static void main(String[] args) throws IOException {

        // Зарегистрированный пользователь, чьи запросы на сертификат мы
        // хотим получить. Если пользователь не зарегистрирован, то его
        // следует предварительно зарегистрировать с помощью примера
        // RegisterUserExample.
        CA15User userInfo = new CA15User(Configuration.TOKEN_ID,
            Configuration.PASSWORD);

        // Получаем список запросов на сертификаты.
        Map&lt;String, CA15CertificateRequestRecord&gt; requestMap =
            CA15GostCertificateRequest.getCertificateRequestList(
                CA15GostCertificateRequest.TEST_CA15_ADDRESS, userInfo);

        Collection&lt;CA15CertificateRequestRecord&gt; requests = requestMap.values();
        Iterator requestIterator = requests.iterator();

        // Выводим список запросов.
        while (requestIterator.hasNext()) {

            CA15CertificateRequestRecord requestRecord =
                (CA15CertificateRequestRecord) requestIterator.next();

            System.out.print("Request N: " + requestRecord.getCertificateRequestIdentifier());
            System.out.print("\n\tstatus: " + requestRecord.getStatus().toString());
            System.out.print("\n\tsent date: " + requestRecord.getSentDate());
            System.out.print("\n\tapproval date: " + requestRecord.getApprovalDate());
            System.out.println("\n\tcomment: " + requestRecord.getComment());
        }

        // Список может быть пустым, например, для только что зарегистрированного
        // пользователя, а также пользователя с истекшим маркером или несуществующего
        // пользователя.
        if (requestMap.size() == 0) {
            System.out.println("User " + userInfo.getTokenID() + " has empty table.");
        }
    }
}
</java>
<java name="userSamples/ca15/RegisterUserExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package userSamples.ca15;

import ru.CryptoPro.JCPRequest.ca15.decoder.CA15UserRegistrationField;
import ru.CryptoPro.JCPRequest.ca15.request.CA15GostCertificateRequest;
import ru.CryptoPro.JCPRequest.ca15.status.CA15Status;
import ru.CryptoPro.JCPRequest.ca15.status.CA15UserRegisterInfoStatus;
import ru.CryptoPro.JCPRequest.ca15.status.CA15UserRegisterStatus;
import ru.CryptoPro.JCPRequest.ca15.user.CA15User;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 10.11.12
 * Time: 15:46
 * To change this template use File | Settings | File Templates.
 */

/**
 * Пример получения списка полей для подготовки регистрации пользователя,
 * заполнения полей, отправки запрос на регистрацию, проверки статуса
 * регистрации пользователя.
 */
public class RegisterUserExample {

    static {

        // Настройки TLS, т.к. обращение к серверу будет выполняться
        // по протоколу HTTPS. Указываем тип хранилища с доверенным корневым
        // сертификатом, путь к нему и пароль.
        System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
        System.setProperty("javax.net.ssl.trustStore", "C:/Keys/server/test_ca.store");
        System.setProperty("javax.net.ssl.trustStorePassword", "Pass1234");

    }

    /**
     * Вывод информации о пользователе и статусе.
     *
     * @param userInfo Данные пользователя.
     * @param userStatus Статус пользователя.
     */
    public static void printUserInfo(CA15User userInfo,
        CA15UserRegisterStatus userStatus) {

        System.out.println("SAVE tokenID AND password TO CONFIGURATION!");
        System.out.print("User: ");
        System.out.print("\n\ttokenID: " + userInfo.getTokenID());
        System.out.print("\n\tpassword: " + userInfo.getPassword());
        System.out.print("\n\tstatus: " + userStatus.toString());
        System.out.println("\n\tregistration identifier: " + userStatus.getRegistrationId());
    }

    /**
     * Функция вывода списка полей с их параметрами.
     *
     * @param index Номер поля.
     * @param field Описание поля.
     */
    public static void printUserRegistrationFieldInfo(int index,
        CA15UserRegistrationField field) {

        System.out.print("Field # " + index + ": ");
        System.out.print("\n\tname: " + field.getName());
        System.out.print("\n\tform name: " + field.getFormName());
        System.out.print("\n\tvalue: " + field.getValue());
        System.out.print("\n\ttype: " + field.getComponentType());
        System.out.print("\n\tmandatory: " + field.getMandatory());
        System.out.print("\n\tmaxLength: " + field.getMaxLength());

        Vector&lt;String&gt; allowedValues = field.getAllowedValues();
        if (allowedValues != null &amp;&amp; allowedValues.size() &gt; 0) {

            System.out.print("\n\tallowed values: ");

            for (int i = 0; i &lt; allowedValues.size(); i++) {
                System.out.print("\n\t\tallowed value: " + allowedValues.get(i));
            }
        }

        System.out.println();
    }

    /**
     * Функция вывода статуса регистрации пользователя.
     *
     * @param userStatus Статус пользователя.
     */
    private static void printCA15UserRegisterInfoStatus(CA15UserRegisterInfoStatus
        userStatus) {

        System.out.println("Status: " + userStatus.toString());
        System.out.println("TokenID: " + userStatus.getTokenID());
        System.out.println("Password: " + userStatus.getPassword());

    }

    public static void main(String[] args) throws IOException,
        InterruptedException {

        // 1. Получаем список полей для заполнения и последующей
        // регистрации пользователя.

        Vector&lt;CA15UserRegistrationField&gt; userRegistrationFields =
            CA15User.getUserRegistrationFields(CA15GostCertificateRequest.TEST_CA15_ADDRESS);

        // Выводим поля.
        for (int i = 0; i &lt; userRegistrationFields.size(); i++) {

            CA15UserRegistrationField userRegistrationField =
                userRegistrationFields.get(i);

            printUserRegistrationFieldInfo(i + 1, userRegistrationField);
        } // for

        // 2. Заполняем полученный список значениями.

        // Список пар поле=значение для передачи на регистрацию.
        Map&lt;String, String&gt; fields = new HashMap&lt;String, String&gt;();

        // Частично заполняем список названиями полей и значениями.
        // Обязательным является только CommonName, а также укажем
        // страну CountryName = RU.

        for (int i = 0; i &lt; userRegistrationFields.size(); i++) {

            CA15UserRegistrationField userRegistrationField =
                    userRegistrationFields.get(i);

            String fieldName = userRegistrationField.getFormName();
            String fieldValue = userRegistrationField.getValue();

            // Подставляем свои значения в CN и C.
            if (fieldName.equalsIgnoreCase("RDN_CN_1")) {
                fieldValue = Configuration.COMMON_NAME;
            }
            else if (fieldName.equalsIgnoreCase("RDN_C_1")) {
                fieldValue = Configuration.COUNTRY_NAME;
            } // if

            fields.put(fieldName, fieldValue);
        } // for

        // 3. Регистрируем пользователя и получаем tokenID и пароль
        // для входа.

        CA15User newUser = new CA15User(fields);
        CA15UserRegisterInfoStatus userStatus =
            newUser.registerUser(CA15GostCertificateRequest.TEST_CA15_ADDRESS);

        printCA15UserRegisterInfoStatus(userStatus);

        if (userStatus.getValue() != CA15Status.CR_DISP_ISSUED &amp;&amp;
            userStatus.getValue() != CA15Status.CR_DISP_UNDER_SUBMISSION) {

            System.err.println("User registration failure.");
            return;
        } // if

        // 4. Проверяем статус пользователя, если регистрация не произвелась
        // сразу.

        // Если пользователь в процессе регистрации (UNDER_SUBMISSION), то ждем
        // окончания регистрации, пока запрос будет обработан, проверя статус этого
        // пользователя по его tokenID и паролю, которые мы уже получили.
        // Если запрос был обработан моментально, то выходим из программы, т.к.
        // все необходимые данные были уже распечатаны ранее.
        // Можно организовать процесс ожидания иначе: с помощью цикла опроса состояния
        // обработки и др.
        if (userStatus.getValue() == CA15Status.CR_DISP_UNDER_SUBMISSION) {

            Thread.sleep(30 * 1000);

            CA15User userInfo =
                new CA15User(userStatus.getTokenID(), userStatus.getPassword());

            CA15UserRegisterStatus status = userInfo.checkUserStatus(
                CA15GostCertificateRequest.TEST_CA15_ADDRESS);

            printUserInfo(userInfo, status);

        } // if
    }
}
</java>
<java name="userSamples/ca15/SendRequestAndGetCertificateExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */
package userSamples.ca15;

import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCPRequest.ca15.request.CA15GostCertificateRequest;
import ru.CryptoPro.JCPRequest.ca15.status.CA15RequestStatus;
import ru.CryptoPro.JCPRequest.ca15.status.CA15Status;
import ru.CryptoPro.JCPRequest.ca15.user.CA15User;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.*;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

/**
 * Created with IntelliJ IDEA.
 * User: Yevgeniy
 * Date: 10.11.12
 * Time: 15:47
 * To change this template use File | Settings | File Templates.
 */

/**
 * Пример создания запроса на сертификат, отправки его в УЦ (CA15)
 * для выпуска сертификата, проверки статуса сертификата и  его
 * обработки.
 */
public class SendRequestAndGetCertificateExample {

    static {

        // Настройки TLS, т.к. обращение к серверу будет выполняться
        // по протоколу HTTPS. Указываем тип хранилища с доверенным корневым
        // сертификатом, путь к нему и пароль.
        System.setProperty("javax.net.ssl.trustStoreType", "HDImageStore");
        System.setProperty("javax.net.ssl.trustStore", "C:/Keys/server/test_ca.store");
        System.setProperty("javax.net.ssl.trustStorePassword", "Pass1234");

    }

    /**
     * Функция вывода информации о сертификате.
     *
     * @param cert Сертификат.
     */
    public static void printCertificateInfo(X509Certificate cert) {

        System.out.print("Certificate:");
        System.out.print("\n\tserial number: " + cert.getSerialNumber().toString(16));
        System.out.print("\n\tsubject: " + cert.getSubjectDN());
        System.out.print("\n\tissuer: " + cert.getIssuerDN());
        System.out.println();
    }

    public static void main(String[] args) throws IOException,
        NoSuchAlgorithmException, SignatureException, InvalidKeyException,
        InterruptedException, CertificateException {

        // Поля, которые использовались при регистрации пользователя
        // (см. пример RegisterUserExample), необходимо использовать и
        // при генерации запроса. Т.к. обязательным является только поле
        // CommonName, то используем его при генерации запроса на сертификат,
        // а также указывалась страна.
        // Используем пользователя, у которого ommonName и CountryName
        // соответствуют данным (см. пример RegisterUserExample).
        CA15User userInfo = new CA15User(Configuration.TOKEN_ID, Configuration.PASSWORD);

        // 1. Генерирование ключевой пары.

        KeyPairGenerator kg = KeyPairGenerator.getInstance(JCP.GOST_DH_NAME);
        KeyPair pair = kg.generateKeyPair();

        // 2. Генерирование запроса на сертификат.

        CA15GostCertificateRequest req = new CA15GostCertificateRequest();
        req.init(JCP.GOST_DH_NAME, false);
        req.setPublicKeyInfo(pair.getPublic());
        req.setSubjectInfo("CN=" + Configuration.COMMON_NAME +
            ",C=" + Configuration.COUNTRY_NAME);
        req.encodeAndSign(pair.getPrivate());

        // 3. Отправляем запрос и получаем статус обработки.

        CA15RequestStatus requestStatus =
            req.sendCertificateRequest(CA15GostCertificateRequest.TEST_CA15_ADDRESS, userInfo);

        if (requestStatus.getValue() == CA15Status.CR_DISP_ERROR) {
            System.err.println("Send certificate request failure.");
            return;
        } // if

        System.out.println("Request identifier: " + requestStatus.getRequestIdentifier()
            + ", status: " + requestStatus.toString());

        // 4. Проверим статус сертификата специально еще раз.

        requestStatus = CA15GostCertificateRequest.checkCertificateStatus(
            CA15GostCertificateRequest.TEST_CA15_ADDRESS, userInfo,
            requestStatus.getRequestIdentifier());

        System.out.println("Request identifier (again): " + requestStatus.getRequestIdentifier()
            + ", status: " + requestStatus.toString());

        if (requestStatus.getValue() == CA15Status.CR_DISP_ERROR) {
            System.err.println("Certificate request has invalid status.");
            return;
        } // if

        byte[] certificateEncoded = null;

        switch (requestStatus.getValue()) {

            // 5. Запрос обработан, просто получаем сертификат.

            case CA15Status.CR_DISP_ISSUED : {
                certificateEncoded =
                    CA15GostCertificateRequest.getCertificateByRequestId(
                        CA15GostCertificateRequest.TEST_CA15_ADDRESS, userInfo,
                            requestStatus.getRequestIdentifier());
            }
            break;

            // 6. Ждем, когда будет обработан запрос и создан сертификат, затем получаем
            // сертификат. Можно организовать процесс ожидания иначе: с помощью цикла опроса
            // состояния обработки и др.

            case CA15Status.CR_DISP_UNDER_SUBMISSION : {

                Thread.sleep(30 * 1000);

                certificateEncoded =
                    CA15GostCertificateRequest.getCertificateByRequestId(
                        CA15GostCertificateRequest.TEST_CA15_ADDRESS, userInfo,
                            requestStatus.getRequestIdentifier());
            }
            break;

            default: {
                System.err.println("Certificate request has invalid status");
                return;
            }

        } // switch

        // 7. Создаем сертификат и выводим на экран.

        if (certificateEncoded != null) {

            X509Certificate cert =
                (X509Certificate) CertificateFactory.getInstance("X.509")
                    .generateCertificate(new ByteArrayInputStream(certificateEncoded));

            printCertificateInfo(cert);

        } // if
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/SignatureTool.java">/**
 * SignatureTool.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool;

public interface SignatureTool extends java.rmi.Remote {
    public wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType verifySignature(wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType parameters) throws java.rmi.RemoteException;
    public wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType signMessage(wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageRequestType parameters) throws java.rmi.RemoteException;
}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/SignatureToolBindingStub.java">/**
 * SignatureToolBindingStub.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool;

public class SignatureToolBindingStub extends org.apache.axis.client.Stub implements wss4j.gosuslugi.smev.SignatureTool.SignatureTool {
    private java.util.Vector cachedSerClasses = new java.util.Vector();
    private java.util.Vector cachedSerQNames = new java.util.Vector();
    private java.util.Vector cachedSerFactories = new java.util.Vector();
    private java.util.Vector cachedDeserFactories = new java.util.Vector();

    static org.apache.axis.description.OperationDesc [] _operations;

    static {
        _operations = new org.apache.axis.description.OperationDesc[2];
        _initOperationDesc1();
    }

    private static void _initOperationDesc1(){
        org.apache.axis.description.OperationDesc oper;
        org.apache.axis.description.ParameterDesc param;
        oper = new org.apache.axis.description.OperationDesc();
        oper.setName("verifySignature");
        param = new org.apache.axis.description.ParameterDesc(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureRequest"), org.apache.axis.description.ParameterDesc.IN, new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureRequestType"), wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType.class, false, false);
        oper.addParameter(param);
        oper.setReturnType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureResponseType"));
        oper.setReturnClass(wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType.class);
        oper.setReturnQName(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureResponse"));
        oper.setStyle(org.apache.axis.constants.Style.DOCUMENT);
        oper.setUse(org.apache.axis.constants.Use.LITERAL);
        _operations[0] = oper;

        oper = new org.apache.axis.description.OperationDesc();
        oper.setName("signMessage");
        param = new org.apache.axis.description.ParameterDesc(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageRequest"), org.apache.axis.description.ParameterDesc.IN, new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageRequestType"), wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageRequestType.class, false, false);
        oper.addParameter(param);
        oper.setReturnType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageResponseType"));
        oper.setReturnClass(wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType.class);
        oper.setReturnQName(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageResponse"));
        oper.setStyle(org.apache.axis.constants.Style.DOCUMENT);
        oper.setUse(org.apache.axis.constants.Use.LITERAL);
        _operations[1] = oper;

    }

    public SignatureToolBindingStub() throws org.apache.axis.AxisFault {
         this(null);
    }

    public SignatureToolBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
         this(service);
         super.cachedEndpoint = endpointURL;
    }

    public SignatureToolBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {
        if (service == null) {
            super.service = new org.apache.axis.client.Service();
        } else {
            super.service = service;
        }
        ((org.apache.axis.client.Service)super.service).setTypeMappingVersion("1.2");
            java.lang.Class cls;
            javax.xml.namespace.QName qName;
            javax.xml.namespace.QName qName2;
            java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;
            java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;
            java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;
            java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;
            java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;
            java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;
            java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;
            java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;
            java.lang.Class simplelistsf = org.apache.axis.encoding.ser.SimpleListSerializerFactory.class;
            java.lang.Class simplelistdf = org.apache.axis.encoding.ser.SimpleListDeserializerFactory.class;
            qName = new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "Error");
            cachedSerQNames.add(qName);
            cls = wss4j.nvg.idecs.identityservice.ws.types.Error.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(beansf);
            cachedDeserFactories.add(beandf);

            qName = new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "ErrorCode");
            cachedSerQNames.add(qName);
            cls = long.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(org.apache.axis.encoding.ser.BaseSerializerFactory.createFactory(org.apache.axis.encoding.ser.SimpleSerializerFactory.class, cls, qName));
            cachedDeserFactories.add(org.apache.axis.encoding.ser.BaseDeserializerFactory.createFactory(org.apache.axis.encoding.ser.SimpleDeserializerFactory.class, cls, qName));

            qName = new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "Part4SignType");
            cachedSerQNames.add(qName);
            cls = wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(beansf);
            cachedDeserFactories.add(beandf);

            qName = new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageRequestType");
            cachedSerQNames.add(qName);
            cls = wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageRequestType.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(beansf);
            cachedDeserFactories.add(beandf);

            qName = new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageResponseType");
            cachedSerQNames.add(qName);
            cls = wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(beansf);
            cachedDeserFactories.add(beandf);

            qName = new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureRequestType");
            cachedSerQNames.add(qName);
            cls = wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(beansf);
            cachedDeserFactories.add(beandf);

            qName = new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureResponseType");
            cachedSerQNames.add(qName);
            cls = wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType.class;
            cachedSerClasses.add(cls);
            cachedSerFactories.add(beansf);
            cachedDeserFactories.add(beandf);

    }

    protected org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {
        try {
            org.apache.axis.client.Call _call = super._createCall();
            if (super.maintainSessionSet) {
                _call.setMaintainSession(super.maintainSession);
            }
            if (super.cachedUsername != null) {
                _call.setUsername(super.cachedUsername);
            }
            if (super.cachedPassword != null) {
                _call.setPassword(super.cachedPassword);
            }
            if (super.cachedEndpoint != null) {
                _call.setTargetEndpointAddress(super.cachedEndpoint);
            }
            if (super.cachedTimeout != null) {
                _call.setTimeout(super.cachedTimeout);
            }
            if (super.cachedPortName != null) {
                _call.setPortName(super.cachedPortName);
            }
            java.util.Enumeration keys = super.cachedProperties.keys();
            while (keys.hasMoreElements()) {
                java.lang.String key = (java.lang.String) keys.nextElement();
                _call.setProperty(key, super.cachedProperties.get(key));
            }
            // All the type mapping information is registered
            // when the first call is made.
            // The type mapping information is actually registered in
            // the TypeMappingRegistry of the service, which
            // is the reason why registration is only needed for the first call.
            synchronized (this) {
                if (firstCall()) {
                    // must set encoding style before registering serializers
                    _call.setEncodingStyle(null);
                    for (int i = 0; i &lt; cachedSerFactories.size(); ++i) {
                        java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);
                        javax.xml.namespace.QName qName =
                                (javax.xml.namespace.QName) cachedSerQNames.get(i);
                        java.lang.Object x = cachedSerFactories.get(i);
                        if (x instanceof Class) {
                            java.lang.Class sf = (java.lang.Class)
                                 cachedSerFactories.get(i);
                            java.lang.Class df = (java.lang.Class)
                                 cachedDeserFactories.get(i);
                            _call.registerTypeMapping(cls, qName, sf, df, false);
                        }
                        else if (x instanceof javax.xml.rpc.encoding.SerializerFactory) {
                            org.apache.axis.encoding.SerializerFactory sf = (org.apache.axis.encoding.SerializerFactory)
                                 cachedSerFactories.get(i);
                            org.apache.axis.encoding.DeserializerFactory df = (org.apache.axis.encoding.DeserializerFactory)
                                 cachedDeserFactories.get(i);
                            _call.registerTypeMapping(cls, qName, sf, df, false);
                        }
                    }
                }
            }
            return _call;
        }
        catch (java.lang.Throwable _t) {
            throw new org.apache.axis.AxisFault("Failure trying to get the Call object", _t);
        }
    }

    public wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType verifySignature(wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType parameters) throws java.rmi.RemoteException {
        if (super.cachedEndpoint == null) {
            throw new org.apache.axis.NoEndPointException();
        }
        org.apache.axis.client.Call _call = createCall();
        _call.setOperation(_operations[0]);
        _call.setUseSOAPAction(true);
        _call.setSOAPActionURI("http://smev.gosuslugi.ru/SignatureTool/verifySignature");
        _call.setEncodingStyle(null);
        _call.setProperty(org.apache.axis.client.Call.SEND_TYPE_ATTR, Boolean.FALSE);
        _call.setProperty(org.apache.axis.AxisEngine.PROP_DOMULTIREFS, Boolean.FALSE);
        _call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
        _call.setOperationName(new javax.xml.namespace.QName("", "verifySignature"));

        setRequestHeaders(_call);
        setAttachments(_call);
 try {        java.lang.Object _resp = _call.invoke(new java.lang.Object[] {parameters});

        if (_resp instanceof java.rmi.RemoteException) {
            throw (java.rmi.RemoteException)_resp;
        }
        else {
            extractAttachments(_call);
            try {
                return (wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType) _resp;
            } catch (java.lang.Exception _exception) {
                return (wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType) org.apache.axis.utils.JavaUtils.convert(_resp, wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType.class);
            }
        }
  } catch (org.apache.axis.AxisFault axisFaultException) {
  throw axisFaultException;
}
    }

    public wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType signMessage(wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageRequestType parameters) throws java.rmi.RemoteException {
        if (super.cachedEndpoint == null) {
            throw new org.apache.axis.NoEndPointException();
        }
        org.apache.axis.client.Call _call = createCall();
        _call.setOperation(_operations[1]);
        _call.setUseSOAPAction(true);
        _call.setSOAPActionURI("http://smev.gosuslugi.ru/SignatureTool/signMessage");
        _call.setEncodingStyle(null);
        _call.setProperty(org.apache.axis.client.Call.SEND_TYPE_ATTR, Boolean.FALSE);
        _call.setProperty(org.apache.axis.AxisEngine.PROP_DOMULTIREFS, Boolean.FALSE);
        _call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);
        _call.setOperationName(new javax.xml.namespace.QName("", "signMessage"));

        setRequestHeaders(_call);
        setAttachments(_call);
 try {        java.lang.Object _resp = _call.invoke(new java.lang.Object[] {parameters});

        if (_resp instanceof java.rmi.RemoteException) {
            throw (java.rmi.RemoteException)_resp;
        }
        else {
            extractAttachments(_call);
            try {
                return (wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType) _resp;
            } catch (java.lang.Exception _exception) {
                return (wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType) org.apache.axis.utils.JavaUtils.convert(_resp, wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType.class);
            }
        }
  } catch (org.apache.axis.AxisFault axisFaultException) {
  throw axisFaultException;
}
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/SignatureToolProxy.java">package wss4j.gosuslugi.smev.SignatureTool;

public class SignatureToolProxy implements wss4j.gosuslugi.smev.SignatureTool.SignatureTool {
  private String _endpoint = null;
  private wss4j.gosuslugi.smev.SignatureTool.SignatureTool signatureTool = null;
  
  public SignatureToolProxy() {
    _initSignatureToolProxy();
  }
  
  public SignatureToolProxy(String endpoint) {
    _endpoint = endpoint;
    _initSignatureToolProxy();
  }
  
  private void _initSignatureToolProxy() {
    try {
      signatureTool = (new wss4j.gosuslugi.smev.SignatureTool.SignatureToolServiceLocator()).getSignatureToolPort();
      if (signatureTool != null) {
        if (_endpoint != null)
          ((javax.xml.rpc.Stub)signatureTool)._setProperty("javax.xml.rpc.service.endpoint.address", _endpoint);
        else
          _endpoint = (String)((javax.xml.rpc.Stub)signatureTool)._getProperty("javax.xml.rpc.service.endpoint.address");
      }
      
    }
    catch (javax.xml.rpc.ServiceException serviceException) {}
  }
  
  public String getEndpoint() {
    return _endpoint;
  }
  
  public void setEndpoint(String endpoint) {
    _endpoint = endpoint;
    if (signatureTool != null)
      ((javax.xml.rpc.Stub)signatureTool)._setProperty("javax.xml.rpc.service.endpoint.address", _endpoint);
    
  }
  
  public wss4j.gosuslugi.smev.SignatureTool.SignatureTool getSignatureTool() {
    if (signatureTool == null)
      _initSignatureToolProxy();
    return signatureTool;
  }
  
  public wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType verifySignature(wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType parameters) throws java.rmi.RemoteException{
    if (signatureTool == null)
      _initSignatureToolProxy();
    return signatureTool.verifySignature(parameters);
  }
  
  public wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageResponseType signMessage(wss4j.gosuslugi.smev.SignatureTool.xsd.SignMessageRequestType parameters) throws java.rmi.RemoteException{
    if (signatureTool == null)
      _initSignatureToolProxy();
    return signatureTool.signMessage(parameters);
  }
  
  
}</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/SignatureToolService.java">/**
 * SignatureToolService.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool;

public interface SignatureToolService extends javax.xml.rpc.Service {
    public java.lang.String getSignatureToolPortAddress();

    public wss4j.gosuslugi.smev.SignatureTool.SignatureTool getSignatureToolPort() throws javax.xml.rpc.ServiceException;

    public wss4j.gosuslugi.smev.SignatureTool.SignatureTool getSignatureToolPort(java.net.URL portAddress) throws javax.xml.rpc.ServiceException;
}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/SignatureToolServiceLocator.java">/**
 * SignatureToolServiceLocator.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool;

public class SignatureToolServiceLocator extends org.apache.axis.client.Service implements wss4j.gosuslugi.smev.SignatureTool.SignatureToolService {

    public SignatureToolServiceLocator() {
    }


    public SignatureToolServiceLocator(org.apache.axis.EngineConfiguration config) {
        super(config);
    }

    public SignatureToolServiceLocator(java.lang.String wsdlLoc, javax.xml.namespace.QName sName) throws javax.xml.rpc.ServiceException {
        super(wsdlLoc, sName);
    }

    // Use to get a proxy class for SignatureToolPort
    private java.lang.String SignatureToolPort_address = "http://d00smevapp01:9999/gateway/services/SID0003038";

    public java.lang.String getSignatureToolPortAddress() {
        return SignatureToolPort_address;
    }

    // The WSDD service name defaults to the port name.
    private java.lang.String SignatureToolPortWSDDServiceName = "SignatureToolPort";

    public java.lang.String getSignatureToolPortWSDDServiceName() {
        return SignatureToolPortWSDDServiceName;
    }

    public void setSignatureToolPortWSDDServiceName(java.lang.String name) {
        SignatureToolPortWSDDServiceName = name;
    }

    public wss4j.gosuslugi.smev.SignatureTool.SignatureTool getSignatureToolPort() throws javax.xml.rpc.ServiceException {
       java.net.URL endpoint;
        try {
            endpoint = new java.net.URL(SignatureToolPort_address);
        }
        catch (java.net.MalformedURLException e) {
            throw new javax.xml.rpc.ServiceException(e);
        }
        return getSignatureToolPort(endpoint);
    }

    public wss4j.gosuslugi.smev.SignatureTool.SignatureTool getSignatureToolPort(java.net.URL portAddress) throws javax.xml.rpc.ServiceException {
        try {
            wss4j.gosuslugi.smev.SignatureTool.SignatureToolBindingStub _stub = new wss4j.gosuslugi.smev.SignatureTool.SignatureToolBindingStub(portAddress, this);
            _stub.setPortName(getSignatureToolPortWSDDServiceName());
            return _stub;
        }
        catch (org.apache.axis.AxisFault e) {
            return null;
        }
    }

    public void setSignatureToolPortEndpointAddress(java.lang.String address) {
        SignatureToolPort_address = address;
    }

    /**
     * For the given interface, get the stub implementation.
     * If this service has no port for the given interface,
     * then ServiceException is thrown.
     */
    public java.rmi.Remote getPort(Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
        try {
            if (wss4j.gosuslugi.smev.SignatureTool.SignatureTool.class.isAssignableFrom(serviceEndpointInterface)) {
                wss4j.gosuslugi.smev.SignatureTool.SignatureToolBindingStub _stub = new wss4j.gosuslugi.smev.SignatureTool.SignatureToolBindingStub(new java.net.URL(SignatureToolPort_address), this);
                _stub.setPortName(getSignatureToolPortWSDDServiceName());
                return _stub;
            }
        }
        catch (java.lang.Throwable t) {
            throw new javax.xml.rpc.ServiceException(t);
        }
        throw new javax.xml.rpc.ServiceException("There is no stub implementation for the interface:  " + (serviceEndpointInterface == null ? "null" : serviceEndpointInterface.getName()));
    }

    /**
     * For the given interface, get the stub implementation.
     * If this service has no port for the given interface,
     * then ServiceException is thrown.
     */
    public java.rmi.Remote getPort(javax.xml.namespace.QName portName, Class serviceEndpointInterface) throws javax.xml.rpc.ServiceException {
        if (portName == null) {
            return getPort(serviceEndpointInterface);
        }
        java.lang.String inputPortName = portName.getLocalPart();
        if ("SignatureToolPort".equals(inputPortName)) {
            return getSignatureToolPort();
        }
        else  {
            java.rmi.Remote _stub = getPort(serviceEndpointInterface);
            ((org.apache.axis.client.Stub) _stub).setPortName(portName);
            return _stub;
        }
    }

    public javax.xml.namespace.QName getServiceName() {
        return new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/", "SignatureToolService");
    }

    private java.util.HashSet ports = null;

    public java.util.Iterator getPorts() {
        if (ports == null) {
            ports = new java.util.HashSet();
            ports.add(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/", "SignatureToolPort"));
        }
        return ports.iterator();
    }

    /**
    * Set the endpoint address for the specified port name.
    */
    public void setEndpointAddress(java.lang.String portName, java.lang.String address) throws javax.xml.rpc.ServiceException {
        
if ("SignatureToolPort".equals(portName)) {
            setSignatureToolPortEndpointAddress(address);
        }
        else 
{ // Unknown Port Name
            throw new javax.xml.rpc.ServiceException(" Cannot set Endpoint Address for Unknown Port" + portName);
        }
    }

    /**
    * Set the endpoint address for the specified port name.
    */
    public void setEndpointAddress(javax.xml.namespace.QName portName, java.lang.String address) throws javax.xml.rpc.ServiceException {
        setEndpointAddress(portName.getLocalPart(), address);
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/xsd/Part4SignType.java">/**
 * Part4SignType.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool.xsd;

public class Part4SignType  implements java.io.Serializable {
    /* Значение атрибута wsu:id. Подписанны будут все элементы с таким
     * ИД */
    private java.lang.String id;

    /* Простраство имен */
    private java.lang.String namespace;

    /* Наименование элемента */
    private java.lang.String name;

    public Part4SignType() {
    }

    public Part4SignType(
           java.lang.String id,
           java.lang.String namespace,
           java.lang.String name) {
           this.id = id;
           this.namespace = namespace;
           this.name = name;
    }


    /**
     * Gets the id value for this Part4SignType.
     * 
     * @return id   * Значение атрибута wsu:id. Подписанны будут все элементы с таким
     * ИД
     */
    public java.lang.String getId() {
        return id;
    }


    /**
     * Sets the id value for this Part4SignType.
     * 
     * @param id   * Значение атрибута wsu:id. Подписанны будут все элементы с таким
     * ИД
     */
    public void setId(java.lang.String id) {
        this.id = id;
    }


    /**
     * Gets the namespace value for this Part4SignType.
     * 
     * @return namespace   * Простраство имен
     */
    public java.lang.String getNamespace() {
        return namespace;
    }


    /**
     * Sets the namespace value for this Part4SignType.
     * 
     * @param namespace   * Простраство имен
     */
    public void setNamespace(java.lang.String namespace) {
        this.namespace = namespace;
    }


    /**
     * Gets the name value for this Part4SignType.
     * 
     * @return name   * Наименование элемента
     */
    public java.lang.String getName() {
        return name;
    }


    /**
     * Sets the name value for this Part4SignType.
     * 
     * @param name   * Наименование элемента
     */
    public void setName(java.lang.String name) {
        this.name = name;
    }

    private java.lang.Object __equalsCalc = null;
    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof Part4SignType)) return false;
        Part4SignType other = (Part4SignType) obj;
        if (obj == null) return false;
        if (this == obj) return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = true &amp;&amp; 
            ((this.id==null &amp;&amp; other.getId()==null) || 
             (this.id!=null &amp;&amp;
              this.id.equals(other.getId()))) &amp;&amp;
            ((this.namespace==null &amp;&amp; other.getNamespace()==null) || 
             (this.namespace!=null &amp;&amp;
              this.namespace.equals(other.getNamespace()))) &amp;&amp;
            ((this.name==null &amp;&amp; other.getName()==null) || 
             (this.name!=null &amp;&amp;
              this.name.equals(other.getName())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;
    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = 1;
        if (getId() != null) {
            _hashCode += getId().hashCode();
        }
        if (getNamespace() != null) {
            _hashCode += getNamespace().hashCode();
        }
        if (getName() != null) {
            _hashCode += getName().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc =
        new org.apache.axis.description.TypeDesc(Part4SignType.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "Part4SignType"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("id");
        elemField.setXmlName(new javax.xml.namespace.QName("", "id"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("namespace");
        elemField.setXmlName(new javax.xml.namespace.QName("", "namespace"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("name");
        elemField.setXmlName(new javax.xml.namespace.QName("", "name"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanSerializer(
            _javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanDeserializer(
            _javaType, _xmlType, typeDesc);
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/xsd/SignMessageRequestType.java">/**
 * SignMessageRequestType.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool.xsd;

public class SignMessageRequestType  implements java.io.Serializable {
    /* Сообщение для подписи */
    private java.lang.String message;

    /* атрибут ws-security:actor для секции ws:security
     * 						 в которую будет добавлена подпись */
    private java.lang.String actor;

    /* Элементы для подписи */
    private wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType[] part4Sign;

    /* Алиас сертификата. */
    private java.lang.String certAlias;

    /* Алиас приватного ключа. */
    private java.lang.String privateKeyAlias;

    /* Пароль для доступа к приватному ключу */
    private java.lang.String privateKeyPassword;

    public SignMessageRequestType() {
    }

    public SignMessageRequestType(
           java.lang.String message,
           java.lang.String actor,
           wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType[] part4Sign,
           java.lang.String certAlias,
           java.lang.String privateKeyAlias,
           java.lang.String privateKeyPassword) {
           this.message = message;
           this.actor = actor;
           this.part4Sign = part4Sign;
           this.certAlias = certAlias;
           this.privateKeyAlias = privateKeyAlias;
           this.privateKeyPassword = privateKeyPassword;
    }


    /**
     * Gets the message value for this SignMessageRequestType.
     * 
     * @return message   * Сообщение для подписи
     */
    public java.lang.String getMessage() {
        return message;
    }


    /**
     * Sets the message value for this SignMessageRequestType.
     * 
     * @param message   * Сообщение для подписи
     */
    public void setMessage(java.lang.String message) {
        this.message = message;
    }


    /**
     * Gets the actor value for this SignMessageRequestType.
     * 
     * @return actor   * атрибут ws-security:actor для секции ws:security
     * 						 в которую будет добавлена подпись
     */
    public java.lang.String getActor() {
        return actor;
    }


    /**
     * Sets the actor value for this SignMessageRequestType.
     * 
     * @param actor   * атрибут ws-security:actor для секции ws:security
     * 						 в которую будет добавлена подпись
     */
    public void setActor(java.lang.String actor) {
        this.actor = actor;
    }


    /**
     * Gets the part4Sign value for this SignMessageRequestType.
     * 
     * @return part4Sign   * Элементы для подписи
     */
    public wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType[] getPart4Sign() {
        return part4Sign;
    }


    /**
     * Sets the part4Sign value for this SignMessageRequestType.
     * 
     * @param part4Sign   * Элементы для подписи
     */
    public void setPart4Sign(wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType[] part4Sign) {
        this.part4Sign = part4Sign;
    }

    public wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType getPart4Sign(int i) {
        return this.part4Sign[i];
    }

    public void setPart4Sign(int i, wss4j.gosuslugi.smev.SignatureTool.xsd.Part4SignType _value) {
        this.part4Sign[i] = _value;
    }


    /**
     * Gets the certAlias value for this SignMessageRequestType.
     * 
     * @return certAlias   * Алиас сертификата.
     */
    public java.lang.String getCertAlias() {
        return certAlias;
    }


    /**
     * Sets the certAlias value for this SignMessageRequestType.
     * 
     * @param certAlias   * Алиас сертификата.
     */
    public void setCertAlias(java.lang.String certAlias) {
        this.certAlias = certAlias;
    }


    /**
     * Gets the privateKeyAlias value for this SignMessageRequestType.
     * 
     * @return privateKeyAlias   * Алиас приватного ключа.
     */
    public java.lang.String getPrivateKeyAlias() {
        return privateKeyAlias;
    }


    /**
     * Sets the privateKeyAlias value for this SignMessageRequestType.
     * 
     * @param privateKeyAlias   * Алиас приватного ключа.
     */
    public void setPrivateKeyAlias(java.lang.String privateKeyAlias) {
        this.privateKeyAlias = privateKeyAlias;
    }


    /**
     * Gets the privateKeyPassword value for this SignMessageRequestType.
     * 
     * @return privateKeyPassword   * Пароль для доступа к приватному ключу
     */
    public java.lang.String getPrivateKeyPassword() {
        return privateKeyPassword;
    }


    /**
     * Sets the privateKeyPassword value for this SignMessageRequestType.
     * 
     * @param privateKeyPassword   * Пароль для доступа к приватному ключу
     */
    public void setPrivateKeyPassword(java.lang.String privateKeyPassword) {
        this.privateKeyPassword = privateKeyPassword;
    }

    private java.lang.Object __equalsCalc = null;
    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof SignMessageRequestType)) return false;
        SignMessageRequestType other = (SignMessageRequestType) obj;
        if (obj == null) return false;
        if (this == obj) return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = true &amp;&amp; 
            ((this.message==null &amp;&amp; other.getMessage()==null) || 
             (this.message!=null &amp;&amp;
              this.message.equals(other.getMessage()))) &amp;&amp;
            ((this.actor==null &amp;&amp; other.getActor()==null) || 
             (this.actor!=null &amp;&amp;
              this.actor.equals(other.getActor()))) &amp;&amp;
            ((this.part4Sign==null &amp;&amp; other.getPart4Sign()==null) || 
             (this.part4Sign!=null &amp;&amp;
              java.util.Arrays.equals(this.part4Sign, other.getPart4Sign()))) &amp;&amp;
            ((this.certAlias==null &amp;&amp; other.getCertAlias()==null) || 
             (this.certAlias!=null &amp;&amp;
              this.certAlias.equals(other.getCertAlias()))) &amp;&amp;
            ((this.privateKeyAlias==null &amp;&amp; other.getPrivateKeyAlias()==null) || 
             (this.privateKeyAlias!=null &amp;&amp;
              this.privateKeyAlias.equals(other.getPrivateKeyAlias()))) &amp;&amp;
            ((this.privateKeyPassword==null &amp;&amp; other.getPrivateKeyPassword()==null) || 
             (this.privateKeyPassword!=null &amp;&amp;
              this.privateKeyPassword.equals(other.getPrivateKeyPassword())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;
    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = 1;
        if (getMessage() != null) {
            _hashCode += getMessage().hashCode();
        }
        if (getActor() != null) {
            _hashCode += getActor().hashCode();
        }
        if (getPart4Sign() != null) {
            for (int i=0;
                 i&lt;java.lang.reflect.Array.getLength(getPart4Sign());
                 i++) {
                java.lang.Object obj = java.lang.reflect.Array.get(getPart4Sign(), i);
                if (obj != null &amp;&amp;
                    !obj.getClass().isArray()) {
                    _hashCode += obj.hashCode();
                }
            }
        }
        if (getCertAlias() != null) {
            _hashCode += getCertAlias().hashCode();
        }
        if (getPrivateKeyAlias() != null) {
            _hashCode += getPrivateKeyAlias().hashCode();
        }
        if (getPrivateKeyPassword() != null) {
            _hashCode += getPrivateKeyPassword().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc =
        new org.apache.axis.description.TypeDesc(SignMessageRequestType.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageRequestType"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("message");
        elemField.setXmlName(new javax.xml.namespace.QName("", "message"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("actor");
        elemField.setXmlName(new javax.xml.namespace.QName("", "actor"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("part4Sign");
        elemField.setXmlName(new javax.xml.namespace.QName("", "part4Sign"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "Part4SignType"));
        elemField.setNillable(false);
        elemField.setMaxOccursUnbounded(true);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("certAlias");
        elemField.setXmlName(new javax.xml.namespace.QName("", "certAlias"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("privateKeyAlias");
        elemField.setXmlName(new javax.xml.namespace.QName("", "privateKeyAlias"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("privateKeyPassword");
        elemField.setXmlName(new javax.xml.namespace.QName("", "privateKeyPassword"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanSerializer(
            _javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanDeserializer(
            _javaType, _xmlType, typeDesc);
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/xsd/SignMessageResponseType.java">/**
 * SignMessageResponseType.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool.xsd;

public class SignMessageResponseType  implements java.io.Serializable {
    /* Результат выполнения операции */
    private wss4j.nvg.idecs.identityservice.ws.types.Error error;

    /* Подпсанное сообщение */
    private java.lang.String message;

    public SignMessageResponseType() {
    }

    public SignMessageResponseType(
           wss4j.nvg.idecs.identityservice.ws.types.Error error,
           java.lang.String message) {
           this.error = error;
           this.message = message;
    }


    /**
     * Gets the error value for this SignMessageResponseType.
     * 
     * @return error   * Результат выполнения операции
     */
    public wss4j.nvg.idecs.identityservice.ws.types.Error getError() {
        return error;
    }


    /**
     * Sets the error value for this SignMessageResponseType.
     * 
     * @param error   * Результат выполнения операции
     */
    public void setError(wss4j.nvg.idecs.identityservice.ws.types.Error error) {
        this.error = error;
    }


    /**
     * Gets the message value for this SignMessageResponseType.
     * 
     * @return message   * Подпсанное сообщение
     */
    public java.lang.String getMessage() {
        return message;
    }


    /**
     * Sets the message value for this SignMessageResponseType.
     * 
     * @param message   * Подпсанное сообщение
     */
    public void setMessage(java.lang.String message) {
        this.message = message;
    }

    private java.lang.Object __equalsCalc = null;
    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof SignMessageResponseType)) return false;
        SignMessageResponseType other = (SignMessageResponseType) obj;
        if (obj == null) return false;
        if (this == obj) return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = true &amp;&amp; 
            ((this.error==null &amp;&amp; other.getError()==null) || 
             (this.error!=null &amp;&amp;
              this.error.equals(other.getError()))) &amp;&amp;
            ((this.message==null &amp;&amp; other.getMessage()==null) || 
             (this.message!=null &amp;&amp;
              this.message.equals(other.getMessage())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;
    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = 1;
        if (getError() != null) {
            _hashCode += getError().hashCode();
        }
        if (getMessage() != null) {
            _hashCode += getMessage().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc =
        new org.apache.axis.description.TypeDesc(SignMessageResponseType.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "SignMessageResponseType"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("error");
        elemField.setXmlName(new javax.xml.namespace.QName("", "error"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "Error"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("message");
        elemField.setXmlName(new javax.xml.namespace.QName("", "message"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanSerializer(
            _javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanDeserializer(
            _javaType, _xmlType, typeDesc);
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/xsd/VerifySignatureRequestType.java">/**
 * VerifySignatureRequestType.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool.xsd;

public class VerifySignatureRequestType  implements java.io.Serializable {
    /* Сообщение для проверки целостности */
    private java.lang.String message;

    /* атрибут указывает проверять ли сертификат на валидность */
    private boolean isCertCheck;

    /* атрибут ws-security:actor для проверки */
    private java.lang.String actor;

    public VerifySignatureRequestType() {
    }

    public VerifySignatureRequestType(
           java.lang.String message,
           boolean isCertCheck,
           java.lang.String actor) {
           this.message = message;
           this.isCertCheck = isCertCheck;
           this.actor = actor;
    }


    /**
     * Gets the message value for this VerifySignatureRequestType.
     * 
     * @return message   * Сообщение для проверки целостности
     */
    public java.lang.String getMessage() {
        return message;
    }


    /**
     * Sets the message value for this VerifySignatureRequestType.
     * 
     * @param message   * Сообщение для проверки целостности
     */
    public void setMessage(java.lang.String message) {
        this.message = message;
    }


    /**
     * Gets the isCertCheck value for this VerifySignatureRequestType.
     * 
     * @return isCertCheck   * атрибут указывает проверять ли сертификат на валидность
     */
    public boolean isIsCertCheck() {
        return isCertCheck;
    }


    /**
     * Sets the isCertCheck value for this VerifySignatureRequestType.
     * 
     * @param isCertCheck   * атрибут указывает проверять ли сертификат на валидность
     */
    public void setIsCertCheck(boolean isCertCheck) {
        this.isCertCheck = isCertCheck;
    }


    /**
     * Gets the actor value for this VerifySignatureRequestType.
     * 
     * @return actor   * атрибут ws-security:actor для проверки
     */
    public java.lang.String getActor() {
        return actor;
    }


    /**
     * Sets the actor value for this VerifySignatureRequestType.
     * 
     * @param actor   * атрибут ws-security:actor для проверки
     */
    public void setActor(java.lang.String actor) {
        this.actor = actor;
    }

    private java.lang.Object __equalsCalc = null;
    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof VerifySignatureRequestType)) return false;
        VerifySignatureRequestType other = (VerifySignatureRequestType) obj;
        if (obj == null) return false;
        if (this == obj) return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = true &amp;&amp; 
            ((this.message==null &amp;&amp; other.getMessage()==null) || 
             (this.message!=null &amp;&amp;
              this.message.equals(other.getMessage()))) &amp;&amp;
            this.isCertCheck == other.isIsCertCheck() &amp;&amp;
            ((this.actor==null &amp;&amp; other.getActor()==null) || 
             (this.actor!=null &amp;&amp;
              this.actor.equals(other.getActor())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;
    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = 1;
        if (getMessage() != null) {
            _hashCode += getMessage().hashCode();
        }
        _hashCode += (isIsCertCheck() ? Boolean.TRUE : Boolean.FALSE).hashCode();
        if (getActor() != null) {
            _hashCode += getActor().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc =
        new org.apache.axis.description.TypeDesc(VerifySignatureRequestType.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureRequestType"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("message");
        elemField.setXmlName(new javax.xml.namespace.QName("", "message"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("isCertCheck");
        elemField.setXmlName(new javax.xml.namespace.QName("", "isCertCheck"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "boolean"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("actor");
        elemField.setXmlName(new javax.xml.namespace.QName("", "actor"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanSerializer(
            _javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanDeserializer(
            _javaType, _xmlType, typeDesc);
    }

}
</java>
<java name="wss4j/gosuslugi/smev/SignatureTool/xsd/VerifySignatureResponseType.java">/**
 * VerifySignatureResponseType.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.gosuslugi.smev.SignatureTool.xsd;

public class VerifySignatureResponseType  implements java.io.Serializable {
    /* Результат выполнения операции */
    private wss4j.nvg.idecs.identityservice.ws.types.Error error;

    /* Сертификат в кодировке Base64 */
    private java.lang.String certificate;

    public VerifySignatureResponseType() {
    }

    public VerifySignatureResponseType(
           wss4j.nvg.idecs.identityservice.ws.types.Error error,
           java.lang.String certificate) {
           this.error = error;
           this.certificate = certificate;
    }


    /**
     * Gets the error value for this VerifySignatureResponseType.
     * 
     * @return error   * Результат выполнения операции
     */
    public wss4j.nvg.idecs.identityservice.ws.types.Error getError() {
        return error;
    }


    /**
     * Sets the error value for this VerifySignatureResponseType.
     * 
     * @param error   * Результат выполнения операции
     */
    public void setError(wss4j.nvg.idecs.identityservice.ws.types.Error error) {
        this.error = error;
    }


    /**
     * Gets the certificate value for this VerifySignatureResponseType.
     * 
     * @return certificate   * Сертификат в кодировке Base64
     */
    public java.lang.String getCertificate() {
        return certificate;
    }


    /**
     * Sets the certificate value for this VerifySignatureResponseType.
     * 
     * @param certificate   * Сертификат в кодировке Base64
     */
    public void setCertificate(java.lang.String certificate) {
        this.certificate = certificate;
    }

    private java.lang.Object __equalsCalc = null;
    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof VerifySignatureResponseType)) return false;
        VerifySignatureResponseType other = (VerifySignatureResponseType) obj;
        if (obj == null) return false;
        if (this == obj) return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = true &amp;&amp; 
            ((this.error==null &amp;&amp; other.getError()==null) || 
             (this.error!=null &amp;&amp;
              this.error.equals(other.getError()))) &amp;&amp;
            ((this.certificate==null &amp;&amp; other.getCertificate()==null) || 
             (this.certificate!=null &amp;&amp;
              this.certificate.equals(other.getCertificate())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;
    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = 1;
        if (getError() != null) {
            _hashCode += getError().hashCode();
        }
        if (getCertificate() != null) {
            _hashCode += getCertificate().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc =
        new org.apache.axis.description.TypeDesc(VerifySignatureResponseType.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://smev.gosuslugi.ru/SignatureTool/xsd/", "VerifySignatureResponseType"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("error");
        elemField.setXmlName(new javax.xml.namespace.QName("", "error"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "Error"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("certificate");
        elemField.setXmlName(new javax.xml.namespace.QName("", "certificate"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanSerializer(
            _javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanDeserializer(
            _javaType, _xmlType, typeDesc);
    }

}
</java>
<java name="wss4j/manager/CombinedSignatureManager.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import org.w3c.dom.Document;
import wss4j.manager.effeciency.EfficiencyThread;

/*
 * Class produces signed SOAP XML document and verify its signature. It also
 * calculates time of execution and count of operations. The type of
 * class is "combined".
 */
public class CombinedSignatureManager extends EfficiencyThread {

	private final int WAIT_TIMEOUT = 5;
	
	public CombinedSignatureManager(String name, SignatureManager signatureManager, 
			long workoutTimeout) {
		super(name, null, "combined", signatureManager, workoutTimeout);
	}

	synchronized private void printOperationResult(boolean result) {
		System.out.println("Document verification failed in CombainedSignatureManager thread " + this.name + 
				" (" + result + ")");

	}
	
	@Override
	public void run() {
		
		while (this.threadIsActive &amp;&amp;
				(java.lang.System.currentTimeMillis() - startTime)&lt;workoutTimeout ) {
			
			messageCount++;
			Document signedDoc = signatureManager.signDoc(signatureManager.getMessage());
			boolean verResult = signatureManager.verifyDoc(signedDoc, false);
			if (!verResult) {
				printOperationResult(verResult);
			}
			
			try {
				Thread.sleep(WAIT_TIMEOUT);
			} catch (InterruptedException e) {
				System.out.print("Thread.sleep failed in CombainedSignatureManager thread " + this.name + 
						" : " + e.getMessage());
			}
		}
		
		finish();
	}
}
</java>
<java name="wss4j/manager/SignatureManager.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import org.w3c.dom.Document;

/**
 * Simple class defines some methods to be used in thread tests.
 */
public abstract class SignatureManager {

	/**
	 * Function produces text XML SOAP message.
	 * @return XML SOAP message.
	 */
	public abstract String getMessage();
	
	/**
	 * Function sets signature in XML SOAP document.
	 * @param docStr - XML SOAP string.
	 * @return signed document.
	 */
	public abstract Document signDoc(String docStr);
	
	/**
	 * Function verifies signed XML SOAP document.
	 * @param signedDoc - signed document.
	 * @param printCert - option to print certificate.
	 * @return verification result.
	 */
	public abstract boolean verifyDoc(Document signedDoc, boolean printCert);
}
</java>
<java name="wss4j/manager/TestManager.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.text.DecimalFormat;
import wss4j.utility.SpecUtility;

/*
 * Class calculates time of test execution. callRealTestExecution must be
 * defined in derived class. It can print report about efficiency of test.
 */
public abstract class TestManager {

	protected String testName = null;
	protected double testTime = 0;
	protected DecimalFormat decFormat = new DecimalFormat("#.##");
	protected SignatureManager signatureManager = null;
	
	public TestManager(String name, SignatureManager signatureManager) throws KeyStoreException, 
	NoSuchAlgorithmException, CertificateException, ClassNotFoundException {
		
		SpecUtility.initJCP();
		
		testName = name;
		this.signatureManager = signatureManager;
	}
	
	protected String getTestName() {
		return testName;
	}
	
	protected double getTestTimeInSec() {
		return testTime*0.001;
	}
	
	public void execute() {
		
		System.out.println("Test " + testName + " is run!");
		long begTime = java.lang.System.currentTimeMillis();
		
		callRealTestExecution();
		
		testTime = (double)(java.lang.System.currentTimeMillis() - begTime);
		System.out.println("Test " + testName + " is finished!");
	}
	
	protected abstract void callRealTestExecution();	
	public abstract void report();
}
</java>
<java name="wss4j/manager/TestManagerCombined.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.Vector;
import wss4j.manager.effeciency.EfficiencyThread;

/*
 * Test collects statistics about operations of signing and verifying
 * of XML documents in different threads executing simultaneously.
 */
public class TestManagerCombined extends TestManager {

	private Vector&lt;EfficiencyThread&gt; threads = new Vector&lt;EfficiencyThread&gt;();
	private long threadCount = 0;
	private long workoutPeriod = 0;
		
	public TestManagerCombined(String name, long thCount,
			long workPeriod, SignatureManager signatureManager) throws KeyStoreException, 
			NoSuchAlgorithmException, CertificateException, ClassNotFoundException {
		super(name, signatureManager);
		threadCount = thCount;
		workoutPeriod = workPeriod;
	}

	protected void callRealTestExecution() {
		
		threads.clear();
		
		for (int i = 0; i &lt; threadCount; i++) {
			threads.add(new CombinedSignatureManager( "combained_" + (i + 1), 
					signatureManager, workoutPeriod ));
		}
		
		for (int i = 0; i &lt; threads.size(); i++) {
			
			try {
				threads.get(i).getThread().join(workoutPeriod);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		for (int i = 0; i &lt; threads.size(); i++) {
			
			threads.get(i).stop();
			
			try {
				threads.get(i).getThread().join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public void report() {
		
		long signedAndVerifiedDocCount = 0;
		for (int i = 0; i &lt; threads.size(); i++) {
			signedAndVerifiedDocCount += threads.get(i).getMessageCount();
		}

		System.out.println("###### Report: ######");
		System.out.println("Count of documents which were signed and verified: " + 
				signedAndVerifiedDocCount + " in " + threads.size() + " thread(s)");
		System.out.println("Total (signing &amp; verifying) time: " + decFormat.format(getTestTimeInSec()) + 
				" sec in " + threads.size() + " thread(s)");
		System.out.println("Rate of (signing &amp; verifying) operation: " + 
				decFormat.format((double)signedAndVerifiedDocCount/getTestTimeInSec()) + 
				" op/s (1 action rate ~ " + 
				decFormat.format( (double)signedAndVerifiedDocCount*2/(getTestTimeInSec()) ) + " op/s)");
	}
}
</java>
<java name="wss4j/manager/TestManagerMulti.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import org.w3c.dom.Document;
import wss4j.manager.effeciency.EfficiencyThread;
import wss4j.manager.effeciency.Processor;
import wss4j.manager.effeciency.Producer;

/*
 * Test collects statistics about operations of signing and verifying
 * of XML documents in different threads synchronized by queue of documents.
 */
public class TestManagerMulti extends TestManager {

	protected List&lt;Vector&lt;Document&gt;&gt; queues = new ArrayList&lt;Vector&lt;Document&gt;&gt;();
	protected Vector&lt;EfficiencyThread&gt; threads = new Vector&lt;EfficiencyThread&gt;();
	protected long producerCount = 0;
	protected long processorCount = 0;
	protected long workoutPeriod = 0;
	
	public TestManagerMulti(String name, long prodCount, long procCount,
		long workPeriod, SignatureManager signatureManager) throws KeyStoreException, 
		NoSuchAlgorithmException, CertificateException, ClassNotFoundException {
		
		super(name, signatureManager);
		producerCount = prodCount;
		processorCount = procCount;
		workoutPeriod = workPeriod;
	}
	
	protected void callRealTestExecution() {
		
		threads.clear();
		queues.add(new Vector&lt;Document&gt;());

		for (int i = 0; i &lt; producerCount; i++) {
			threads.add(new Producer( "producer_" + (i + 1), queues.get(0), 
					signatureManager, workoutPeriod ));
		}
		
		for (int i = 0; i &lt; processorCount; i++) {
			threads.add(new Processor( "processor_" + (i + 1), queues.get(0), 
					signatureManager, workoutPeriod ));
		}

		for (int i = 0; i &lt; threads.size(); i++) {
			
			try {
				threads.get(i).getThread().join(workoutPeriod);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		for (int i = 0; i &lt; threads.size(); i++) {
			
			threads.get(i).stop();
			
			try {
				threads.get(i).getThread().join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void report() {
		
		long signedDocCount = 0;
		long verifiedDocCount = 0;
		long producerCount = 0;
		long processorCount = 0;
		
		for (int i = 0; i &lt; threads.size(); i++) {
			
			if (threads.get(i).getType().equalsIgnoreCase("producer")) {
				producerCount++;
				signedDocCount += threads.get(i).getMessageCount();
			}
			else if (threads.get(i).getType().equalsIgnoreCase("processor")) {
				processorCount++;
				verifiedDocCount += threads.get(i).getMessageCount();
			}
		}
		
		System.out.println("###### Report: ######");

		System.out.println("Count of documents which were signed: " + signedDocCount + 
				" in " + producerCount + " thread(s)");
		System.out.println("Count of documents which were verified: " + verifiedDocCount + 
				" in " + processorCount + " thread(s)");
		System.out.println("Total count of operations: " + (signedDocCount + verifiedDocCount));
		System.out.println("Total (signing &amp; verifying) time: " + decFormat.format(getTestTimeInSec()) + " sec in " + 
				producerCount + " thread(s)");
		System.out.println("Rate of (signing &amp; verifying) operation: " + 
				decFormat.format((double)(signedDocCount + verifiedDocCount)/getTestTimeInSec()) + " op/s");
	}
}
</java>
<java name="wss4j/manager/TestManagerMultiQueue.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.Vector;
import org.w3c.dom.Document;

import wss4j.manager.effeciency.Processor;
import wss4j.manager.effeciency.Producer;

/*
 * Test collects statistics about operations of signing and verifying
 * of XML documents in different threads. Every pair of producer and
 * processor is synchronized by queue of documents.
 */
public class TestManagerMultiQueue extends TestManagerMulti {

	private long queueCount = 0;
	
	public TestManagerMultiQueue(String name, long queueCount,
			long workPeriod, SignatureManager signatureManager) throws KeyStoreException, 
			NoSuchAlgorithmException, CertificateException, ClassNotFoundException {
		super(name, queueCount, queueCount, workPeriod, signatureManager);
		this.queueCount = queueCount;
	}

	protected void callRealTestExecution() {
		
		threads.clear();
		
		for (long i = 0; i &lt; queueCount; i++) {
			queues.add(new Vector&lt;Document&gt;());
		}

		for (int i = 0; i &lt; producerCount; i++) {
			threads.add(new Producer( "producer_" + (i + 1), queues.get(i), 
					signatureManager, workoutPeriod ));
		}

		for (int i = 0; i &lt; processorCount; i++) {
			threads.add(new Processor( "processor_" + (i + 1), queues.get(i), 
					signatureManager, workoutPeriod ));
		}

		for (int i = 0; i &lt; threads.size(); i++) {
			
			try {
				threads.get(i).getThread().join(workoutPeriod);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		for (int i = 0; i &lt; threads.size(); i++) {
			
			threads.get(i).stop();
			
			try {
				threads.get(i).getThread().join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
</java>
<java name="wss4j/manager/TestManagerSingle.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import org.w3c.dom.Document;

/*
 * Test collects statistics about operations of signing and verifying
 * of XML documents in main thread.
 */
public class TestManagerSingle extends TestManager {

	private long circleCount = 1000;
	private long totalSigningTime = 0;
	private long totalVerifyingTime = 0;
		
	public TestManagerSingle(String name, long crCount, SignatureManager signatureManager) 
	throws KeyStoreException, NoSuchAlgorithmException, CertificateException, ClassNotFoundException {
		super(name, signatureManager);
		circleCount = crCount;
	}

	protected void callRealTestExecution() {
		
		for (int i = 0; i &lt; circleCount; i++) {
			
			long startTime = java.lang.System.currentTimeMillis();
			Document signedDoc = signatureManager.signDoc(signatureManager.getMessage());
			totalSigningTime += (java.lang.System.currentTimeMillis() - startTime);

			startTime = java.lang.System.currentTimeMillis();
			boolean result = signatureManager.verifyDoc(signedDoc, false);
			totalVerifyingTime += (java.lang.System.currentTimeMillis() - startTime);
			
			if (!result) {
				System.out.println("Delta verification failed (" + result + ")");
			}
		}
	}

	public void report() {
		
		double mediumSigningRate = (double)circleCount/(totalSigningTime*0.001);
		double mediumVerifyingTime = (double)circleCount/(totalVerifyingTime*0.001);
		
		System.out.println("###### Report: ######");
		System.out.println("Count of documents which were signed and verified: " + circleCount);
		System.out.println("Total (signing &amp; verifying) time: " + decFormat.format(getTestTimeInSec()) + " sec");
		System.out.println("Rate of signing: " + decFormat.format(mediumSigningRate) + " op/s");
		System.out.println("Rate of verifying: " + decFormat.format(mediumVerifyingTime) + " op/s");
		System.out.println("Rate of (signing &amp; verifying) operation: " + 
				decFormat.format( (double)circleCount/(getTestTimeInSec()) ) + 
				" op/s (1 action rate ~ " + 
				decFormat.format( (double)circleCount*2/(getTestTimeInSec()) ) + " op/s)");
	}
}
</java>
<java name="wss4j/manager/effeciency/EfficiencyThread.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager.effeciency;

import java.util.Vector;
import org.w3c.dom.Document;
import wss4j.manager.SignatureManager;

/*
 * Base class, which extends standard implementation of thread. It contains
 * single signature provider to produce and verify signatures in SOAP
 * XML documents.
 */
public abstract class EfficiencyThread implements Runnable {

	protected Thread thread;
	protected String name;
	protected Vector&lt;Document&gt; queue;
	volatile protected boolean threadIsActive;
	protected long messageCount;
	protected SignatureManager signatureManager = null;
	private String type;
	protected long workoutTimeout = 0;
	protected long startTime = 0;
	
	protected EfficiencyThread(String name, Vector&lt;Document&gt; queue, String type, 
			SignatureManager signatureManager, long workoutTimeout) {
		this.name = name;
		this.type = type;
		this.queue = queue;
		this.threadIsActive = true;
		this.messageCount = 0;
		this.workoutTimeout = workoutTimeout;
		this.startTime = java.lang.System.currentTimeMillis();
		this.signatureManager = signatureManager;
		this.thread = new Thread(this, name);
		this.thread.start();
	}

	@Override
	public abstract void run();
	
	public void stop() {
		this.threadIsActive = false;
	}
	
	public Thread getThread() {
		return this.thread;
	}
	
	public String getName() {
		return this.name;
	}
	
	public long getMessageCount() {
		return this.messageCount;
	}
	
	public String getType() {
		return this.type;
	}
	
	synchronized protected void finish() {
		System.out.println("Thread " + this.name + " is stopped. Message count: " + this.messageCount);
	}
}
</java>
<java name="wss4j/manager/effeciency/Processor.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager.effeciency;

import java.util.Vector;
import org.w3c.dom.Document;
import wss4j.manager.SignatureManager;

/*
 * Class processes signed SOAP XML document reading from queue (signature
 * verification). The type of class is "processor".
 */
public class Processor extends EfficiencyThread {

	private final int WAIT_TIMEOUT = 3000;
	
	public Processor(String name, Vector&lt;Document&gt; queue, 
			SignatureManager signatureManager, long workoutTimeout) {
		super(name, queue, "processor", signatureManager, workoutTimeout);
	}
	
	public void run() {
		
		synchronized(queue) {
		
			while (this.threadIsActive &amp;&amp;
					(java.lang.System.currentTimeMillis() - startTime)&lt;workoutTimeout) {
				
				try {
					queue.wait(WAIT_TIMEOUT);
				} catch (InterruptedException e) {
					System.out.println("Queue.wait failed in Processor thread " + name + " : " + e.getMessage());
				}
				
				if (queue.size() &gt; 0) {
					
					messageCount++;
					Document signedDoc = queue.firstElement();
					queue.remove(0);
					
					boolean verResult = signatureManager.verifyDoc(signedDoc, false);
					if (!verResult) {
						System.out.println("Verification failed in Processor thread " + name + " (" + 
								verResult + ")");
					}
				}
			}
		}

		finish();
	}
}
</java>
<java name="wss4j/manager/effeciency/Producer.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.manager.effeciency;

import java.util.Vector;
import org.w3c.dom.Document;
import wss4j.manager.SignatureManager;

/*
 * Class produces signed SOAP XML document and adds it into queue.
 * The type of class is "producer".
 */
public class Producer extends EfficiencyThread {
	
	private final int WAIT_TIMEOUT = 5;
	
	public Producer(String name, Vector&lt;Document&gt; queue, 
			SignatureManager signatureManager, long workoutTimeout) {
		super(name, queue, "producer", signatureManager, workoutTimeout);
	}
	
	public void run() {

		while (this.threadIsActive &amp;&amp;
				(java.lang.System.currentTimeMillis() - startTime)&lt;workoutTimeout) {
			
			synchronized(queue) {
				
				messageCount++;
				Document signedDoc = signatureManager.signDoc(signatureManager.getMessage());
				queue.add(signedDoc);
				queue.notifyAll();
				
			}
			
			try {
				Thread.sleep(WAIT_TIMEOUT);
			} catch (InterruptedException e) {
				System.out.print("Thread.sleep failed in Producer thread " + name + " : " + e.getMessage());
			}
		}

		finish();
	}
}
</java>
<java name="wss4j/nvg/idecs/identityservice/ws/types/Error.java">/**
 * Error.java
 *
 * This file was auto-generated from WSDL
 * by the Apache Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.
 */

package wss4j.nvg.idecs.identityservice.ws.types;

public class Error  implements java.io.Serializable {
    private long errorCode;

    private java.lang.String errorMessage;

    public Error() {
    }

    public Error(
           long errorCode,
           java.lang.String errorMessage) {
           this.errorCode = errorCode;
           this.errorMessage = errorMessage;
    }


    /**
     * Gets the errorCode value for this Error.
     * 
     * @return errorCode
     */
    public long getErrorCode() {
        return errorCode;
    }


    /**
     * Sets the errorCode value for this Error.
     * 
     * @param errorCode
     */
    public void setErrorCode(long errorCode) {
        this.errorCode = errorCode;
    }


    /**
     * Gets the errorMessage value for this Error.
     * 
     * @return errorMessage
     */
    public java.lang.String getErrorMessage() {
        return errorMessage;
    }


    /**
     * Sets the errorMessage value for this Error.
     * 
     * @param errorMessage
     */
    public void setErrorMessage(java.lang.String errorMessage) {
        this.errorMessage = errorMessage;
    }

    private java.lang.Object __equalsCalc = null;
    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof Error)) return false;
        Error other = (Error) obj;
        if (obj == null) return false;
        if (this == obj) return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = true &amp;&amp; 
            this.errorCode == other.getErrorCode() &amp;&amp;
            ((this.errorMessage==null &amp;&amp; other.getErrorMessage()==null) || 
             (this.errorMessage!=null &amp;&amp;
              this.errorMessage.equals(other.getErrorMessage())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;
    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = 1;
        _hashCode += new Long(getErrorCode()).hashCode();
        if (getErrorMessage() != null) {
            _hashCode += getErrorMessage().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc =
        new org.apache.axis.description.TypeDesc(Error.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "Error"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("errorCode");
        elemField.setXmlName(new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "errorCode"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "long"));
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("errorMessage");
        elemField.setXmlName(new javax.xml.namespace.QName("http://idecs.nvg.ru/identityservice/ws/types/", "errorMessage"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanSerializer(
            _javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(
           java.lang.String mechType, 
           java.lang.Class _javaType,  
           javax.xml.namespace.QName _xmlType) {
        return 
          new  org.apache.axis.encoding.ser.BeanDeserializer(
            _javaType, _xmlType, typeDesc);
    }

}
</java>
<java name="wss4j/utility/SOAPUtility.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.utility;

import org.apache.axis.Message;
import org.apache.axis.message.SOAPEnvelope;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;

/**
 * Class with auxiliary SOAP functions.
 */
public class SOAPUtility {

	/**
	 * Simple XML SOAP example.
	 */
	public static final String SOAPMSG = 
        "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;" 
        + "&lt;SOAP-ENV:Envelope "
        +   "xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" "
        +   "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" "
        +   "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;" 
        +   "&lt;SOAP-ENV:Body&gt;" 
        +       "&lt;add xmlns=\"http://ws.apache.org/counter/counter_port_type\"&gt;" 
        +           "&lt;value xmlns=\"\"&gt;15&lt;/value&gt;" 
        +       "&lt;/add&gt;" 
        +   "&lt;/SOAP-ENV:Body&gt;" 
        + "&lt;/SOAP-ENV:Envelope&gt;";

	/** Function checks 'org.apache.ws.security.crypto.provider' option in 
	 * 'crypto.properties' to determine wss4j version: 
	 * 		if Merlin's base class is AbstractCrypto, then wss4j version is 1.5.11, 
	 * 		else if Merlin's base class is CryptoBase, then version is 1.6.3.
	 * @param className - name of provider (Merlin).
	 * @return - true, if version is 1.5.11.
	 * @throws ClassNotFoundException
	 */
	public static boolean is_1_5_11( String className ) throws ClassNotFoundException {
	
		Class classType = Class.forName(className);
		Class superClassType = classType.getSuperclass();
		String superClassName = superClassType.getSimpleName();
		
		// If properties contains MerlinEx class
		if ( superClassName.equalsIgnoreCase("Merlin") ) {
			return is_1_5_11(superClassType.getName());
		}
		
		if ( superClassName.equalsIgnoreCase("AbstractCrypto") ) {
			return true;
		}
		
		return false;
	}
	
	/**
	 * Function creates SOAP XML message from string.
	 * @return SOAP XML message.
	 * @throws Exception
	 */
	public static SOAPEnvelope getSOAPEnvelopeFromString(String message) throws Exception {
        
    	InputStream input = new ByteArrayInputStream(message.getBytes());
        Message msg = new Message(input);
        return msg.getSOAPEnvelope();
        
    }
	
	/**
	 * Function creates SOAP XML message reading file .
	 * @param fileName - SOAP XML file name.
	 * @return SOAP XML message.
	 * @throws Exception
	 */
	public static SOAPEnvelope getSOAPEnvelopeFromFile(String fileName) throws Exception {
    	
    	InputStream input = new FileInputStream( new File(fileName) );
        Message msg = new Message(input);
        return msg.getSOAPEnvelope();
        
    }
}
</java>
<java name="wss4j/utility/SpecUtility.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.utility;

import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.*;
import java.security.cert.*;
import java.util.*;

/**
 * Class with auxiliary functions.
 */
public class SpecUtility {
	
	// All properties
	private static Properties props = new Properties();
	// Default properties. Alternative configuration is wss40 (+ our own variables related to
	// WSS4J files in /keys directory: 'wss40' is valid, 'wss40rev' is revoked)
	public static final String DEFAULT_CRYPTO_PROPERTIES = System.getProperty("user.dir") +
        "/data/WebContent/crypto.properties";
	public static String DEFAULT_STORETYPE = "HDImageStore";
	public static String DEFAULT_KEYSTORE = null;
	public static String DEFAULT_ALIAS = null;
	public static char[] DEFAULT_PASSWORD = null;
	public static String DEFAULT_CERT_FILE = null;
	public static String DEFAULT_CA_FILE = null;
	public static String DEFAULT_CRL_FILE = null;
    public static String MERLIN_PROVIDER = null;
	
	// Load all settings from crypto.properties
	static {
		
		try {
			
			props.load(new FileInputStream(DEFAULT_CRYPTO_PROPERTIES));

            MERLIN_PROVIDER = props.getProperty("org.apache.ws.security.crypto.provider");

			// Standard WSS4J variables
			DEFAULT_STORETYPE = props.getProperty("org.apache.ws.security.crypto.merlin.keystore.type");
			DEFAULT_KEYSTORE = props.getProperty("org.apache.ws.security.crypto.merlin.file");
			DEFAULT_ALIAS = props.getProperty("org.apache.ws.security.crypto.merlin.keystore.alias");
			
			String password = props.getProperty("org.apache.ws.security.crypto.merlin.keystore.password");
			if (password != null) {
				DEFAULT_PASSWORD = password.toCharArray();
			}
			
			// Our own variables
			DEFAULT_CERT_FILE = props.getProperty("cert.file");
			DEFAULT_CA_FILE = props.getProperty("ca.file");
			DEFAULT_CRL_FILE = props.getProperty("crl.file");

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
		
	/**
	 * Functions initializes XML JCP.
	 */
	public static void initJCP() {
		
		if(!JCPXMLDSigInit.isInitialized())
    		JCPXMLDSigInit.init();
		
		System.setProperty("com.ibm.security.enableCRLDP", "false");
	}

	/**
	 * Function loads store information from key store.
	 * @param storeType - type of key store (HDImageStore, JKS, PKCS12).
	 * @param store - store file.
	 * @param storePassword - password to store.
	 * @return loaded key store.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public static KeyStore loadKeyStore( String storeType, File store, char[] storePassword ) 
	throws KeyStoreException, NoSuchAlgorithmException, CertificateException, 
		FileNotFoundException, IOException {

		KeyStore keyStore = KeyStore.getInstance(storeType);
		FileInputStream inputStream = null;

		if (store != null)
			inputStream = new FileInputStream(store);

		keyStore.load( keyStore == null ? null : inputStream, storePassword );
		return keyStore;		 
	}
	
	/**
	 * Function verifies the user certificate chain 'certs'.
	 * @param crlFile - CRL file (can be null).
	 * @param certs - list of user certificates to be checked.
	 * @param cacerts - list of trusted certificates. 
	 * @param endPointCertificate - a certificate as last verifiable link in the chain (can be null).
	 * @return true, if chain is valid.
	 * @throws CRLException
	 * @throws FileNotFoundException
	 * @throws SignatureException 
	 * @throws NoSuchProviderException 
	 * @throws InvalidKeyException 
	 * @throws CertPathBuilderException 
	 */
	public static boolean validateCertPath(File crlFile,
			X509Certificate[] certs, X509Certificate[] cacerts,
			X509Certificate endPointCertificate) throws 
			CRLException, FileNotFoundException, InvalidKeyException, 
			NoSuchProviderException, SignatureException, CertPathBuilderException {
        
		PKIXCertPathValidatorResult bldResult = null;
		List&lt;CertStore&gt; storeCertCRL = null;
		CertStore crlCertStore = null;
    	boolean crlIsAdded = false;
    	boolean bResult = false;
		
		try {
          
    		CertificateFactory certFactory = CertificateFactory.getInstance("X509");
    		
    		/**
    		 * Add CRL in list.
    		 */
    		if ( crlFile != null ) {
    			
    			CRL crl = certFactory.generateCRL(new FileInputStream(crlFile));
    			if ( crl != null )
    				crlCertStore = CertStore.getInstance( "Collection", new CollectionCertStoreParameters(Collections.singletonList(crl)) );
    		
    			if (crlCertStore != null) {
    				storeCertCRL = Arrays.asList(crlCertStore);
    				crlIsAdded = true;
    			}
    		}
    		
            List&lt;X509Certificate&gt; certList = Arrays.asList(certs);
            CertPath path = certFactory.generateCertPath(certList);
            System.out.println("Certificate path length: " + path.getCertificates().size());
            
            Set&lt;TrustAnchor&gt; trustedAnchors = new HashSet&lt;TrustAnchor&gt;();

            if (cacerts != null) {
                for ( int i = 0; i &lt; cacerts.length; ++i ) {
                    TrustAnchor anchor = 
                        new TrustAnchor(cacerts[i], 
                        		cacerts[i].getExtensionValue("2.5.29.30"));
                    if (anchor != null &amp;&amp; !trustedAnchors.contains(anchor) )
                    	trustedAnchors.add(anchor);
                }
            }

            /* 
            if (certs != null) {
                for ( int i = 0; i &lt; certs.length; ++i ) {
                	TrustAnchor anchor = 
                		new TrustAnchor(certs[i], 
                    		certs[i].getExtensionValue(Merlin.NAME_CONSTRAINTS_OID));
                	if ( anchor != null &amp;&amp; !trustedAnchors.contains(anchor) )
                		trustedAnchors.add(anchor);
                }
            }
            */
            
            System.out.println("Trusted anchor deepth: " + trustedAnchors.size());
            
            if (certs != null &amp;&amp; cacerts != null &amp;&amp; 
            		certs.length == 1 &amp;&amp; cacerts.length == 1) {
            	certs[0].checkValidity();
            	certs[0].verify(cacerts[0].getPublicKey());
            }
            
            PKIXParameters param = new PKIXParameters(trustedAnchors);
            param.setSigProvider(null);
            param.setRevocationEnabled(crlIsAdded);
            if (crlIsAdded)
            	 param.setCertStores(storeCertCRL);
          
            if (endPointCertificate != null) {
            	final X509CertSelector selector = new X509CertSelector();
            	selector.setCertificate(endPointCertificate);
            	param.setTargetCertConstraints(selector);
            }

            CertPathValidator certPathValidator = CertPathValidator.getInstance("PKIX");
            bldResult = (PKIXCertPathValidatorResult)certPathValidator.validate(path, param);
            /* MUST BE (bldResult != null)
            PublicKey publicKey = bldResult.getPublicKey();
            */
            bResult = true;
            
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        } catch (CertificateException ex) {
        	ex.printStackTrace();
        } catch (InvalidAlgorithmParameterException ex) {
        	ex.printStackTrace();
        } catch (CertPathValidatorException ex) {
        	ex.printStackTrace();
        	System.out.println("Index of certificate that caused exception: "
                    + ex.getIndex());
        }
        
        System.out.println("Path Validator result (public key algorithm): " + 
        		((bldResult != null) ? bldResult.getPublicKey().getAlgorithm() : null));

        return bResult;
    }
}
</java>
<java name="wss4j/wss4j1_6_3/bad/IBM6XSLTTest.java">package wss4j.wss4j1_6_3.bad;

import org.apache.ws.security.message.WSSecHeader;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.tools.Platform;
import wss4j.gosuslugi.smev.SignatureTool.SignatureTool;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolService;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolServiceLocator;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType;
import wss4j.manager.SignatureManager;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import java.io.*;
import java.net.URL;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;

/**
 * Проблема удаления пространства xmlns:ds из xsl:stylesheet шаблона в блоке SignedInfo-&gt;Transforms.
 * Замена его любым другим url, проверяем, что подпись проверяется локально и СМЭВ.
 * Формируем с помощью JCPxml, проверяем с помощью XMLDSigRI и в тестовом сервисе СМЭВ.
 * Собственно, замеченная проблема:
 * на IBM JVM 6 происходит удаление xmlns:ds во вложенных узлах, остается упоминание только в верхнем
 * узле. Например, если добавляем в header, то пропадет xmlns:ds в Signature, а в нем - в xsl:stylesheet.
 * Если уберем из header, то xmlns:ds появится в Signature, но так и не появится в xsl:stylesheet.
 * &lt;Header&gt;
 *     ...
 *     &lt;Signature&gt;
 *      ...
 *      &lt;xsl:stylesheet&gt;
 *          ...
 *      &lt;/xsl:stylesheet&gt;
 *      ...
 *     &lt;/Signature&gt;
 *     ...
 * &lt;/Header&gt;
 */
public class IBM6XSLTTest {

    /**
     * Файл с документом для подписи.
     */
    private final static String inSOAPFile = System.getProperty("user.dir") + "/data/unsignedRequest.xml";
    /**
     * Адрес тестового сервиса СМЭВ.
     */
    private final static String smevService = "http://188.254.16.92:7777/gateway/services/SID0003038";
    /**
     * Нужно ли проверять подпись онлайн в сервисе СМЭВ.
     */
    private final static boolean checkOnline = true;
    /**
     * True, если IBM JVM.
     */
    private final static boolean isIBM = Platform.isIBM();

    /**
     * @param args
     * @throws
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {

        // Стандартное пространство ds, не удаляемое на SUN JVM.
        String xmlns_ds = "'http://www.w3.org/2000/09/xmldsig#'";

        // Замена любым url на IBM JVM.
        if (isIBM) {
            xmlns_ds = "'http://any.url'";
        }

        xmlns_ds = "xmlns:ds=" + xmlns_ds;

        // XSL шаблон.
        final String transformStr = "" +
                "&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' " + xmlns_ds + " version='1.0'&gt;\n" +
                "  &lt;xsl:template match='/'&gt;\n" +
                "    &lt;xsl:apply-templates /&gt;\n" +
                "  &lt;/xsl:template&gt;\n" +
                "  &lt;xsl:template match='*'&gt;\n" +
                "    &lt;xsl:copy&gt;\n" +
                "      &lt;xsl:copy-of select='@*' /&gt;\n" +
                "      &lt;xsl:apply-templates /&gt;\n" +
                "    &lt;/xsl:copy&gt;\n" +
                "  &lt;/xsl:template&gt;\n" +
                "  &lt;xsl:template match='ds:Signature' /&gt;\n" +
                "    &lt;/xsl:stylesheet&gt;\n";

        com.sun.org.apache.xml.internal.security.Init.init();
        SpecUtility.initJCP();

        KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
        keyStore.load(null, null);

        PrivateKey privateKey = (PrivateKey)keyStore.getKey(SpecUtility.DEFAULT_ALIAS,
                SpecUtility.DEFAULT_PASSWORD);
        X509Certificate cert = (X509Certificate) keyStore.getCertificate(SpecUtility.DEFAULT_ALIAS);

        MessageFactory mf = MessageFactory.newInstance();

        SOAPMessage sm = mf.createMessage();
        SOAPPart soapPart = sm.getSOAPPart();

        FileInputStream is = new FileInputStream(inSOAPFile);
        // Set contents of message
        soapPart.setContent(new StreamSource(is));

        sm.getSOAPPart().getEnvelope().addNamespaceDeclaration("wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
        sm.getSOAPPart().getEnvelope().addNamespaceDeclaration("wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
        sm.getSOAPPart().getEnvelope().addNamespaceDeclaration("ds", "http://www.w3.org/2000/09/xmldsig#");
        sm.getSOAPBody().setAttributeNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", "wsu:Id", "body");

        WSSecHeader header = new WSSecHeader();
        header.setActor("http://smev.gosuslugi.ru/actors/smev");
        header.setMustUnderstand(false);

        Element sec = header.insertSecurityHeader(sm.getSOAPPart());
        Document doc = sm.getSOAPPart().getEnvelope().getOwnerDocument();

        Element token =(Element) sec.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:BinarySecurityToken"));
        token.setAttribute("EncodingType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary");
        token.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
        token.setAttribute("wsu:Id", "CertId");
        header.getSecurityHeader().appendChild(token);

        final XMLSignature sig =
                new XMLSignature(doc, "http://www.w3.org/2000/09/xmldsig#", "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411", Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS);

        // Работаем с документом.
        final Document xsltDoc = doc; // (Document) doc.cloneNode(true);

        final DocumentBuilderFactory xsltDbf =
                DocumentBuilderFactory.newInstance();

        xsltDbf.setNamespaceAware(true);
        final DocumentBuilder xsltDb = xsltDbf.newDocumentBuilder();

        final Document xsltDocTr =
                xsltDb.parse(new ByteArrayInputStream(transformStr.getBytes()));

        final Element xsltTrEl =
                (Element) xsltDoc.importNode(xsltDocTr.getDocumentElement(), true);

        final Transforms xsltTransforms = new Transforms(xsltDoc);

        xsltTransforms.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);
        xsltTransforms.addTransform(Transforms.TRANSFORM_XSLT, xsltTrEl);
        xsltTransforms.addTransform(Transforms.TRANSFORM_C14N_OMIT_COMMENTS);

        sig.addDocument("#body", xsltTransforms, "http://www.w3.org/2001/04/xmldsig-more#gostr3411");
        sig.addKeyInfo(cert);
        sig.sign(privateKey);

        Element sigE = sig.getElement();
        Node keyE = XPathAPI.selectSingleNode(sigE, "//ds:KeyInfo", sigE);
        token.appendChild(doc.createTextNode(XPathAPI.selectSingleNode(keyE, "//ds:X509Certificate", keyE).getFirstChild().getNodeValue()));

        keyE.removeChild(XPathAPI.selectSingleNode(keyE, "//ds:X509Data", keyE));

        NodeList chl = keyE.getChildNodes();
        for (int i = 0; i &lt; chl.getLength(); i++) {
            keyE.removeChild(chl.item(i));
        }

        Node str = keyE.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:SecurityTokenReference"));
        Element strRef = (Element)str.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Reference"));
        strRef.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
        strRef.setAttribute("URI", "#CertId");

        header.getSecurityHeader().appendChild(sigE);

        String mes = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(doc);
        System.out.println(mes);

        // Сохраним подписанный документ в файл.
        xmlToFile(doc,inSOAPFile + "_signed_" + (isIBM ? "ibm" : "sun") + "_SOAP.xml");

        if (checkOnline) {

            SignatureManager signatureManager =
                    new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES,
                            SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);

            System.out.println( "Проверка ЭЦП: " + signatureManager.verifyDoc(doc, true) );

            SignatureToolService sts = new SignatureToolServiceLocator();
            SignatureTool st = sts.getSignatureToolPort(new URL(smevService));

            VerifySignatureRequestType vsrt = new VerifySignatureRequestType(mes, false,
                    "http://smev.gosuslugi.ru/actors/smev");
            VerifySignatureResponseType result = st.verifySignature(vsrt);

            System.out.println("Проверка ЭЦП в сервисе СМЭВ: код ошибки = " +
                    result.getError().getErrorCode() + ", описание = " + result.getError().getErrorMessage());
        }
    }

    /**
     * Экспорт документа в файл.
     *
     * @param doc Документ.
     * @param path Путь к файлу, в который нужно записать документ.
     * @throws IOException
     * @throws TransformerException
     */
    public static void xmlToFile(Document doc, String path) throws IOException, TransformerException {

        final OutputStream os = new FileOutputStream(path);
        final TransformerFactory tf = TransformerFactory.newInstance();
        final Transformer trans = tf.newTransformer();
        trans.transform(new DOMSource(doc), new StreamResult(os));
        os.close();
    }
}
</java>
<java name="wss4j/wss4j1_6_3/bad/TestDubl.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.bad;

import org.apache.axis.message.SOAPEnvelope;
import org.apache.ws.security.WSConstants;
import org.apache.ws.security.WSSecurityEngine;
import org.apache.ws.security.WSSecurityEngineResult;
import org.apache.ws.security.WSSecurityException;
import org.apache.ws.security.components.crypto.Crypto;
import org.apache.ws.security.components.crypto.Merlin;
import org.apache.ws.security.message.WSSecHeader;
import org.apache.ws.security.message.WSSecSignature;
import org.apache.ws.security.util.WSSecurityUtil;
import org.w3c.dom.Document;
import wss4j.utility.SOAPUtility;
import wss4j.utility.SpecUtility;

import java.security.Provider;
import java.security.Security;
import java.util.List;

/**
 * Attention! If test shows an exception about unsupported algorithm in newDigestMethod or/and
 * newSignatureMethod then: 
 * ...
 *	Provider pNew = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();
 *	Security.addProvider(pNew);
 *	...
 *	Security.getProvider("XMLDSig").put("XMLSignatureFactory.DOM", 
 *		        "ru.CryptoPro.JCPxml.dsig.internal.dom.DOMXMLSignatureFactory");
 *	Security.getProvider("XMLDSig").put("KeyInfoFactory.DOM", 
 *		        "ru.CryptoPro.JCPxml.dsig.internal.dom.DOMKeyInfoFactory");
 *	...
 * Example works correctly in java 7 (e.g. jdk1.7.0_02).
 */

/**
 * Example shows that xmlns is duplicated in every node.
 */
public class TestDubl {

	private static Crypto crypto = null;
	private static WSSecurityEngine secEngine = new WSSecurityEngine();
	
	/**
	 * @param args
	 * @throws Exception 
	 */
	public static void main(String[] args) throws Exception {

		// Initialize JCP
		com.sun.org.apache.xml.internal.security.Init.init();
		SpecUtility.initJCP();
		
		// Load CryptoPro XMLDSig service provider
		Provider provCryptoProRI = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();
		Security.addProvider(provCryptoProRI);

		// Override methods
		Security.getProvider("XMLDSig").put("XMLSignatureFactory.DOM", 
		        "ru.CryptoPro.JCPxml.dsig.internal.dom.DOMXMLSignatureFactory");
		Security.getProvider("XMLDSig").put("KeyInfoFactory.DOM", 
		        "ru.CryptoPro.JCPxml.dsig.internal.dom.DOMKeyInfoFactory");

		// Prepare SOAP message
		SOAPEnvelope unsignedEnvelope = SOAPUtility.getSOAPEnvelopeFromString(SOAPUtility.SOAPMSG);
		Document doc = unsignedEnvelope.getAsDocument();
	    WSSecHeader secHeader = new WSSecHeader();
	    secHeader.insertSecurityHeader(doc);

	    // Create Merlin to execute cryptographic operations
	    Merlin merlin = new Merlin();
		merlin.setKeyStore(SpecUtility.loadKeyStore(SpecUtility.DEFAULT_STORETYPE, null, 
				SpecUtility.DEFAULT_PASSWORD));
		crypto = merlin;

		// Prepare object to sign SOAP message (alias, password, algorithm etc)
		WSSecSignature sign = new WSSecSignature();
		
		String pswrd = null;
		if (SpecUtility.DEFAULT_PASSWORD != null) {
			pswrd = new String(SpecUtility.DEFAULT_PASSWORD);
		}
		
		sign.setUserInfo(SpecUtility.DEFAULT_ALIAS, pswrd);
	    sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
	    sign.setSignatureAlgorithm(ru.CryptoPro.JCPxml.Consts.URI_GOST_SIGN);
	    sign.setDigestAlgo(ru.CryptoPro.JCPxml.Consts.URI_GOST_DIGEST);
	    
	    Document signedDoc = null;
	    
	    try {
	    	// Sign SOAP XML document
			signedDoc = sign.build(doc, crypto, secHeader);
		} catch (WSSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// See duplicated xmlns
	    String docStr = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(signedDoc);
	    System.out.println("Signed document: " + docStr);
        /*
        Element el =
            (Element) signedDoc.getElementsByTagNameNS("http://ws.apache.org/counter/counter_port_type", "add").item(0);
        Element val = (Element) el.getElementsByTagName("value").item(0);
        val.setTextContent("16");

        docStr = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(signedDoc);
        System.out.println("Bad signed document: " + docStr);
        */
	    WSSecurityEngineResult actionResult = null;
		// Verify signature and see that it's wrong because of excess xmlns
		try {

			List&lt;WSSecurityEngineResult&gt; results = secEngine.processSecurityHeader(signedDoc, null, null, crypto);
			actionResult = WSSecurityUtil.fetchActionResult(results, WSConstants.SIGN);
		
		} catch (WSSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// Wrong document shows 'null'
		System.out.println("Verified: " + actionResult);
	}
}
</java>
<java name="wss4j/wss4j1_6_3/manager/SOAPXMLSignatureManager_1_6_3.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.manager;

import java.io.*;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.xml.crypto.KeySelector;
import javax.xml.crypto.XMLStructure;
import javax.xml.crypto.dsig.CanonicalizationMethod;
import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.Transform;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.transform.TransformerException;
import javax.xml.transform.stream.StreamSource;

import org.apache.axis.message.SOAPEnvelope;
import org.apache.ws.security.WSSecurityException;
import org.apache.ws.security.message.WSSecHeader;
import org.apache.ws.security.message.token.X509Security;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import wss4j.manager.SignatureManager;
import wss4j.utility.SOAPUtility;
import wss4j.utility.SpecUtility;

/*
 * Class provides generating and verifying of signature. For wss4j 1.5.11 only.
 */
public class SOAPXMLSignatureManager_1_6_3 extends SignatureManager {
	
	private Object[] samData = null;
	private Provider xmlDSigProvider = null;
	
	public SOAPXMLSignatureManager_1_6_3(String propertyFile, String alias, char[] StorePassword, 
			char [] keyPassword) throws ClassNotFoundException, KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, UnrecoverableKeyException, FileNotFoundException, IOException {
		
		// Load JCP
		com.sun.org.apache.xml.internal.security.Init.init();
		SpecUtility.initJCP();
		
		xmlDSigProvider = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();
		// Create objects to sign and verify SOAP XML messages
		setSAMdata(null, StorePassword, alias, keyPassword);
	}
	
	private void setSAMdata( File keyStore, char[] keyStorePass, String alias, char[] aliasKeyRecoveryPass) 
	throws KeyStoreException, NoSuchAlgorithmException, CertificateException, FileNotFoundException, 
	IOException, UnrecoverableKeyException {
		
		// Load key store to extract certificate and key
		KeyStore ks = SpecUtility.loadKeyStore(SpecUtility.DEFAULT_STORETYPE, keyStore, keyStorePass);
		samData = new Object[]{(X509Certificate)ks.getCertificate(alias), ks.getKey(alias, aliasKeyRecoveryPass)};
	}

	/**
	 * Function signs XML SOAP document. Document has been already signed in getMessage.
	 * @param docStr - XML SOAP string.
	 * @return signed document.
	 */
	public Document signDoc(String docStr) {
		
		Document signedDoc = null;
		
		try {
			// Read only signed document
			SOAPEnvelope envelope = SOAPUtility.getSOAPEnvelopeFromString(docStr);
			signedDoc = envelope.getAsDocument();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return signedDoc;
		
	}

    /**
     * Private function to verify secured SOAP message.
     * @param message - SOAP message to be verified.
     * @param printCert - option to print certificate.
     * @return boolean result.
     * @throws Exception
     */
    private boolean verifySecuredMessage(SOAPMessage message, boolean printCert) throws Exception {

        // Extract some nodes to verify document
        Document doc = message.getSOAPPart().getEnvelope().getOwnerDocument();
        return verifySecuredMessage(doc, printCert);
    }
	
	/**
	 * Private function to verify secured SOAP document directly.
	 * @param doc - SOAP document to be verified.
	 * @param printCert - option to print certificate.
	 * @return boolean result.
	 * @throws Exception
	 */
	private boolean verifySecuredMessage(Document doc, boolean printCert) throws Exception {

        final Element wssecontext = doc.createElementNS(null, "namespaceContext");
        wssecontext.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:"+"wsse".trim(), "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
        NodeList secnodeList = XPathAPI.selectNodeList(doc.getDocumentElement(), "//wsse:Security");

        Element r = null;
        Element el = null;
        if( secnodeList != null&amp;&amp;secnodeList.getLength()&gt;0 ) {
        	String actorAttr = null;
        	for( int i = 0; i&lt;secnodeList.getLength(); i++ ) {
        		el = (Element) secnodeList.item(i);
        		actorAttr = el.getAttributeNS("http://schemas.xmlsoap.org/soap/envelope/", "actor");
        		if(actorAttr != null&amp;&amp;actorAttr.equals("http://smev.gosuslugi.ru/actors/smev")) {
        			r = (Element)XPathAPI.selectSingleNode(el, "//wsse:BinarySecurityToken[1]", wssecontext); 
        			break;
        		}
        	}
        }
        if(r == null)
        	return false;
        
        final X509Security x509 = new X509Security(r);
       	if(x509 == null)
       		return false;
       	
       	// Extract certificate
       	final X509Certificate cert = (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(new ByteArrayInputStream(x509.getToken()));
       	
       	if (cert == null) {
    	    throw new Exception("Cannot find certificate to verify signature");
    	}
       	
       	// Printing of certificate if need
       	if (printCert) {
       		System.out.println(cert);
       	}
       	
       	// Get signature node
       	NodeList nl = doc.getElementsByTagNameNS("http://www.w3.org/2000/09/xmldsig#", "Signature");
    	if (nl.getLength() == 0) {
    	    throw new Exception("Cannot find Signature element");
    	}
    	
    	XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);
    	// Set public key
    	DOMValidateContext valContext = new DOMValidateContext(KeySelector.singletonKeySelector(cert.getPublicKey()), nl.item(0));
    	javax.xml.crypto.dsig.XMLSignature signature = fac.unmarshalXMLSignature(valContext);
    	
    	// Verify signature
    	return signature.validate(valContext); 
	}
	
	/**
	 * Function verifies a signature in SOAP XML document.
	 * @param signedDoc - verifiable SOAP XML document with signature.
	 * @param printCert - option to print certificate.
	 * @return object with result.
	 * @throws Exception
	 */
	public boolean verifyDoc(Document signedDoc, boolean printCert) {

		String docStr = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(signedDoc);
        ByteArrayInputStream bi = null;

        try {
            bi = new ByteArrayInputStream(docStr.getBytes("UTF8"));
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        MessageFactory messageFactory = null;
		SOAPMessage sm = null;

		boolean result = false;
		
		try {

			// Create SOAP XML message from string (signed document)
			messageFactory = MessageFactory.newInstance();
			sm = messageFactory.createMessage(null, bi);

			// Verify signature
			result = verifySecuredMessage(sm, printCert);
		} catch (SOAPException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return result;
	}
	
	/**
	 * Function creates signed secured message.
	 * @param mf - source message.
	 * @throws GeneralSecurityException
	 * @throws XMLSecurityException
	 * @throws SOAPException
	 * @throws ParserConfigurationException
	 * @throws TransformerException
	 * @throws WSSecurityException
	 * @throws FileNotFoundException
	 * @throws Exception
	 */
	private void constructSecuredMessage(SOAPMessage mf) throws Exception {
		
		if (mf == null)
			return;
		// Prepare secured header
		mf.getSOAPPart().getEnvelope().addNamespaceDeclaration("wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
		mf.getSOAPPart().getEnvelope().addNamespaceDeclaration("wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
		mf.getSOAPPart().getEnvelope().addNamespaceDeclaration("ds", "http://www.w3.org/2000/09/xmldsig#");
		mf.getSOAPBody().setAttributeNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", "wsu:Id","body");
		
		WSSecHeader header = new WSSecHeader();
		header.setActor("http://smev.gosuslugi.ru/actors/smev");
		header.setMustUnderstand(false);
		
		Element sec = header.insertSecurityHeader(mf.getSOAPPart());
		Document doc = mf.getSOAPPart().getEnvelope().getOwnerDocument();
		
		Element token =(Element) sec.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:BinarySecurityToken")); 
		token.setAttribute("EncodingType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary");
		token.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
		token.setAttribute("wsu:Id", "CertId");
		header.getSecurityHeader().appendChild(token);
		
		// Prepare signature provider
		XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);
		
		Reference ref = fac.newReference("#body", fac.newDigestMethod("http://www.w3.org/2001/04/xmldsig-more#gostr3411", null));
		// Make link to signing element
		SignedInfo si = fac.newSignedInfo( fac.newCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS, 
				 								(C14NMethodParameterSpec) null),
				 						   fac.newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411", null),
				 						   		Collections.singletonList(ref));
		
		final Object[] obj = samData.clone();
		final Transforms transforms = new Transforms(doc);
		transforms.addTransform(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS);

		// Prepare key information to verify signature in future on other side
		KeyInfoFactory kif = fac.getKeyInfoFactory();
		X509Data x509d = kif.newX509Data(Collections.singletonList((X509Certificate) obj[0]));
		KeyInfo ki = kif.newKeyInfo(Collections.singletonList(x509d));
		
		// Create signature and sign by private key
		javax.xml.crypto.dsig.XMLSignature sig = fac.newXMLSignature(si, ki);
		DOMSignContext signContext = new DOMSignContext((Key) obj[1], token);
		sig.sign(signContext);
		
		// Insert signature node in document
		Element sigE = (Element) XPathAPI.selectSingleNode(signContext.getParent(), "//ds:Signature");
		Node keyE = XPathAPI.selectSingleNode(sigE, "//ds:KeyInfo", sigE);
		token.appendChild(doc.createTextNode(XPathAPI.selectSingleNode(keyE, "//ds:X509Certificate", keyE).getFirstChild().getNodeValue()));
		keyE.removeChild(XPathAPI.selectSingleNode(keyE, "//ds:X509Data", keyE));
		NodeList chl = keyE.getChildNodes();
		
		for (int i = 0; i &lt; chl.getLength(); i++) {
			keyE.removeChild(chl.item(i));
		}
		
		Node str = keyE.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:SecurityTokenReference"));
		Element strRef = (Element)str.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Reference"));
		
		strRef.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
		strRef.setAttribute("URI", "#CertId");
		header.getSecurityHeader().appendChild(sigE);
	}

	/**
	 * Function returns SOAP message (signed).
	 */
	public String getMessage() {

		String messageStr = null;
		
		try {
			// Create simple secured message
			MessageFactory mf = MessageFactory.newInstance();
			SOAPMessage sm = mf.createMessage();
			
			// Sign it
			constructSecuredMessage(sm);
			
			// Convert signed document to string for compatibility with basic interface
			Document doc = sm.getSOAPPart().getEnvelope().getOwnerDocument();
			messageStr = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(doc);

		} catch (SOAPException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (GeneralSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (XMLSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransformerException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (WSSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return messageStr;
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/EfficiencyTestCombined.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerCombined;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

/*
 * Test provides different threads for signing and verifying of SOAP
 * XML documents as one operation synchronizing by queue.
 */
public class EfficiencyTestCombined {

	private static final int THREAD_COUNT = 5;
	private static final int WORKOUT_PERIOD = 30000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws IOException 
	 * @throws FileNotFoundException 
	 * @throws UnrecoverableKeyException 
	 */
	public static void main(String[] args) throws KeyStoreException, 
	NoSuchAlgorithmException, CertificateException, ClassNotFoundException, 
	UnrecoverableKeyException, FileNotFoundException, IOException {
		
		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES, 
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testCombined = new TestManagerCombined( "EfficiencyTestCombained", 
				THREAD_COUNT, WORKOUT_PERIOD, signatureManager);
		
		testCombined.execute();
		testCombined.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/EfficiencyTestMulti.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerMulti;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

/*
 * Test provides different threads for signing and verifying of SOAP
 * XML documents synchronizing by queue.
 */
public class EfficiencyTestMulti {
	
	private static final int PRODUCER_COUNT = 3;
	private static final int PROCESSOR_COUNT = 3;
	private static final int WORKOUT_PERIOD = 30000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws IOException 
	 * @throws FileNotFoundException 
	 * @throws UnrecoverableKeyException 
	 * @throws InterruptedException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException, UnrecoverableKeyException, 
	FileNotFoundException, IOException {
		
		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES, 
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testMulti = new TestManagerMulti( "EfficiencyTestMulti", 
				PRODUCER_COUNT, PROCESSOR_COUNT, WORKOUT_PERIOD, signatureManager);
		
		testMulti.execute();
		testMulti.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/EfficiencyTestMultiQueue.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerMultiQueue;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

/*
 * Test provides different threads for signing and verifying of SOAP
 * XML documents, where every pair of producer and processor is synchronized
 * by one queue.
 */
public class EfficiencyTestMultiQueue {

	private static final int PAIR_COUNT = 2;
	private static final int WORKOUT_PERIOD = 30000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws IOException 
	 * @throws FileNotFoundException 
	 * @throws UnrecoverableKeyException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException, UnrecoverableKeyException, 
	FileNotFoundException, IOException {

		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES, 
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testMultiQueue = new TestManagerMultiQueue( "EfficiencyTestMultiQueue", 
						PAIR_COUNT, WORKOUT_PERIOD, signatureManager);
		
		testMultiQueue.execute();
		testMultiQueue.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/EfficiencyTestSingle.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerSingle;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

/*
 * Test provides one main thread for signing and verifying of SOAP
 * XML documents as one operation (simple circle).
 */
public class EfficiencyTestSingle {

	private static final int CIRCLE_COUNT = 1000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws IOException 
	 * @throws FileNotFoundException 
	 * @throws UnrecoverableKeyException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException, UnrecoverableKeyException, 
	FileNotFoundException, IOException {

		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES, 
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testSingle = new TestManagerSingle( "EfficiencyTestSingle", 
							CIRCLE_COUNT, signatureManager);
		testSingle.execute();
		testSingle.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/ValidateCertificateChain.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SignatureException;
import java.security.cert.CRLException;
import java.security.cert.CertPathBuilderException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Properties;
import org.apache.ws.security.WSSecurityException;
import org.apache.ws.security.components.crypto.Crypto;
import org.apache.ws.security.components.crypto.CryptoFactory;
import org.apache.ws.security.components.crypto.CryptoType;
import wss4j.utility.SpecUtility;

/**
 * Class for verifying of validity of a certificate chain by two methods:
 * 	1) user function to verify a chain of certificates from any store or file (with/without CRL).
 * 	2) example of calling of the same function from class 'Merlin' (without CRL).
 */
public class ValidateCertificateChain {
	
	/**
	 * @param args
	 * @throws CertPathValidatorException 
	 * @throws CertPathBuilderException 
	 * @throws CRLException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws InvalidAlgorithmParameterException 
	 * @throws IOException 
	 * @throws KeyStoreException 
	 * @throws SignatureException 
	 * @throws NoSuchProviderException 
	 * @throws InvalidKeyException 
	 * @throws WSSecurityException 
	 */
	public static void main(String[] args) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, 
	CertificateException, CRLException, CertPathBuilderException, CertPathValidatorException, KeyStoreException, 
	IOException, InvalidKeyException, NoSuchProviderException, SignatureException, WSSecurityException {
		
		SpecUtility.initJCP();
		
		//Test #1
		//runTestRSA();
		runTestGOST();
		
		//Test #2
		/* Using Merlin
		runTestRSA_IfCAIsInCacertsAndIfUseMerlinByProperties();
		runTestGOST_IfCAIsInCacertsAndIfUseMerlinByProperties();
		*/
	}
	
	/**
	 * Function verifies RSA certificate chain with/without CRL (can be null). If certificate is 
	 * revoked, therefore it throws exception.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws CRLException
	 * @throws SignatureException 
	 * @throws NoSuchProviderException 
	 * @throws InvalidKeyException 
	 * @throws CertPathBuilderException 
	 * @throws InvalidAlgorithmParameterException 
	 * @throws WSSecurityException 
	 */
	public static void runTestRSA() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, 
	FileNotFoundException, IOException, CRLException, InvalidKeyException, NoSuchProviderException, 
	SignatureException, CertPathBuilderException, InvalidAlgorithmParameterException, WSSecurityException {
		
		System.out.println("###### 1. Test runTestRSA is begun ######");

		// Load key store to extract client certificate
		File store = null;
		if (SpecUtility.DEFAULT_KEYSTORE != null) {
			store = new File(SpecUtility.DEFAULT_KEYSTORE);
		}
		
		KeyStore clientKeyStore = SpecUtility.loadKeyStore( SpecUtility.DEFAULT_STORETYPE, 
				store, SpecUtility.DEFAULT_PASSWORD );
		X509Certificate clientCertificate = (X509Certificate)clientKeyStore.getCertificate(SpecUtility.DEFAULT_ALIAS);
		
		// Load trusted certificate from file
		FileInputStream trustedCertStream = null;
		if (SpecUtility.DEFAULT_CA_FILE != null) {
			trustedCertStream = new FileInputStream( new File(SpecUtility.DEFAULT_CA_FILE) );
		}
		else {
			throw new IOException("Default CA file is not found.");
		}
		
		CertificateFactory factory = CertificateFactory.getInstance("X509");
		X509Certificate trustedCertificate = (X509Certificate)factory.generateCertificate( trustedCertStream );
		
		// Build chain
        X509Certificate[] certificateChain = new X509Certificate[2];
        certificateChain[0] = clientCertificate;
        certificateChain[1] = trustedCertificate;
        
        X509Certificate[] trustedCertificates = new X509Certificate[1];
        trustedCertificates[0] = trustedCertificate;
        
        /**
         * First parameter can be null.  Verify certificate chain using CRL file.
         */
        File crl = null;
		if (SpecUtility.DEFAULT_CRL_FILE != null) {
			crl = new File(SpecUtility.DEFAULT_CRL_FILE);
		}
		
        boolean bResult = SpecUtility.validateCertPath( crl, certificateChain, trustedCertificates, null );
        System.out.println("Test result: " + bResult);
        
        System.out.println("###### Test runTestRSA is finished ######");
	}
	
	/**
	 * Function verifies GOST 34.10 certificate chain with/without CRL (can be null). wss40rev is 
	 * revoked, therefore it throws exception.
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws CRLException
	 * @throws SignatureException 
	 * @throws NoSuchProviderException 
	 * @throws InvalidKeyException 
	 * @throws CertPathBuilderException 
	 * @throws InvalidAlgorithmParameterException 
	 * @throws WSSecurityException 
	 */
	public static void runTestGOST() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, 
	FileNotFoundException, IOException, CRLException, InvalidKeyException, NoSuchProviderException, 
	SignatureException, CertPathBuilderException, InvalidAlgorithmParameterException, WSSecurityException {
		
		System.out.println("###### 2. Test runTestGOST is begun ######");
		
		CertificateFactory factory = CertificateFactory.getInstance("X509");
		// Load client and trusted certificates from file
		FileInputStream certStream = null;
		if (SpecUtility.DEFAULT_CERT_FILE != null) {
			certStream = new FileInputStream( new File(SpecUtility.DEFAULT_CERT_FILE) );
		}
		else {
			throw new IOException("Default certificate file is not found.");
		}
		
		FileInputStream caStream = null;
		if (SpecUtility.DEFAULT_CA_FILE != null) {
			caStream = new FileInputStream( new File(SpecUtility.DEFAULT_CA_FILE) );
		}
		else {
			throw new IOException("Default CA file is not found.");
		}
		
		X509Certificate clientCertificate = (X509Certificate)factory.generateCertificate( certStream );
		X509Certificate trustedCertificate = (X509Certificate)factory.generateCertificate( caStream );
		
		// Build chain
        X509Certificate[] certificateChain = new X509Certificate[2];
        certificateChain[0] = clientCertificate;
        certificateChain[1] = trustedCertificate;
        
        X509Certificate[] trustedCertificates = new X509Certificate[1];
        trustedCertificates[0] = trustedCertificate;

        /**
         * First parameter can be null. Verify certificate chain using CRL file.
         */
        File crl = null;
		if (SpecUtility.DEFAULT_CRL_FILE != null) {
			crl = new File(SpecUtility.DEFAULT_CRL_FILE);
		}
		
        boolean bResult = SpecUtility.validateCertPath( crl, certificateChain, 
        		trustedCertificates, null );
        System.out.println("Test result: " + bResult);
        
        System.out.println("###### Test runTestGOST is finished ######");
        
	}
	
	/**
	 * Function verifies RSA certificate chain without CRL. Merlin constructor loads key stores (user &amp; 
	 * cacerts). Root certificates are always stored in 'jre/lib/security/cacerts', therefore you should 
	 * install root certificates in cacerts. There is no default constructor for Merlin in wss4j 1.5.11, 
	 * so 'crypto.properties' is easy way to extract client certificate &amp; private key from key store. 
	 * If there are not certificates in key store, then chain won't be builded.
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws CertificateException 
	 * @throws WSSecurityException 
	 */
	public static void runTestRSA_IfCAIsInCacertsAndIfUseMerlinByProperties() throws FileNotFoundException, 
	IOException, CertificateException, WSSecurityException {
	
		System.out.println("###### 3. Test runTestRSA_IfCAIsInCacertsAndIfUseMerlinByProperties is begun ######");

		// Load properties
		Properties properties = new Properties();
		properties.load( new FileInputStream(SpecUtility.DEFAULT_CRYPTO_PROPERTIES) );
		Crypto crypto = CryptoFactory.getInstance(properties);
	
		/**
		 * Without CRL. Verify certificate chain using Merlin.
		 */
		CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);
        cryptoType.setAlias(SpecUtility.DEFAULT_ALIAS);
		boolean bResult = crypto.verifyTrust( crypto.getX509Certificates(cryptoType), false );
        System.out.println("Test result: " + bResult);
        
        System.out.println("###### Test runTestRSA_IfCAIsInCacertsAndIfUseMerlinByProperties is finished ######");
	}
	
	public static void runTestGOST_IfCAIsInCacertsAndIfUseMerlinByProperties() throws FileNotFoundException, 
	IOException, CertificateException, WSSecurityException {
	
		System.out.println("###### 4. Test runTestGOST_IfCAIsInCacertsAndIfUseMerlinByProperties is begun ######");
		
		// Load properties
		Properties properties = new Properties();
		properties.load( new FileInputStream( SpecUtility.DEFAULT_CRYPTO_PROPERTIES ) );
		Crypto crypto = CryptoFactory.getInstance(properties);
		
		/**
		 * Without CRL. Verify certificate chain using Merlin.
		 */
		CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);
        cryptoType.setAlias(SpecUtility.DEFAULT_ALIAS);
		boolean bResult = crypto.verifyTrust( crypto.getX509Certificates(cryptoType), false );
        System.out.println("Test result: " + bResult);
        
        System.out.println("###### Test runTestGOST_IfCAIsInCacertsAndIfUseMerlinByProperties is finished ######");
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/WSS4J_SignVerifySOAP.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import org.w3c.dom.Document;
import wss4j.manager.SignatureManager;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

/**
 * Class for signing &amp; verifying of SOAP XML document.
 */
public class WSS4J_SignVerifySOAP {

	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws IOException 
	 * @throws FileNotFoundException 
	 * @throws UnrecoverableKeyException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException, UnrecoverableKeyException, 
	FileNotFoundException, IOException {

		// Initialize JCP
		SpecUtility.initJCP();
		
		System.out.println("###### Test WSS4J_SignVerifySOAP 1.6.3 is begun ######");
		
		// Load key store
		SignatureManager manager = 
			new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES, 
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);
		
		// Sign XML SOAP document
        Document signedDoc = manager.signDoc(manager.getMessage());
        String outputString = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(signedDoc);
        System.out.println("Signed document: ");
        System.out.println(outputString);
		
        // Verify signature in XML SOAP document
        boolean printCert = true;
        boolean result = manager.verifyDoc(signedDoc, printCert);
        System.out.println("\nVerified: " + result);
		
		System.out.println("###### Test WSS4J_SignVerifySOAP is finished ######");
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/forum/ForumTest_gPOST_t4379.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests.forum;

import java.io.FileInputStream;
import java.net.URL;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.xml.crypto.XMLStructure;
import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.transform.stream.StreamSource;

import org.apache.ws.security.message.WSSecHeader;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import ru.CryptoPro.JCP.JCP;
import wss4j.gosuslugi.smev.SignatureTool.SignatureTool;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolService;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolServiceLocator;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType;
import wss4j.manager.SignatureManager;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3.manager.SOAPXMLSignatureManager_1_6_3;

public class ForumTest_gPOST_t4379 {

    /**
     * Файл с документом для подписи.
     */
    private final static String inSOAPFile = System.getProperty("user.dir") + "/data/unsignedRequest.xml";
    /**
     * Адрес тестового сервиса СМЭВ.
     */
    private final static String smevService = "http://188.254.16.92:7777/gateway/services/SID0003038";
    /**
     * Нужно ли проверять подпись онлайн в сервисе СМЭВ.
     */
    private final static boolean checkOnline = true;

	/**
	 * @param args
	 * @throws  
	 * @throws Exception
	 */
	public static void main(String[] args) throws Exception {

		com.sun.org.apache.xml.internal.security.Init.init();
		SpecUtility.initJCP();
		
		KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
		keyStore.load(null, null);
		
		PrivateKey privateKey = (PrivateKey)keyStore.getKey(SpecUtility.DEFAULT_ALIAS, 
				SpecUtility.DEFAULT_PASSWORD);
		X509Certificate cert = (X509Certificate) keyStore.getCertificate(SpecUtility.DEFAULT_ALIAS);
			
		MessageFactory mf = MessageFactory.newInstance();

		SOAPMessage sm = mf.createMessage();
		SOAPPart soapPart = sm.getSOAPPart();  
		   
		FileInputStream is = new FileInputStream(inSOAPFile);
		// Set contents of message  
		soapPart.setContent(new StreamSource(is)); 
		
		sm.getSOAPPart().getEnvelope().addNamespaceDeclaration("wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
		sm.getSOAPPart().getEnvelope().addNamespaceDeclaration("wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
		sm.getSOAPPart().getEnvelope().addNamespaceDeclaration("ds", "http://www.w3.org/2000/09/xmldsig#");
		sm.getSOAPBody().setAttributeNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", "wsu:Id", "body");
		
	    WSSecHeader header = new WSSecHeader();
	    header.setActor("http://smev.gosuslugi.ru/actors/smev");
	    header.setMustUnderstand(false);

	    Element sec = header.insertSecurityHeader(sm.getSOAPPart());
	    Document doc = sm.getSOAPPart().getEnvelope().getOwnerDocument();

	    Element token = (Element) sec.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:BinarySecurityToken"));
	    token.setAttribute("EncodingType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary");
	    token.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
	    token.setAttribute("wsu:Id", "CertId");
		
		Provider xmlDSigProvider = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();

	    XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);

	    List&lt;Transform&gt; transformList = new ArrayList&lt;Transform&gt;();
	    Transform transform = fac.newTransform(Transform.ENVELOPED, (XMLStructure) null);
	    Transform transformC14N = fac.newTransform(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS, (XMLStructure) null);
	    transformList.add(transform);
	    transformList.add(transformC14N);

	    Reference ref = fac.newReference("#body", fac.newDigestMethod("http://www.w3.org/2001/04/xmldsig-more#gostr3411", null),
	    		transformList, null, null);

	    // Make link to signing element
	    SignedInfo si = fac.newSignedInfo(fac.newCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE,
	        (C14NMethodParameterSpec) null),
	        fac.newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411", null),
	        Collections.singletonList(ref));

	    // Prepare key information to verify signature in future on other side
	    KeyInfoFactory kif = fac.getKeyInfoFactory();
	    X509Data x509d = kif.newX509Data(Collections.singletonList(cert));
	    KeyInfo ki = kif.newKeyInfo(Collections.singletonList(x509d));

	    // Create signature and sign by private key
	    javax.xml.crypto.dsig.XMLSignature sig = fac.newXMLSignature(si, ki);

	    Element l = doc.getElementById("body");
	    DOMSignContext signContext = new DOMSignContext(privateKey, token);
	    signContext.putNamespacePrefix(javax.xml.crypto.dsig.XMLSignature.XMLNS, "ds");
	    sig.sign(signContext);
	    
	    // Insert signature node in document
	    Element sigE = (Element) XPathAPI.selectSingleNode(signContext.getParent(), "//ds:Signature");
	    
	    Node keyE = XPathAPI.selectSingleNode(sigE, "//ds:KeyInfo", sigE);
	    token.appendChild(doc.createTextNode(XPathAPI.selectSingleNode(keyE, "//ds:X509Certificate", keyE).getFirstChild().getNodeValue()));
	    keyE.removeChild(XPathAPI.selectSingleNode(keyE, "//ds:X509Data", keyE));
	    NodeList chl = keyE.getChildNodes();

	    for (int i = 0; i &lt; chl.getLength(); i++) {
	      keyE.removeChild(chl.item(i));
	    }

	    Node str = keyE.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:SecurityTokenReference"));
	    Element strRef = (Element) str.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Reference"));

	    strRef.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
	    strRef.setAttribute("URI", "#CertId");
	    header.getSecurityHeader().appendChild(sigE);
	    
	    String mes = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(doc);
	    System.out.println(mes);

        if (checkOnline) {

	        SignatureManager signatureManager =
				new SOAPXMLSignatureManager_1_6_3(SpecUtility.DEFAULT_CRYPTO_PROPERTIES, 
					SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD, SpecUtility.DEFAULT_PASSWORD);

            System.out.println( "Проверка ЭЦП: " + signatureManager.verifyDoc(doc, true) );
	    
	        SignatureToolService sts = new SignatureToolServiceLocator();
		    SignatureTool st = sts.getSignatureToolPort(new URL(smevService));

            VerifySignatureRequestType vsrt = new VerifySignatureRequestType(mes, false,
			    "http://smev.gosuslugi.ru/actors/smev");
		    VerifySignatureResponseType result = st.verifySignature(vsrt);

            System.out.println("Проверка ЭЦП в сервисе СМЭВ: код ошибки = " +
                result.getError().getErrorCode() + ", описание = " + result.getError().getErrorMessage());
        }
	}

}
</java>
<java name="wss4j/wss4j1_6_3/tests/forum/SMEVExample.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests.forum;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.net.URL;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.xml.crypto.KeySelector;
import javax.xml.crypto.XMLStructure;
import javax.xml.crypto.dsig.CanonicalizationMethod;
import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.Transform;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.transform.stream.StreamSource;

import org.apache.ws.security.message.WSSecHeader;
import org.apache.ws.security.message.token.X509Security;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.tools.Array;
import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;
import wss4j.gosuslugi.smev.SignatureTool.SignatureTool;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolService;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolServiceLocator;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType;
import wss4j.utility.SpecUtility;

public class SMEVExample {

    /**
     * Папка с исходным документом.
     */
    private static final String IN_DIR = System.getProperty("user.dir") + "/data";
    /**
     * Папка с подписанным документом.
     */
    private static final String OUT_DIR = System.getProperty("user.dir") + "/temp";
    /**
     * Документ для подписи.
     */
    private final static String inSOAPFile = IN_DIR + "/soap_net.xml";
    /**
     * Подписанный документ.
     */
    private final static String outSOAPFile = OUT_DIR + "/soap_net.signed.xml";
    /**
     * Адрес тестового сервиса СМЭВ.
     */
    private final static String smevService = "http://188.254.16.92:7777/gateway/services/SID0003038";
    /**
     * Нужно ли проверять подпись онлайн в сервисе СМЭВ.
     */
    private final static boolean checkOnline = true;

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception {

        /*** Инициализация ***/

		// Инициализация Transforms алгоритмов.
		com.sun.org.apache.xml.internal.security.Init.init();
		
		// Инициализация JCP XML провайдера.
		if(!JCPXMLDSigInit.isInitialized()) {
    		JCPXMLDSigInit.init();
		}

        // Инициализация ключевого контейнера.
        KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
        keyStore.load(null, null);

        // Получение ключа и сертификата.
        PrivateKey privateKey = (PrivateKey)keyStore.getKey(SpecUtility.DEFAULT_ALIAS,
                SpecUtility.DEFAULT_PASSWORD);
        X509Certificate cert = (X509Certificate) keyStore.getCertificate(SpecUtility.DEFAULT_ALIAS);

        /*** Подготовка документа ***/

        MessageFactory mf = MessageFactory.newInstance();

        SOAPMessage message = mf.createMessage();
        SOAPPart soapPart = message.getSOAPPart();

        // Читаем сообщение из файла.
        FileInputStream is = new FileInputStream(inSOAPFile);
        soapPart.setContent(new StreamSource(is));

        message.getSOAPPart().getEnvelope().addNamespaceDeclaration("ds", "http://www.w3.org/2000/09/xmldsig#");

        // Формируем заголовок.
        WSSecHeader header = new WSSecHeader();
        header.setActor("http://smev.gosuslugi.ru/actors/smev");
        header.setMustUnderstand(false);

        // Получаем документ.
        Document doc = message.getSOAPPart().getEnvelope().getOwnerDocument();
        header.insertSecurityHeader(message.getSOAPPart().getEnvelope().getOwnerDocument());

        // Подписываемый элемент.
        Element token = header.getSecurityHeader();

        /*** Подпись данных ***/

        // Загрузка провайдера.
        Provider xmlDSigProvider = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();

        // Преобразования над документом.
        final Transforms transforms = new Transforms(doc);
        transforms.addTransform(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS);

        XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);

        // Преобразования над блоком SignedInfo
        List&lt;Transform&gt; transformList = new ArrayList&lt;Transform&gt;();
        Transform transformC14N =
                fac.newTransform(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS, (XMLStructure) null);
        transformList.add(transformC14N);

        // Ссылка на подписываемые данные.
        Reference ref = fac.newReference("#body",
            fac.newDigestMethod("http://www.w3.org/2001/04/xmldsig-more#gostr3411", null),
            transformList, null, null);

        // Блок SignedInfo.
        SignedInfo si = fac.newSignedInfo( fac.newCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE,
            (C14NMethodParameterSpec) null),
            fac.newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411", null),
            Collections.singletonList(ref));

        // Блок KeyInfo.
        KeyInfoFactory kif = fac.getKeyInfoFactory();
        X509Data x509d = kif.newX509Data(Collections.singletonList(cert));
        KeyInfo ki = kif.newKeyInfo(Collections.singletonList(x509d));

        // Подпись данных.
        javax.xml.crypto.dsig.XMLSignature sig = fac.newXMLSignature(si, ki);
        DOMSignContext signContext = new DOMSignContext(privateKey, token);
        sig.sign(signContext);

        // Блок подписи Signature.
        Element sigE = (Element) XPathAPI.selectSingleNode(signContext.getParent(), "//ds:Signature");
        // Блок данных KeyInfo.
        Node keyE = XPathAPI.selectSingleNode(sigE, "//ds:KeyInfo", sigE);

        // Элемент SenderCertificate, который должен содержать сертификат.
        Element cerVal = (Element) XPathAPI.selectSingleNode(token, "//*[@wsu:Id='SenderCertificate']");
        cerVal.setTextContent(XPathAPI.selectSingleNode(keyE, "//ds:X509Certificate", keyE).getFirstChild().getNodeValue());

        // Удаляем элементы KeyInfo, попавшие в тело документа. Они должны быть только в header.
        keyE.removeChild(XPathAPI.selectSingleNode(keyE, "//ds:X509Data", keyE));

        NodeList chl = keyE.getChildNodes();

        for (int i = 0; i &lt; chl.getLength(); i++) {
            keyE.removeChild(chl.item(i));
        }

        // Блок KeyInfo содержит указание на проверку подписи с помощью сертификата SenderCertificate.
        Node str = keyE.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd",
                "wsse:SecurityTokenReference"));
        Element strRef = (Element)str.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd",
                "wsse:Reference"));

        strRef.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
        strRef.setAttribute("URI", "#SenderCertificate");
        header.getSecurityHeader().appendChild(sigE);

        // Получение документа в виде строки и сохранение в файл.
        String msg = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(doc);

        if (outSOAPFile != null) {
            Array.writeFile(outSOAPFile, msg.getBytes("utf-8"));
        }

        /*** а) Проверка подписи (локально) ***/

        // Получение блока, содержащего сертификат.
        final Element wssecontext = doc.createElementNS(null, "namespaceContext");
        wssecontext.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:wsse",
                "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
        NodeList secnodeList = XPathAPI.selectNodeList(doc.getDocumentElement(), "//wsse:Security");

        // Поиск элемента сертификата.
        Element binarySecurityToken = null;
        if(secnodeList != null &amp;&amp; secnodeList.getLength() &gt; 0) {

            for( int i = 0; i&lt;secnodeList.getLength(); i++ ) {

                Element el = (Element) secnodeList.item(i);
                String actorAttr = el.getAttributeNS("http://schemas.xmlsoap.org/soap/envelope/", "actor");

                if(actorAttr != null &amp;&amp; actorAttr.equals("http://smev.gosuslugi.ru/actors/smev")) {
                    binarySecurityToken = (Element)XPathAPI.selectSingleNode(el, "//wsse:BinarySecurityToken[1]", wssecontext);
                    break;
                }
            }
        }

        if (binarySecurityToken == null) {
            throw new Exception("Не найден элемент BinarySecurityToken.");
        }

        // Получение сертификата.
        final X509Security x509 = new X509Security(binarySecurityToken);

        cert = (X509Certificate) CertificateFactory.getInstance("X.509")
                .generateCertificate(new ByteArrayInputStream(x509.getToken()));

        if (cert == null) {
            throw new Exception("Не найден сертификат.");
        }

        System.out.println("Проверяем с помощью сертификата #" + cert.getSerialNumber().toString(16) +
            " " + cert.getSubjectDN());

        // Поиск элемента с подписью.
        NodeList nl = doc.getElementsByTagNameNS("http://www.w3.org/2000/09/xmldsig#", "Signature");
        if (nl.getLength() == 0) {
            throw new Exception("Не найден элемент Signature.");
        }

        // Задаем открытый ключ для проверки подписи.
        fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);
        DOMValidateContext valContext =
            new DOMValidateContext(KeySelector.singletonKeySelector(cert.getPublicKey()), nl.item(0));
        javax.xml.crypto.dsig.XMLSignature signature = fac.unmarshalXMLSignature(valContext);

        // Проверяем подпись.
        System.out.println( "Проверка ЭЦП: " + signature.validate(valContext));

        /*** б) Проверка подписи (СМЭВ) ***/

        if (checkOnline) {

            // Используем веб-клиент СМЭВ.
            SignatureToolService sts = new SignatureToolServiceLocator();

            // Задаем адрес тестового сервиса.
            SignatureTool st = sts.getSignatureToolPort(new URL(smevService));

            // Передаем документ, при этом зарещаем проверять сертификат.
            VerifySignatureRequestType vsrType = new VerifySignatureRequestType(msg, false,
                "http://smev.gosuslugi.ru/actors/smev");
            VerifySignatureResponseType result = st.verifySignature(vsrType);

            // Результат проверки подписи сервисом СМЭВ.
            System.out.println("Проверка ЭЦП в сервисе СМЭВ: код ошибки = " +
                result.getError().getErrorCode() + ", описание = " + result.getError().getErrorMessage());
        }
	}
}
</java>
<java name="wss4j/wss4j1_6_3/tests/forum/SMEVExampleDouble.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.tests.forum;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.net.URL;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.xml.crypto.KeySelector;
import javax.xml.crypto.XMLStructure;
import javax.xml.crypto.dsig.CanonicalizationMethod;
import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.Transform;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.transform.stream.StreamSource;

import org.apache.ws.security.message.WSSecHeader;
import org.apache.ws.security.message.token.X509Security;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import ru.CryptoPro.JCP.JCP;
import ru.CryptoPro.JCP.tools.Array;
import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;
import wss4j.gosuslugi.smev.SignatureTool.SignatureTool;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolService;
import wss4j.gosuslugi.smev.SignatureTool.SignatureToolServiceLocator;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureRequestType;
import wss4j.gosuslugi.smev.SignatureTool.xsd.VerifySignatureResponseType;
import wss4j.utility.SpecUtility;

public class SMEVExampleDouble {

    /**
     * Папка с исходным документом.
     */
    private static final String IN_DIR = System.getProperty("user.dir") + "/data";
    /**
     * Папка с подписанным документом.
     */
    private static final String OUT_DIR = System.getProperty("user.dir") + "/temp";
    /**
     * Документ для подписи.
     */
    private final static String inSOAPFile = IN_DIR + "/soap_net.xml";
    /**
     * Подписанный документ.
     */
    private final static String outSOAPFile = OUT_DIR + "/soap_net.signed.xml";
    /**
     * Адрес тестового сервиса СМЭВ.
     */
    private final static String smevService = "http://188.254.16.92:7777/gateway/services/SID0003038";
    /**
     * Нужно ли проверять подпись онлайн в сервисе СМЭВ.
     */
    private final static boolean checkOnline = true;

    /**
     * Выполнение подписи документа, а затем проверки двумя способами: с помощью функций проверки
     * и в сервисе СМЭВ. Подписанный документ сохранится в файл.
     *
     * @param privateKey Закрытый ключ для подписи.
     * @param cert Серификат для проверки подписи.
     * @param digAlgo Имя алгоритма хеширования.
     * @param sigAlgo Имя алгоритма подписи.
     * @param message Подписываемый документ.
     * @param outFile Имя файла для сохранения в него подписанного сообщения.
     * @throws Exception
     */
    public static void runTest(PrivateKey privateKey, X509Certificate cert,
        String digAlgo, String sigAlgo, SOAPMessage message, String outFile) throws Exception {

        // Формируем заголовок.
        WSSecHeader header = new WSSecHeader();
        header.setActor("http://smev.gosuslugi.ru/actors/smev");
        header.setMustUnderstand(false);

        // Получаем документ.
        Document doc = message.getSOAPPart().getEnvelope().getOwnerDocument();
        header.insertSecurityHeader(message.getSOAPPart().getEnvelope().getOwnerDocument());

        // Подписываемый элемент.
        Element token = header.getSecurityHeader();

        /*** Подпись данных ***/

        // Загрузка провайдера.
        Provider xmlDSigProvider = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();

        // Преобразования над документом.
        final Transforms transforms = new Transforms(doc);
        transforms.addTransform(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS);

        XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);

        // Преобразования над блоком SignedInfo
        List&lt;Transform&gt; transformList = new ArrayList&lt;Transform&gt;();
        Transform transformC14N =
            fac.newTransform(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS, (XMLStructure) null);
        transformList.add(transformC14N);

        // Ссылка на подписываемые данные.
        Reference ref = fac.newReference("#body",
            fac.newDigestMethod(digAlgo, null), transformList, null, null);

        // Блок SignedInfo.
        SignedInfo si = fac.newSignedInfo( fac.newCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE,
            (C14NMethodParameterSpec) null), fac.newSignatureMethod(sigAlgo, null),
            Collections.singletonList(ref));

        // Блок KeyInfo.
        KeyInfoFactory kif = fac.getKeyInfoFactory();
        X509Data x509d = kif.newX509Data(Collections.singletonList(cert));
        KeyInfo ki = kif.newKeyInfo(Collections.singletonList(x509d));

        // Подпись данных.
        javax.xml.crypto.dsig.XMLSignature sig = fac.newXMLSignature(si, ki);
        DOMSignContext signContext = new DOMSignContext(privateKey, token);
        sig.sign(signContext);

        // Блок подписи Signature.
        Element sigE = (Element) XPathAPI.selectSingleNode(signContext.getParent(), "//ds:Signature");
        // Блок данных KeyInfo.
        Node keyE = XPathAPI.selectSingleNode(sigE, "//ds:KeyInfo", sigE);

        // Элемент SenderCertificate, который должен содержать сертификат.
        Element cerVal = (Element) XPathAPI.selectSingleNode(token, "//*[@wsu:Id='SenderCertificate']");
        cerVal.setTextContent(XPathAPI.selectSingleNode(keyE, "//ds:X509Certificate", keyE).getFirstChild().getNodeValue());

        // Удаляем элементы KeyInfo, попавшие в тело документа. Они должны быть только в header.
        keyE.removeChild(XPathAPI.selectSingleNode(keyE, "//ds:X509Data", keyE));

        NodeList chl = keyE.getChildNodes();

        for (int i = 0; i &lt; chl.getLength(); i++) {
            keyE.removeChild(chl.item(i));
        }

        // Блок KeyInfo содержит указание на проверку подписи с помощью сертификата SenderCertificate.
        Node str = keyE.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd",
            "wsse:SecurityTokenReference"));
        Element strRef = (Element)str.appendChild(doc.createElementNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd",
            "wsse:Reference"));

        strRef.setAttribute("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3");
        strRef.setAttribute("URI", "#SenderCertificate");
        header.getSecurityHeader().appendChild(sigE);

        // Получение документа в виде строки и сохранение в файл.
        String msg = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(doc);

        if (outFile != null) {
            Array.writeFile(outFile, msg.getBytes("utf-8"));
        }

        /*** а) Проверка подписи (локально) ***/

        // Получение блока, содержащего сертификат.
        final Element wssecontext = doc.createElementNS(null, "namespaceContext");
        wssecontext.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:wsse",
            "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
        NodeList secnodeList = XPathAPI.selectNodeList(doc.getDocumentElement(), "//wsse:Security");

        // Поиск элемента сертификата.
        Element binarySecurityToken = null;
        if(secnodeList != null &amp;&amp; secnodeList.getLength() &gt; 0) {

            for( int i = 0; i&lt;secnodeList.getLength(); i++ ) {

                Element el = (Element) secnodeList.item(i);
                String actorAttr = el.getAttributeNS("http://schemas.xmlsoap.org/soap/envelope/", "actor");

                if(actorAttr != null &amp;&amp; actorAttr.equals("http://smev.gosuslugi.ru/actors/smev")) {
                    binarySecurityToken = (Element)XPathAPI.selectSingleNode(el, "//wsse:BinarySecurityToken[1]", wssecontext);
                    break;
                }
            }
        }

        if(binarySecurityToken == null) {
            throw new Exception("Не найден элемент BinarySecurityToken");
        }

        // Получение сертификата.
        final X509Security x509 = new X509Security(binarySecurityToken);

        cert = (X509Certificate) CertificateFactory.getInstance("X.509")
                .generateCertificate(new ByteArrayInputStream(x509.getToken()));

        if (cert == null) {
            throw new Exception("Не найден сертификат.");
        }

        System.out.println("Проверяем с помощью сертификата #" + cert.getSerialNumber().toString(16) +
            " " + cert.getSubjectDN());

        // Поиск элемента с подписью.
        NodeList nl = doc.getElementsByTagNameNS("http://www.w3.org/2000/09/xmldsig#", "Signature");
        if (nl.getLength() == 0) {
            throw new Exception("Не найден элемент Signature.");
        }

        // Задаем открытый ключ для проверки подписи.
        fac = XMLSignatureFactory.getInstance("DOM", xmlDSigProvider);
        DOMValidateContext valContext = new DOMValidateContext(KeySelector.singletonKeySelector(cert.getPublicKey()), nl.item(0));
        javax.xml.crypto.dsig.XMLSignature signature = fac.unmarshalXMLSignature(valContext);

        // Проверяем подпись.
        System.out.println( "Проверка ЭЦП: " + signature.validate(valContext));

        /*** б) Проверка подписи (СМЭВ) ***/

        if (checkOnline) {

            // Используем веб-клиент СМЭВ.
            SignatureToolService sts = new SignatureToolServiceLocator();

            // Задаем адрес тестового сервиса.
            SignatureTool st = sts.getSignatureToolPort(new URL(smevService));

            // Передаем документ, при этом зарещаем проверять сертификат.
            VerifySignatureRequestType vsrType = new VerifySignatureRequestType(msg, false, "http://smev.gosuslugi.ru/actors/smev");
            VerifySignatureResponseType result = st.verifySignature(vsrType);

            // Результат проверки подписи сервисом СМЭВ.
            System.out.println("Проверка ЭЦП в сервисе СМЭВ: код ошибки = " +
                result.getError().getErrorCode() + ", описание = " + result.getError().getErrorMessage());
        }

    }

    /**
     * Загрузка и подготовка документа к подписи.
     *
     * @param inFile Файл с документом для подписи.
     * @return готовый для подписи документ.
     * @throws Exception
     */
    public static SOAPMessage getMessage(String inFile) throws Exception {

        /*** Подготовка документа ***/

        MessageFactory mf = MessageFactory.newInstance();

        SOAPMessage message = mf.createMessage();
        SOAPPart soapPart = message.getSOAPPart();

        // Читаем сообщение из файла.
        FileInputStream is = new FileInputStream(inFile);
        soapPart.setContent(new StreamSource(is));

        message.getSOAPPart().getEnvelope().addNamespaceDeclaration("ds", "http://www.w3.org/2000/09/xmldsig#");

        return message;
    }

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception {

        /*** Инициализация ***/

		// Инициализация Transforms алгоритмов.
		com.sun.org.apache.xml.internal.security.Init.init();
		
		// Инициализация JCP XML провайдера.
		if(!JCPXMLDSigInit.isInitialized()) {
    		JCPXMLDSigInit.init();
		}

        // Инициализация ключевого контейнера.
        KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
        keyStore.load(null, null);

        // Получение ключа и сертификата.
        PrivateKey privateKey = (PrivateKey)keyStore.getKey(SpecUtility.DEFAULT_ALIAS,
                SpecUtility.DEFAULT_PASSWORD);
        X509Certificate cert = (X509Certificate) keyStore.getCertificate(SpecUtility.DEFAULT_ALIAS);

        /*** Запуск тестов с именами алгоритмов по разным стандартам ***/

        // По старому стандарту.
        runTest(privateKey, cert, "http://www.w3.org/2001/04/xmldsig-more#gostr3411",
            "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411", getMessage(inSOAPFile),
            outSOAPFile + ".uri");

        // По новому стандарту.
        runTest(privateKey, cert, "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr3411",
            "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34102001-gostr3411", getMessage(inSOAPFile),
            outSOAPFile + "..urn");
	}

}
</java>
<java name="wss4j/wss4j1_6_3/ws/security/components/crypto/MerlinEx.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

package wss4j.wss4j1_6_3.ws.security.components.crypto;

import java.io.IOException;
import java.security.PrivateKey;
import java.util.Properties;

import org.apache.ws.security.WSSecurityException;
import org.apache.ws.security.components.crypto.CredentialException;
import org.apache.ws.security.components.crypto.Merlin;

/*
 * This class extends default class Merlin to cache a private key and to avoid permanent
 * reading of key from store.
 */
public class MerlinEx extends Merlin {

    private PrivateKey cachedPrivateKey = null;
    private String cachedAlias = null;
	
	public MerlinEx(Properties properties) throws CredentialException,
			IOException {
		super(properties);
	}
	
	public MerlinEx(Properties properties, ClassLoader loader) throws CredentialException, 
			IOException {
		super(properties, loader);
	}
	
    public PrivateKey getPrivateKey(String alias, String password) {
    	
    	if (cachedPrivateKey == null || 
    			(cachedAlias != null &amp;&amp; !cachedAlias.equalsIgnoreCase(alias))) {
    		cachedAlias = alias;
    		try {
				cachedPrivateKey = super.getPrivateKey(alias, password);
			} catch (WSSecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
    	
    	return cachedPrivateKey;
    }
}
</java>
<java name="wss4j/wss4j1_6_3_basic/manager/SOAPXMLSignatureManager_1_6_3_Basic.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

/*
 * Class provides generating and verifying of signature.
 */

package wss4j.wss4j1_6_3_basic.manager;

import org.apache.axis.message.SOAPEnvelope;
import org.apache.ws.security.WSConstants;
import org.apache.ws.security.WSSecurityEngine;
import org.apache.ws.security.WSSecurityEngineResult;
import org.apache.ws.security.WSSecurityException;
import org.apache.ws.security.components.crypto.Crypto;
import org.apache.ws.security.components.crypto.Merlin;
import org.apache.ws.security.message.WSSecHeader;
import org.apache.ws.security.message.WSSecSignature;
import org.apache.ws.security.util.WSSecurityUtil;
import org.w3c.dom.Document;
import ru.CryptoPro.JCP.JCP;
import wss4j.manager.SignatureManager;
import wss4j.utility.SOAPUtility;
import wss4j.utility.SpecUtility;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.*;
import java.security.cert.CertificateException;
import java.util.List;
import java.util.Properties;

public class SOAPXMLSignatureManager_1_6_3_Basic extends SignatureManager {
	
	private WSSecurityEngine secEngine = new WSSecurityEngine();
	private Crypto crypto = null;
	private String alias;
	private char[] keyPassword = null;
	private Properties props = new Properties();

    static {

        // Initialize JCP
        com.sun.org.apache.xml.internal.security.Init.init();
        SpecUtility.initJCP();

        // Load CryptoPro XMLDSig service provider
        Provider provCryptoProRI = new ru.CryptoPro.JCPxml.dsig.internal.dom.XMLDSigRI();
        Security.addProvider(provCryptoProRI);

        // Override methods
        Security.getProvider("XMLDSig").put("XMLSignatureFactory.DOM",
                "ru.CryptoPro.JCPxml.dsig.internal.dom.DOMXMLSignatureFactory");
        Security.getProvider("XMLDSig").put("KeyInfoFactory.DOM",
                "ru.CryptoPro.JCPxml.dsig.internal.dom.DOMKeyInfoFactory");
    }

	public SOAPXMLSignatureManager_1_6_3_Basic(String propertyFile, String alias, char[] password)
	throws ClassNotFoundException, KeyStoreException, NoSuchAlgorithmException, CertificateException {

        props.clear();
		this.alias = alias;
		this.keyPassword = password;
		
		try {

			// Load properties (store type, key alias etc)
			props.load(new FileInputStream(propertyFile));

			// Create object (Merlin) to sign and verify SOAP XML messages. It uses crypto.properties and
			// key store must to contain certificate and key
			/* For wss4j 1.5 only. wss4j 1.6 wants keystore.
            crypto = CryptoFactory.getInstance(props);
            */

            KeyStore keyStore = KeyStore.getInstance(JCP.HD_STORE_NAME);
            keyStore.load(null, null);

            Merlin merlin = new Merlin();
            merlin.setKeyStore(keyStore);

            crypto = merlin;

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }

	/**
	 * Function signs XML SOAP document.
	 * @param docStr - XML SOAP string.
	 * @return signed document.
	 */
	public Document signDoc(String docStr) {
		
		Document signedDoc = null;
		
		try {
			SOAPEnvelope unsignedEnvelope = SOAPUtility.getSOAPEnvelopeFromString(docStr);
			// Prepare object to sign secured message
			WSSecSignature sign = new WSSecSignature();
			
			// Set properties: alias, password, algorithm etc.
			String pswrd = null;
			if (keyPassword != null) {
				pswrd = new String(keyPassword);
			}
	        sign.setUserInfo(alias, pswrd);
	        
	        sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
	        sign.setSignatureAlgorithm(ru.CryptoPro.JCPxml.Consts.URI_GOST_SIGN);
	        sign.setDigestAlgo(ru.CryptoPro.JCPxml.Consts.URI_GOST_DIGEST);
	        
	        Document sourceDoc = unsignedEnvelope.getAsDocument();
	        WSSecHeader secHeader = new WSSecHeader();
	        secHeader.insertSecurityHeader(sourceDoc);
	        // Sign document
	        signedDoc = sign.build(sourceDoc, crypto, secHeader);
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return signedDoc;
		
	}
	
	/**
	 * Function verifies a signature in SOAP XML document.
	 * @param signedDoc - verifiable SOAP XML document with signature.
	 * @param printCert - option to print certificate.
	 * @return object with result.
	 * @throws Exception
	 */
	public boolean verifyDoc(Document signedDoc, boolean printCert) {
		
		boolean result = false;
		
		if (signedDoc == null)
			return false;
		
		try {
			// Verify signature
			List&lt;WSSecurityEngineResult&gt; results = secEngine.processSecurityHeader(signedDoc, null, null, crypto);
			// Ensure actionResult != null
			WSSecurityEngineResult actionResult = WSSecurityUtil.fetchActionResult(results, WSConstants.SIGN);
			result = (actionResult != null);
			
			// Print signer cerificate
			if (printCert) {
				System.out.println(actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE));
			}
			
		} catch (WSSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return result;
	}

	/**
	 * Function returns SOAP message.
	 */
	public String getMessage() {
		return SOAPUtility.SOAPMSG;
	}
}
</java>
<java name="wss4j/wss4j1_6_3_basic/tests/EfficiencyTestCombined.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

/*
 * Test provides different threads for signing and verifying of SOAP 
 * XML documents as one operation synchronizing by queue.
 */

package wss4j.wss4j1_6_3_basic.tests;

import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerCombined;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3_basic.manager.SOAPXMLSignatureManager_1_6_3_Basic;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

public class EfficiencyTestCombined {

	private static final int THREAD_COUNT = 3;
	private static final int WORKOUT_PERIOD = 30000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 */
	public static void main(String[] args) throws KeyStoreException, 
	NoSuchAlgorithmException, CertificateException, ClassNotFoundException {
		
		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3_Basic(SpecUtility.DEFAULT_CRYPTO_PROPERTIES,
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testCombined = new TestManagerCombined( "EfficiencyTestCombained", 
				THREAD_COUNT, WORKOUT_PERIOD, signatureManager);
		
		testCombined.execute();
		testCombined.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3_basic/tests/EfficiencyTestMulti.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

/*
 * Test provides different threads for signing and verifying of SOAP 
 * XML documents synchronizing by queue.
 */

package wss4j.wss4j1_6_3_basic.tests;

import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerMulti;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3_basic.manager.SOAPXMLSignatureManager_1_6_3_Basic;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

public class EfficiencyTestMulti {
	
	private static final int PRODUCER_COUNT = 2;
	private static final int PROCESSOR_COUNT = 2;
	private static final int WORKOUT_PERIOD = 30000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws InterruptedException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException {
		
		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3_Basic(SpecUtility.DEFAULT_CRYPTO_PROPERTIES,
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testMulti = new TestManagerMulti( "EfficiencyTestMulti", 
				PRODUCER_COUNT, PROCESSOR_COUNT, WORKOUT_PERIOD, signatureManager);
		
		testMulti.execute();
		testMulti.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3_basic/tests/EfficiencyTestMultiQueue.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

/*
 * Test provides different threads for signing and verifying of SOAP 
 * XML documents, where every pair of producer and processor is synchronized 
 * by one queue.
 */

package wss4j.wss4j1_6_3_basic.tests;

import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerMultiQueue;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3_basic.manager.SOAPXMLSignatureManager_1_6_3_Basic;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

public class EfficiencyTestMultiQueue {

	private static final int PAIR_COUNT = 2;
	private static final int WORKOUT_PERIOD = 30000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException {

		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3_Basic(SpecUtility.DEFAULT_CRYPTO_PROPERTIES,
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testMultiQueue = new TestManagerMultiQueue( "EfficiencyTestMultiQueue", 
						PAIR_COUNT, WORKOUT_PERIOD, signatureManager);
		
		testMultiQueue.execute();
		testMultiQueue.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3_basic/tests/EfficiencyTestSingle.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

/*
 * Test provides one main thread for signing and verifying of SOAP 
 * XML documents as one operation (simple circle).
 */

package wss4j.wss4j1_6_3_basic.tests;

import wss4j.manager.SignatureManager;
import wss4j.manager.TestManager;
import wss4j.manager.TestManagerSingle;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3_basic.manager.SOAPXMLSignatureManager_1_6_3_Basic;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

public class EfficiencyTestSingle {

	private static final int CIRCLE_COUNT = 1000;
	
	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException {

		SignatureManager signatureManager = 
			new SOAPXMLSignatureManager_1_6_3_Basic(SpecUtility.DEFAULT_CRYPTO_PROPERTIES,
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD);
		
		TestManager testSingle = new TestManagerSingle( "EfficiencyTestSingle", 
							CIRCLE_COUNT, signatureManager);
		testSingle.execute();
		testSingle.report();
	}
}
</java>
<java name="wss4j/wss4j1_6_3_basic/tests/WSS4J_SignVerifySOAP.java">/**
 * Copyright 2004-2012 Crypto-Pro. All rights reserved.
 * Этот файл содержит информацию, являющуюся
 * собственностью компании Крипто-Про.
 *
 * Любая часть этого файла не может быть скопирована,
 * исправлена, переведена на другие языки,
 * локализована или модифицирована любым способом,
 * откомпилирована, передана по сети с или на
 * любую компьютерную систему без предварительного
 * заключения соглашения с компанией Крипто-Про.
 */

/**
 * Class for signing &amp; verifying of SOAP XML document.
 */

package wss4j.wss4j1_6_3_basic.tests;

import org.w3c.dom.Document;
import wss4j.manager.SignatureManager;
import wss4j.utility.SpecUtility;
import wss4j.wss4j1_6_3_basic.manager.SOAPXMLSignatureManager_1_6_3_Basic;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

public class WSS4J_SignVerifySOAP {

	/**
	 * @param args
	 * @throws ClassNotFoundException 
	 * @throws CertificateException 
	 * @throws NoSuchAlgorithmException 
	 * @throws KeyStoreException 
	 * @throws Exception 
	 */
	public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, 
	CertificateException, ClassNotFoundException {

		// Initialize JCP
		SpecUtility.initJCP();
		
		System.out.println("###### Test WSS4J_SignVerifySOAP 1.6.3 is begun ######");
		
		// Load key store
		SignatureManager manager = 
			new SOAPXMLSignatureManager_1_6_3_Basic(SpecUtility.DEFAULT_CRYPTO_PROPERTIES,
				SpecUtility.DEFAULT_ALIAS, SpecUtility.DEFAULT_PASSWORD);
		
		// Sign XML SOAP document
		Document signedDoc = manager.signDoc(manager.getMessage());
        String outputString = org.apache.ws.security.util.XMLUtils.PrettyDocumentToString(signedDoc);
        System.out.println("Signed document: ");
        System.out.println(outputString);
		
        // Verify signature in XML SOAP document
        boolean printCert = true;
        boolean result = manager.verifyDoc(signedDoc, printCert);
        System.out.println("\nVerified: " + result);
		
		System.out.println("###### Test WSS4J_SignVerifySOAP is finished ######");
	}
}
</java>
<java name="xmlSign/CryptXML.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 13.07.2009 16:38:35 by Iva
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2009.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package xmlSign;

import org.apache.xml.security.encryption.EncryptedData;
import org.apache.xml.security.encryption.EncryptedKey;
import org.apache.xml.security.encryption.XMLCipher;
import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.keys.content.X509Data;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.EncryptionConstants;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import ru.CryptoPro.JCP.Key.KeyTwix;
import ru.CryptoPro.JCPRequest.CertGen;
import ru.CryptoPro.JCPxml.Consts;
import ru.CryptoPro.JCPxml.XmlInit;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.OutputStream;
import java.security.Key;
import java.security.cert.X509Certificate;

/**
 * Пример шифрования XML.
 *
 * @author Copyright 2004-2009 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class CryptXML {
public static void main(String[] args) throws Exception {
    /**
     * Регистрация алгоритмов ГОСТ
     */
    XmlInit.init();

    /**
     * создание простого XML докуента для примера.
     */
    Document doc = createSampleDocument();
    writeDoc(doc, System.out);
    System.out.println("");

    /*
     * создание временной ключевой пары для теста.
     */
    KeyTwix twix = CertGen.generateTwix("GOST3410DHEPH",
            "GOST3411withGOST3410DHEL",
            "CN=cert");
    //KeyTwix twix = new KeyTwix("XmlSignEncrypt");

    /**
     * зашифрование "на сертификате".
     */
    encrypt(doc, twix.getCert());
    writeDoc(doc, System.out);
    System.out.println("");

    /**
     * расшифрование на секретном ключе.
     */
    decrypt(doc, twix.getPrivate());
    writeDoc(doc, System.out);
    System.out.println("");

}

/**
 * Зашифрование документа
 *
 * @param doc документ, который будем шифровать
 * @param cert сертификат
 * @return зашифрованный документ
 * @throws Exception ошибки шифрования
 */
public static Document encrypt(Document doc, X509Certificate cert)
        throws Exception {
    /**
     * Создание случайного сессионного ключа.
     */
    SecretKey sessionKey = KeyGenerator.getInstance("GOST28147").generateKey();
    /**
     * Зашифрование сессионного ключа.
     */
    EncryptedKey encryptedKey = wrapKey(doc, sessionKey, cert);
    /**
     * зашифрование документа
     */
    return encrypt(doc, sessionKey, encryptedKey);
}

/**
 * Зашифрование документа doc на sessionKey.
 *
 * @param doc документ, который будем шифровать
 * @param sessionKey сессионный ключ шифрования
 * @param encryptedKey зашифрованный sessionKey будет добавлен в документ
 * @return шифрованный документ
 * @throws Exception ошибки шифрования
 */
public static Document encrypt(Document doc, SecretKey sessionKey,
                               EncryptedKey encryptedKey) throws Exception {
    Element element = doc.getDocumentElement();
    /**
     * Создаем шифратор в режиме зашифрования. Константа URI_GOST_CIPHER
     * определена в файле ru.CryptoPro.JCPxml.Consts
     * public static final String URI_GOST_CIPHER =
     * "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gost28147";
     */
    XMLCipher xmlCipher = XMLCipher.getInstance(Consts.URI_GOST_CIPHER);
    xmlCipher.init(XMLCipher.ENCRYPT_MODE, sessionKey);
    /**
     * добавляем шифрованный ключ.
     */
    EncryptedData encryptedData = xmlCipher.getEncryptedData();
    KeyInfo keyInfo = new KeyInfo(doc);
    keyInfo.add(encryptedKey);
    encryptedData.setKeyInfo(keyInfo);
    /**
     * зашифрование документа
     */
    xmlCipher.doFinal(doc, element, true);
    return doc;
}

/**
 * зашифрование сессионного ключа &lt;code&gt;sessionKey&lt;/code&gt; и создание
 * &lt;code&gt;EncryptedKey&lt;/code&gt; с сертификатом.
 *
 * @param doc xml документ
 * @param sessionKey случайный сессионный ключ.
 * @param cert сертификат
 * @return зашифрованный ключ
 * @throws Exception ошибки шифрования
 */
public static EncryptedKey wrapKey(Document doc, SecretKey sessionKey,
                                   X509Certificate cert)
        throws Exception {
    /**
     * создание шифратора для зашифрования ключа. Константа URI_GOST_TRANSPORT
     * определена в файле ru.CryptoPro.JCPxml.Consts
     * public static final String URI_GOST_TRANSPORT =
     * "urn:ietf:params:xml:ns:cpxmlsec:algorithms:transport-gost2001";
     */
    XMLCipher keyCipher = XMLCipher.getInstance(Consts.URI_GOST_TRANSPORT);
    keyCipher.init(XMLCipher.WRAP_MODE, cert.getPublicKey());
    /**
     * создание KeyInfo с сертификатом
     */
    KeyInfo certKeyInfo = new KeyInfo(doc);
    X509Data x509data = new X509Data(doc);
    x509data.addCertificate(cert);
    certKeyInfo.add(x509data);
    /**
     * зашифрование ключа
     */
    EncryptedKey encryptedKey = keyCipher.encryptKey(doc, sessionKey);
    encryptedKey.setKeyInfo(certKeyInfo);
    return encryptedKey;
}

/**
 * Расшифрование документа.
 *
 * @param doc зашифрованный документ
 * @param key секретный ключ шифрования
 * @return расшифрованный документ
 * @throws Exception error
 */
public static Document decrypt(Document doc, Key key) throws Exception {
    /**
     * create cipher in decrypt mode.
     */
    XMLCipher xmlCipher = XMLCipher.getInstance();
    xmlCipher.init(XMLCipher.DECRYPT_MODE, null);
    /*
     * extract element to decrypt.
     */
    Element encryptedDataElement = (Element) doc.getElementsByTagNameNS(
            EncryptionConstants.EncryptionSpecNS,
            EncryptionConstants._TAG_ENCRYPTEDDATA).item(0);
    /*
     * The key to be used for decrypting xml data would be obtained
     * from the keyinfo of the EncrypteData using the kek.
     */
    if (key != null)
        xmlCipher.setKEK(key);
    /*
     * The following doFinal call replaces the encrypted data with
     * decrypted contents in the document.
     */
    xmlCipher.doFinal(doc, encryptedDataElement);
    return doc;
}

/**
 * create DocumentBuilderFactory with properties.
 *
 * @return DocumentBuilderFactory
 */
public static DocumentBuilderFactory createDocFactory() {
    // инициализация объекта чтения XML-документа
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    // установка флага, определяющего игнорирование пробелов
    // в содержимом элементов при обработке XML-документа
    dbf.setIgnoringElementContentWhitespace(true);
    // установка флага, определяющего преобразование узлов CDATA
    // в текстовые узлы при обработке XML-документа
    dbf.setCoalescing(true);
    // установка флага, определяющего поддержку пространств имен
    // при обработке XML-документа
    dbf.setNamespaceAware(true);

    return dbf;
}

/**
 * create new simple document to test. &lt;p/&gt; It will look something like:
 * &lt;p/&gt;
 * &lt;apache:RootElement xmlns:apache="http://www.apache.org/ns/#app1"&gt;
 * &lt;apache:foo&gt;Some simple text&lt;/apache:foo&gt; &lt;/apache:RootElement&gt;
 *
 * @return test document
 * @throws javax.xml.parsers.ParserConfigurationException if a DocumentBuilder
 * cannot be created which satisfies the configuration requested.
 */
public static Document createSampleDocument()
        throws ParserConfigurationException {

    DocumentBuilderFactory dbf = createDocFactory();
    Document document = dbf.newDocumentBuilder().newDocument();

    Element root = document.createElementNS("http://www.apache.org/ns/#app1",
            "apache:RootElement");
    root.setAttributeNS(Constants.NamespaceSpecNS, "xmlns:apache",
            "http://www.apache.org/ns/#app1");
    document.appendChild(root);

    root.appendChild(document.createTextNode("\n"));

    Element childElement = document.createElementNS(
            "http://www.apache.org/ns/#app1", "apache:foo");
    childElement.appendChild(document.createTextNode("Some simple text"));
    root.appendChild(childElement);

    root.appendChild(document.createTextNode("\n"));

    return document;
}

/**
 * save doc.
 *
 * @param doc document to save.
 * @param out output stream
 * @throws javax.xml.transform.TransformerException If an unrecoverable error
 * occurs during the course of the transformation.
 */
public static void writeDoc(Document doc, OutputStream out)
        throws TransformerException {
    // создание объекта копирования содержимого XML-документа в поток
    Transformer transformer = TransformerFactory.newInstance().newTransformer();
    transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
    // копирование содержимого XML-документа в поток
    transformer.transform(new DOMSource(doc), new StreamResult(out));
}

}
</java>
<java name="xmlSign/XMLSignDoc.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 13.08.2007 14:09:47 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package xmlSign;

import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xml.security.utils.Constants;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;
import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.FileOutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.logging.Logger;

/**
 * Формирование и проверка подписи всего XML-документа для алгоритма ГОСТ Р
 * 34.10-2001.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class XMLSignDoc {
 /**/
private XMLSignDoc() {
}

public static void main(String[] args) {
    try {
        //подписываемый xml документ
        final String testDoc = "tests.xml";

        //подписанный xml документ
        final String signDoc = "XmlDSigDocument.xml";

        // алгоритм ГОСТ Р 34.10-2001 (для генерирования ключевой пары)
        final String KeyPairAlgorithm = "GOST3410";

        // имя субъекта (оно же издателя) для генерирования самоподписанного сертификата
        final String certName = "CN=newCert, O=CryptoPro, C=RU";

        // алгоритм подписи (ГОСТ Р 34.10-2001)
        final String signMethod =
                "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411";

        // алгоритм хеширования, используемый при подписи (ГОСТ Р 34.11-94)
        final String digestMethod =
                "http://www.w3.org/2001/04/xmldsig-more#gostr3411";

        /* В первую очередь осуществляет регистрация алгоритма подписи ГОСТ Р 34.10-2001*/
        JCPXMLDSigInit.init();

        Logger.getLogger("LOG").info("sign doc begin");
        signDoc(KeyPairAlgorithm, certName, signMethod, digestMethod, testDoc,
                signDoc);
        Logger.getLogger("LOG").info("sign doc end\nsign doc verify");
        signDocVer(signDoc);

    } catch (Exception e) {
        e.printStackTrace();
    }
}

/**
 * Формирование подписи всего XML-документа для алгоритма ГОСТ Р 34.10-2001.
 *
 * @param keyPairAlgorithm алгоритм ГОСТ Р 34.10-2001 (для генерирования ключевой
 * пары)
 * @param certName имя субъекта (оно же издателя) для генерирования самоподписанного
 * сертификата
 * @param signMethod алгоритм подписи (ГОСТ Р 34.10-2001)
 * @param digestMethod алгоритм хеширования, используемый при подписи (ГОСТ Р
 * 34.11-94)
 * @param testDoc подписываемый документ
 * @param signDoc подписанный документ
 * @throws Exception e
 */
public static void signDoc(String keyPairAlgorithm, String certName,
                           String signMethod, String digestMethod,
                           String testDoc, String signDoc)
        throws Exception {
    /* Генерирование ключевой пары в соответствии с которой будет осуществлять подпись XML-документа*/

    // создание генератора ключевой пары ЭЦП
    final KeyPairGenerator keyGen =
            KeyPairGenerator.getInstance(keyPairAlgorithm);

    // генерирование ключевой пары
    final KeyPair keypair = keyGen.generateKeyPair();

    // получение открытого ключа
    final PublicKey publicKey = keypair.getPublic();

    // получение закрытого ключа
    final PrivateKey privateKey = keypair.getPrivate();

    /* Генерирование самоподписанного сертфиката в соответствии с ключевой парой*/

    // создание генератора самоподписанного сертификата
    final GostCertificateRequest request = new GostCertificateRequest();

    // генерирование самоподписанного сертификата, возвращаемого в DER-кодировке
    final byte[] encodedCert = request.getEncodedSelfCert(keypair, certName);

    // инициализация генератора X509-сертификатов
    final CertificateFactory cf = CertificateFactory.getInstance("X509");

    // генерирование X509-сертификата из закодированного представления сертификата
    final X509Certificate cert = (X509Certificate) cf
            .generateCertificate(new ByteArrayInputStream(encodedCert));

    /* Загружаем подписываемый XML-документ из файла */

    // инициализация объекта чтения XML-документа
    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    // установка флага, определяющего игнорирование пробелов в содержимом элементов при обработке XML-документа
    dbf.setIgnoringElementContentWhitespace(true);

    // установка флага, определяющего преобразование узлов CDATA в текстовые узлы при обработке XML-документа
    dbf.setCoalescing(true);

    // установка флага, определяющего поддержку пространств имен при обработке XML-документа
    dbf.setNamespaceAware(true);

    // загрузка содержимого подписываемого документа на основе установленных флагами правил
    final DocumentBuilder documentBuilder = dbf.newDocumentBuilder();
    final Document doc = documentBuilder.parse(testDoc);

    /* Добавление узла подписи &lt;ds:Signature&gt; в загруженный XML-документ */

    // инициализация объекта формирования ЭЦП в соответствии с алгоритмом ГОСТ Р 34.10-2001
    final XMLSignature sig = new XMLSignature(doc, "", signMethod);

    // получение корневого узла XML-документа
    final Element anElement = doc.getDocumentElement();

    // добавление в корневой узел XML-документа узла подписи
    anElement.appendChild(sig.getElement());

    /* Определение правил работы с XML-документом и добавление в узел подписи этих правил */

    // создание узла преобразований &lt;ds:Transforms&gt; обрабатываемого XML-документа
    final Transforms transforms = new Transforms(doc);

    // добавление в узел преобразований правил работы с документом
    transforms.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);
    transforms.addTransform(Transforms.TRANSFORM_C14N_WITH_COMMENTS);

    // добавление в узел подписи ссылок (узла &lt;ds:Reference&gt;), определяющих правила работы с
    // XML-документом (обрабатывается текущий документ с заданными в узле &lt;ds:Transforms&gt; правилами
    // и заданным алгоритмом хеширования)
    sig.addDocument("", transforms, digestMethod);

    /* Создание подписи всего содержимого XML-документа на основе закрытого ключа, заданных правил и алгоритмов */

    // создание внутри узла подписи узла &lt;ds:KeyInfo&gt; информации об открытом ключе на основе
    // сертификата
    sig.addKeyInfo(cert);

    // создание подписи XML-документа
    sig.sign(privateKey);

    /* Сохранение подписанного XML-документа в файл */

    // определение потока, в который осуществляется запись подписанного XML-документа
    final FileOutputStream os = new FileOutputStream(signDoc);

    // инициализация объекта копирования содержимого XML-документа в поток
    final TransformerFactory tf = TransformerFactory.newInstance();

    // создание объекта копирования содержимого XML-документа в поток
    final Transformer trans = tf.newTransformer();

    // копирование содержимого XML-документа в поток
    trans.transform(new DOMSource(doc), new StreamResult(os));
    os.close();
}

/**
 * Проверка подписи всего XML-документа для алгоритма ГОСТ Р 34.10-2001.
 *
 * @param signDoc подписанный документ
 * @throws Exception /
 */
public static void signDocVer(String signDoc) throws Exception {

    // инициализация объекта чтения XML-документа
    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    // установка флага, определяющего игнорирование пробелов в содержимом элементов при обработке XML-документа
    dbf.setIgnoringElementContentWhitespace(true);

    // установка флага, определяющего преобразование узлов CDATA в текстовые узлы при обработке XML-документа
    dbf.setCoalescing(true);

    // установка флага, определяющего поддержку пространств имен при обработке XML-документа
    dbf.setNamespaceAware(true);

    // загрузка содержимого подписываемого документа на основе установленных флагами правил
    final DocumentBuilder documentBuilder = dbf.newDocumentBuilder();

    /* Загружаем подписанный XML-документ из файла */

    final Document doc = documentBuilder.parse(signDoc);

    /* Чтение узла подписи &lt;ds:Signature&gt; из XML-документа */

    // чтение из загруженного документа содержимого пространства имени Signature
    final Element nscontext = doc.createElementNS(null, "namespaceContext");
    nscontext.setAttributeNS("http://www.w3.org/2000/xmlns/",
            "xmlns:" + "ds".trim(), Constants.SignatureSpecNS);

    // выбор из прочитанного содержимого пространства имени узла подписи &lt;ds:Signature&gt;
    final Element sigElement = (Element) XPathAPI
            .selectSingleNode(doc, "//ds:Signature[1]", nscontext);

    /* Проверка подписи XML-документа на основе информации об открытом ключе, хранящейся в
    XML-документе */

    // инициализация объекта проверки подписи
    final XMLSignature signature = new XMLSignature(sigElement, "");

    // чтение узла &lt;ds:KeyInfo&gt; информации об открытом ключе
    final KeyInfo ki = signature.getKeyInfo();

    // чтение сертификата их узла информации об открытом ключе
    final X509Certificate certKey = ki.getX509Certificate();

    // если сертификат найден, то осуществляется проверка
    // подписи на основе сертфиката
    if (certKey != null) {
        Logger.getLogger("LOG").info("The XML signature  is " +
                (signature.checkSignatureValue(certKey)
                        ? "valid (good)" : "invalid (bad)"));

    }
    // в противном случае осуществляется проверка на открытом ключе
    else {
        // чтение открытого ключа из узла информации об открытом ключе
        final PublicKey pk = ki.getPublicKey();

        // если открытый ключ найден, то на нем осуществляется проверка подписи
        if (pk != null) {
            Logger.getLogger("LOG").info(
                    "The XML signature is " + (signature.checkSignatureValue(pk)
                            ? "valid (good)" : "invalid (bad)"));
        }
        // в противном случае проверка не может быть выполнена
        else
            throw new Exception(
                    "There are no information about public key. Verification couldn't be implemented");

    }
}
}
</java>
<java name="xmlSign/XMLSignObj.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 13.08.2007 14:07:04 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package xmlSign;

import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.signature.ObjectContainer;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xml.security.utils.Constants;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;
import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.FileOutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.logging.Logger;


/**
 * Формирование и проверка подписи объекта XML-документа для алгоритма ГОСТ Р
 * 34.10-2001.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class XMLSignObj {
 /**/
private XMLSignObj() {
}

public static void main(String[] args) {
    try {
        //подписанный xml документ
        final String signObj = "XmlDSigObject.xml";

        // алгоритм ГОСТ Р 34.10-2001 (для генерирования ключевой пары)
        final String KeyPairAlgorithm = "GOST3410";

        // имя субъекта (оно же издателя) для генерирования самоподписанного сертификата
        final String certName = "CN=newCert, O=CryptoPro, C=RU";

        // идентификатор подписываемого объекта
        final String Id = "TheFirstObject";

        // алгоритм подписи (ГОСТ Р 34.10-2001)
        final String signMethod =
                "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411";

        // алгоритм хеширования, используемый при подписи (ГОСТ Р 34.11-94)
        final String digestMethod =
                "http://www.w3.org/2001/04/xmldsig-more#gostr3411";

        /* В первую очередь осуществляет регистрация алгоритма подписи ГОСТ Р 34.10-2001*/
        JCPXMLDSigInit.init();

        Logger.getLogger("LOG").info("sign obj begin");
        signObj(KeyPairAlgorithm, certName, Id, signMethod, digestMethod,
                signObj);
        Logger.getLogger("LOG").info("sign obj end\nsign obj verify");
        signObjVer(signObj);

    } catch (Exception e) {
        e.printStackTrace();
    }


}

/**
 * Формирование подписи объекта XML-документа для алгоритма ГОСТ Р 34.10-2001.
 *
 * @param keyPairAlgorithm алгоритм ГОСТ Р 34.10-2001 (для генерирования ключевой
 * пары)
 * @param certName имя субъекта (оно же издателя) для генерирования самоподписанного
 * сертификата
 * @param id идентификатор подписываемого объекта
 * @param signMethod алгоритм подписи (ГОСТ Р 34.10-2001)
 * @param digestMethod алгоритм хеширования, используемый при подписи (ГОСТ Р
 * 34.11-94)
 * @param signObj подписанный документ
 * @throws Exception e
 */
public static void signObj(String keyPairAlgorithm, String certName,
                           String id, String signMethod,
                           String digestMethod, String signObj)
        throws Exception {
/* Генерирование ключевой пары в соответствии с которой будет осуществлять подпись XML-документа*/

    // создание генератора ключевой пары ЭЦП
    final KeyPairGenerator keyGen =
            KeyPairGenerator.getInstance(keyPairAlgorithm);

    // генерирование ключевой пары
    final KeyPair keypair = keyGen.generateKeyPair();

    // получение открытого ключа
    final PublicKey publicKey = keypair.getPublic();

    // получение закрытого ключа
    final PrivateKey privateKey = keypair.getPrivate();

/* Генерирование самоподписанного сертфиката в соответствии с ключевой парой*/

    // создание генератора самоподписанного сертификата
    final GostCertificateRequest request = new GostCertificateRequest();

    // генерирование самоподписанного сертификата, возвращаемого в DER-кодировке
    final byte[] encodedCert = request.getEncodedSelfCert(keypair, certName);

    // инициализация генератора X509-сертификатов
    final CertificateFactory cf = CertificateFactory.getInstance("X509");

    // генерирование X509-сертификата из закодированного представления сертификата
    final X509Certificate cert = (X509Certificate) cf
            .generateCertificate(new ByteArrayInputStream(encodedCert));

/* Создание нового (пустого) XML-документа */

    // инициализация объекта создания XML-документа
    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    // установка флага, определяющего поддержку пространств имен при обработке XML-документа
    dbf.setNamespaceAware(true);

    // создание нового (пустого) XML-документа
    final DocumentBuilder documentBuilder = dbf.newDocumentBuilder();
    final Document doc = documentBuilder.newDocument();

/* Добавление узла подписи &lt;ds:Signature&gt; в созданный XML-документ */

    // инициализация объекта формирования ЭЦП в соответствии с алгоритмом ГОСТ Р 34.10-2001
    final XMLSignature sig = new XMLSignature(doc, "", signMethod);

    // добавление узла подписи в пустой XML-документ
    doc.appendChild(sig.getElement());

/* Создание внутри узла подписи подписываемого объекта */

    // создание узла объекта &lt;ds:Object&gt; в созданном XML-документе (в узле подписи, поскольку документ
    // состоит только из этого узла)
    final ObjectContainer obj = new ObjectContainer(doc);

    // создание подписываемого объекта с идентификатором "InsideObject"
    final Element anElement = doc.createElement("InsideObject");

    // создание текста для объекта с идентификатором "InsideObject"
    anElement.appendChild(doc.createTextNode("A text in a box"));

    // добавление объекта в узел объекта
    obj.appendChild(anElement);

    // определение идентификатора узла объекта
    obj.setId(id);

    // добавление в узел подписи созданного узла объекта
    sig.appendObject(obj);

/* Определение правил работы с XML-документом и добавление в узел подписи этих правил */

    // создание узла преобразований &lt;ds:Transforms&gt; обрабатываемого XML-документа
    final Transforms transforms = new Transforms(doc);

    // добавление в узел преобразований правил работы с документом
    transforms.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);
    transforms.addTransform(Transforms.TRANSFORM_C14N_WITH_COMMENTS);

    // добавление в узел подписи ссылок (узла &lt;ds:Reference&gt;), определяющих правила работы с
    // XML-документом (обрабатывается текущий документ с заданными в узле &lt;ds:Transforms&gt; правилами
    // и заданным алгоритмом хеширования)
    sig.addDocument("", transforms, digestMethod);

/* Создание подписи объекта XML-документа на основе закрытого ключа, заданных правил и алгоритмов */

    // создание внутри узла подписи узла &lt;ds:KeyInfo&gt; информации об открытом ключе на основе
    // сертификата
    sig.addKeyInfo(cert);

    // создание подписи объекта XML-документа
    sig.sign(privateKey);

/* Сохранение подписанного XML-документа (а точнее объекта XML-документа) в файл */

    // определение потока, в который осуществляется запись подписанного XML-документа
    final FileOutputStream os = new FileOutputStream(signObj);

    // инициализация объекта копирования содержимого XML-документа в поток
    final TransformerFactory tf = TransformerFactory.newInstance();

    // создание объекта копирования содержимого XML-документа в поток
    final Transformer trans = tf.newTransformer();

    // копирование содержимого XML-документа в поток
    trans.transform(new DOMSource(doc), new StreamResult(os));
    os.close();
}

/**
 * проверка подписи объекта XML-документа для алгоритма ГОСТ Р 34.10-2001.
 *
 * @param signObj подписанный документ
 * @throws Exception /
 */
public static void signObjVer(String signObj) throws Exception {
    // инициализация объекта создания XML-документа
    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    // установка флага, определяющего поддержку пространств имен при обработке XML-документа
    dbf.setNamespaceAware(true);

/* Загружаем подписанный XML-документ (а точнее подписанный объект XML-документа) из файла */

    final DocumentBuilder documentBuilder = dbf.newDocumentBuilder();
    final Document doc = documentBuilder.parse(signObj);

/* Чтение узла подписи &lt;ds:Signature&gt; из XML-документа */

// чтение из загруженного документа содержимого пространства имени Signature
    final Element nscontext = doc.createElementNS(null, "namespaceContext");
    nscontext.setAttributeNS("http://www.w3.org/2000/xmlns/",
            "xmlns:" + "ds".trim(), Constants.SignatureSpecNS);

// выбор из прочитанного содержимого пространства имени узла подписи &lt;ds:Signature&gt;
    final Element sigElement = (Element) XPathAPI
            .selectSingleNode(doc, "//ds:Signature[1]", nscontext);

/* Проверка подписи объекта XML-документа на основе информации об открытом ключе, хранящейся в
XML-документе */

// инициализация объекта проверки подписи
    final XMLSignature signature = new XMLSignature(sigElement, "");

// чтение узла &lt;ds:KeyInfo&gt; информации об открытом ключе
    final KeyInfo ki = signature.getKeyInfo();

// чтение сертификата их узла информации об открытом ключе
    final X509Certificate certKey = ki.getX509Certificate();

// если сертификат найден, то осуществляется проверка
// подписи на основе сертфиката
    if (certKey != null) {
        Logger.getLogger("LOG").info("The XML signature  is " +
                (signature.checkSignatureValue(certKey)
                        ? "valid (good)" : "invalid (bad)"));
    }
// в противном случае осуществляется проверка на открытом ключе
    else {
// чтение открытого ключа из узла информации об открытом ключе
        final PublicKey pk = ki.getPublicKey();

// если открытый ключ найден, то на нем осуществляется проверка подписи
        if (pk != null) {
            Logger.getLogger("LOG").info(
                    "The XML signature is " + (signature.checkSignatureValue(pk)
                            ? "valid (good)" : "invalid (bad)"));
        }
        // в противном случае проверка не может быть выполнена
        else throw new Exception(
                "There are no information about public key. Verification couldn't be implemented");
    }
}
}
</java>
<java name="xmlSign/XMLTwoSignDoc.java">/**
 * $RCSfile$
 * version $Revision: 36379 $
 * created 13.08.2007 14:27:59 by kunina
 * last modified $Date: 2012-05-30 12:19:27 +0400 (Wed, 30 May 2012) $ by $Author: afevma $
 * (C) ООО Крипто-Про 2004-2007.
 *
 * Программный код, содержащийся в этом файле, предназначен
 * для целей обучения. Может быть скопирован или модифицирован 
 * при условии сохранения абзацев с указанием авторства и прав.
 *
 * Данный код не может быть непосредственно использован
 * для защиты информации. Компания Крипто-Про не несет никакой
 * ответственности за функционирование этого кода.
 */
package xmlSign;

import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xml.security.transforms.params.XPath2FilterContainer;
import org.apache.xml.security.utils.Constants;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import ru.CryptoPro.JCPRequest.GostCertificateRequest;
import ru.CryptoPro.JCPxml.xmldsig.JCPXMLDSigInit;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.FileOutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.logging.Logger;


/**
 * Формирование и проверка двух независимых подписей всего XML-документа для
 * алгоритма ГОСТ Р 34.10-2001.
 *
 * @author Copyright 2004-2007 Crypto-Pro. All rights reserved.
 * @.Version
 */
public class XMLTwoSignDoc {
 /**/
private XMLTwoSignDoc() {
}

public static void main(String[] args) {
    try {
        //подписываемый xml документ
        String testDoc = "tests.xml";

        //подписанный xml документ
        String signTwo = "XmlTwoDSig.xml";

        // алгоритм ГОСТ Р 34.10-2001 (для генерирования ключевой пары)
        String KeyPairAlgorithm = "GOST3410";

        // имя субъекта (оно же издателя) для генерирования первого самоподписанного сертификата
        String certName1 = "CN=newCert1, O=CryptoPro, C=RU";

        // имя субъекта (оно же издателя) для генерирования второго самоподписанного сертификата
        String certName2 = "CN=newCert2, O=CryptoPro, C=RU";

        // идентификатор первого узла подписи
        String Id1 = "FirstSignature";

        // идентификатор второго узла подписи
        String Id2 = "SecondSignature";

        // алгоритм подписи (ГОСТ Р 34.10-2001)
        String signMethod =
                "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411";

        // алгоритм хеширования, используемый при подписи (ГОСТ Р 34.11-94)
        String digestMethod =
                "http://www.w3.org/2001/04/xmldsig-more#gostr3411";

        /* В первую очередь осуществляет регистрация алгоритма подписи ГОСТ Р 34.10-2001*/
        JCPXMLDSigInit.init();

        Logger.getLogger("LOG").info("two sign doc begin");
        twoSignDoc(KeyPairAlgorithm, certName1, certName2, Id1, Id2, signMethod,
                digestMethod, testDoc, signTwo);
        Logger.getLogger("LOG").info("two sign doc end\ntwo sign doc verify");
        twoSignDocVer(signTwo);

    } catch (Exception e) {
        e.printStackTrace();
    }

}

/**
 * @param keyPairAlgorithm алгоритм ГОСТ Р 34.10-2001 (для генерирования
 * ключевой пары)
 * @param certName1 имя субъекта (оно же издателя) для генерирования первого
 * самоподписанного сертификата
 * @param certName2 имя субъекта (оно же издателя) для генерирования второго
 * самоподписанного сертификата
 * @param Id1 идентификатор первого узла подписи
 * @param Id2 идентификатор второго узла подписи
 * @param signMethod алгоритм подписи (ГОСТ Р 34.10-2001)
 * @param digestMethod алгоритм хеширования, используемый при подписи (ГОСТ Р
 * 34.11-94)
 * @param testDoc подписываемый документ
 * @param signTwo подписанный документ
 * @throws Exception e
 */
public static void twoSignDoc(String keyPairAlgorithm, String certName1,
                              String certName2, String Id1, String Id2,
                              String signMethod, String digestMethod,
                              String testDoc, String signTwo)
        throws Exception {
    /* Генерирование двух ключевых пар в соответствии с которыми будут осуществляться две независимые подписи XML-документа*/

    // создание генератора ключевой пары ЭЦП
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(keyPairAlgorithm);

    // генерирование первой ключевой пары
    KeyPair keypair1 = keyGen.generateKeyPair();

    // получение открытого ключа первой ключевой пары
    PublicKey publicKey1 = keypair1.getPublic();

    // получение закрытого ключа первой ключевой пары
    PrivateKey privateKey1 = keypair1.getPrivate();

    // генерирование второй ключевой пары
    KeyPair keypair2 = keyGen.generateKeyPair();

    // получение открытого ключа второй ключевой пары
    PublicKey publicKey2 = keypair2.getPublic();

    // получение закрытого ключа второй ключевой пары
    PrivateKey privateKey2 = keypair2.getPrivate();

    /* Генерирование двух самоподписанных сертфикатов в соответствии с ключевыми парами */

    // создание генератора самоподписанного сертификата
    GostCertificateRequest request1 = new GostCertificateRequest();
    GostCertificateRequest request2 = new GostCertificateRequest();

    // генерирование первого самоподписанного сертификата, возвращаемого в DER-кодировке
    byte[] encodedCert1 = request1.getEncodedSelfCert(keypair1, certName1);

    // инициализация генератора X509-сертификатов
    CertificateFactory cf = CertificateFactory.getInstance("X509");

    // генерирование X509-сертификата из закодированного представления первого сертификата
    X509Certificate cert1 = (X509Certificate) cf
            .generateCertificate(new ByteArrayInputStream(encodedCert1));

    // генерирование второго самоподписанного сертификата, возвращаемого в DER-кодировке
    byte[] encodedCert2 = request2.getEncodedSelfCert(keypair2, certName2);

    // генерирование X509-сертификата из закодированного представления второго сертификата
    X509Certificate cert2 = (X509Certificate) cf
            .generateCertificate(new ByteArrayInputStream(encodedCert2));

    /* Загружаем подписываемый XML-документ из файла */

    // инициализация объекта чтения XML-документа
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    // установка флага, определяющего игнорирование пробелов в содержимом элементов при обработке XML-документа
    dbf.setIgnoringElementContentWhitespace(true);

    // установка флага, определяющего преобразование узлов CDATA в текстовые узлы при обработке XML-документа
    dbf.setCoalescing(true);

    // установка флага, определяющего поддержку пространств имен при обработке XML-документа
    dbf.setNamespaceAware(true);

    // загрузка содержимого подписываемого документа на основе установленных флагами правил
    DocumentBuilder documentBuilder = dbf.newDocumentBuilder();
    Document doc = documentBuilder.parse(testDoc);

    /* Добавление первого узла подписи &lt;ds:Signature&gt; в загруженный XML-документ */

    // инициализация объекта формирования ЭЦП в соответствии с алгоритмом ГОСТ Р 34.10-2001
    XMLSignature sig = new XMLSignature(doc, "", signMethod);

    // определение идентификатора первого узла подписи
    sig.setId(Id1);

    // получение корневого узла XML-документа
    Element anElement = doc.getDocumentElement();

    // добавление в корневой узел XML-документа первого узла подписи
    anElement.appendChild(sig.getElement());

    /* Определение правил работы с XML-документом и добавление в первый узел подписи этих правил */

    // создание узла преобразований &lt;ds:Transforms&gt; обрабатываемого XML-документа
    Transforms transforms = new Transforms(doc);

    // добавление в узел преобразований правил работы с документом
    transforms.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);
    transforms.addTransform(Transforms.TRANSFORM_C14N_WITH_COMMENTS);
    String[][] filters = {{XPath2FilterContainer.SUBTRACT, "//ds:Signature"}};
    transforms.addTransform(Transforms.TRANSFORM_XPATH2FILTER,
            XPath2FilterContainer.newInstances(doc, filters));

    // добавление в первый узел подписи ссылок (узла &lt;ds:Reference&gt;), определяющих правила работы с
    // XML-документом (обрабатывается текущий документ с заданными в узле &lt;ds:Transforms&gt; правилами
    // и заданным алгоритмом хеширования)
    sig.addDocument("", transforms, digestMethod);

    /* Создание первой подписи всего содержимого XML-документа на основе закрытого ключа первой ключевой пары,
    заданных правил и алгоритмов */

    // создание внутри первого узла подписи узла &lt;ds:KeyInfo&gt; информации об открытом ключе первой ключевой
    // пары на основе сертификата
    sig.addKeyInfo(cert1);

    // создание первой подписи XML-документа
    sig.sign(privateKey1);

    /* Добавление второго узла подписи &lt;ds:Signature&gt; в загруженный XML-документ */

    // инициализация объекта формирования ЭЦП в соответствии с алгоритмом ГОСТ Р 34.10-2001
    XMLSignature sigSecond = new XMLSignature(doc, "", signMethod);

    // определение идентификатора второго узла подписи
    sigSecond.setId(Id2);

    // добавление в корневой узел XML-документа второго узла подписи
    anElement.appendChild(sigSecond.getElement());

    /* Определение правил работы с XML-документом и добавление в первый узел подписи этих правил */

    // создание узла преобразований &lt;ds:Transforms&gt; обрабатываемого XML-документа
    Transforms transforms2 = new Transforms(doc);

    // добавление в узел преобразований правил работы с документом
    transforms2.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);
    transforms2.addTransform(Transforms.TRANSFORM_C14N_WITH_COMMENTS);
    transforms2.addTransform(Transforms.TRANSFORM_XPATH2FILTER,
            XPath2FilterContainer.newInstances(doc, filters));

    // добавление во второй узел подписи ссылок (узла &lt;ds:Reference&gt;), определяющих правила работы с
    // XML-документом (обрабатывается текущий документ с заданными в узле &lt;ds:Transforms&gt; правилами
    // и заданным алгоритмом хеширования)
    sigSecond.addDocument("", transforms2, digestMethod);

    /* Создание второй подписи всего содержимого XML-документа на основе закрытого ключа второй ключевой пары,
    заданных правил и алгоритмов */

    // создание внутри первого узла подписи узла &lt;ds:KeyInfo&gt; информации об открытом ключе второй ключевой
    // пары на основе сертификата
    sigSecond.addKeyInfo(cert2);

    // создание второй подписи XML-документа
    sigSecond.sign(privateKey2);

    /* Сохранение подписанного XML-документа в файл */

    // определение потока, в который осуществляется запись подписанного XML-документа
    FileOutputStream os = new FileOutputStream(signTwo);

    // инициализация объекта копирования содержимого XML-документа в поток
    TransformerFactory tf = TransformerFactory.newInstance();

    // создание объекта копирования содержимого XML-документа в поток
    Transformer trans = tf.newTransformer();

    // копирование содержимого XML-документа в поток
    trans.transform(new DOMSource(doc), new StreamResult(os));
    os.close();
}

/**
 * проверка двух независимых подписей всего XML-документа для алгоритма ГОСТ Р
 * 34.10-2001.
 *
 * @param signTwo подписанный документ
 * @throws Exception /
 */
public static void twoSignDocVer(String signTwo) throws Exception {
    // инициализация объекта чтения XML-документа
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    // установка флага, определяющего игнорирование пробелов в содержимом элементов при обработке XML-документа
    dbf.setIgnoringElementContentWhitespace(true);

    // установка флага, определяющего преобразование узлов CDATA в текстовые узлы при обработке XML-документа
    dbf.setCoalescing(true);

    // установка флага, определяющего поддержку пространств имен при обработке XML-документа
    dbf.setNamespaceAware(true);

    // загрузка содержимого подписываемого документа на основе установленных флагами правил
    DocumentBuilder documentBuilder = dbf.newDocumentBuilder();

    /* Загружаем подписанный XML-документ из файла */
    Document doc = documentBuilder.parse(signTwo);

    /* Чтение узла подписи &lt;ds:Signature&gt; из XML-документа */

    // чтение из загруженного документа содержимого пространства имени Signature
    Element nscontext = doc.createElementNS(null, "namespaceContext");
    nscontext.setAttributeNS("http://www.w3.org/2000/xmlns/",
            "xmlns:" + "ds".trim(), Constants.SignatureSpecNS);

    // определенеи двух узлов подписи
    Element[] sigElement = new Element[2];

    // выбор из прочитанного содержимого пространства имени первого узла подписи &lt;ds:Signature&gt;
    sigElement[0] = (Element) XPathAPI.selectSingleNode(doc,
            "//ds:Signature[@Id='FirstSignature']", nscontext);

    // выбор из прочитанного содержимого пространства имени первого узла подписи &lt;ds:Signature&gt;
    sigElement[1] = (Element) XPathAPI.selectSingleNode(doc,
            "//ds:Signature[@Id='SecondSignature']", nscontext);

    /* Проверка двух подписей XML-документа на основе соответствующей информации об открытом ключе, хранящейся в
   XML-документе */

    // определение двух объектов проверки подписи
    XMLSignature[] signature = new XMLSignature[2];

    // инициализация первого объекта проверки подписи
    signature[0] = new XMLSignature(sigElement[0], "");

    // инициализация второго объекта проверки подписи
    signature[1] = new XMLSignature(sigElement[1], "");

    // процесс последовательной проверки двух подписей
    for (int i = 0; i &lt; 2; i++) {

        // чтение узла &lt;ds:KeyInfo&gt; информации об открытом ключе
        KeyInfo ki = signature[i].getKeyInfo();

        // чтение сертификата их узла информации об открытом ключе
        X509Certificate certKey = ki.getX509Certificate();

        // если сертификат найден, то осуществляется проверка
        // подписи на основе сертфиката
        if (certKey != null) {
            Logger.getLogger("LOG")
                    .info("The XML signature " + (i + 1) + " is " +
                            (signature[i].checkSignatureValue(certKey)
                                    ? "valid (good)" : "invalid (bad)"));
        }
        // в противном случае осуществляется проверка на открытом ключе
        else {
            // чтение открытого ключа из узла информации об открытом ключе
            PublicKey pk = ki.getPublicKey();

            // если открытый ключ найден, то на нем осуществляется проверка подписи
            if (pk != null) {
                Logger.getLogger("LOG")
                        .info("The XML signature " + (i + 1) + " is " +
                                (signature[i].checkSignatureValue(pk)
                                        ? "valid (good)" : "invalid (bad)"));
            }
            // в противном случае проверка не может быть выполнена
            else throw new Exception(
                    "There are no information about public key. Verification couldn't be implemented");

        }
    }

}
}
</java>
</javaproject>
</code>

<item name="$JavaCompilerSource">
<text>1.6</text>
</item>
<item name="$JavaCompilerTarget">
<text>1.6</text>
</item>
</agent>
